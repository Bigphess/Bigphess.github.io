<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.1',
    sidebar: {"position":"right","display":"always","offset":12,"onmobile":true,"dimmer":true},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="今天开始努力学习">
<meta property="og:url" content="https://bigphess.github.io/page/5/index.html">
<meta property="og:site_name" content="今天开始努力学习">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="今天开始努力学习">






  <link rel="canonical" href="https://bigphess.github.io/page/5/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>今天开始努力学习 – 面向谷歌编程选手许若芃</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">今天开始努力学习</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">面向谷歌编程选手许若芃</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories<span class="badge">53</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives<span class="badge">76</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/Bigphess" class="github-corner" title="垃圾代码都在我的github！" aria-label="垃圾代码都在我的github！" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigphess.github.io/2019/05/07/Leetcode笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RUOPENG XU">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天开始努力学习">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/07/Leetcode笔记/" class="post-title-link" itemprop="url">Leetcode笔记</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 21:57:42" itemprop="dateCreated datePublished" datetime="2019-05-07T21:57:42+09:00">2019-05-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-10-25 10:28:40" itemprop="dateModified" datetime="2019-10-25T10:28:40+09:00">2019-10-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进度："><a href="#进度：" class="headerlink" title="进度："></a>进度：</h1><ul>
<li>array部分差不多</li>
<li>string部分提高往后没有继续</li>
<li>math部分浅尝辄止</li>
<li>开始搞树的部分</li>
</ul>
<h1 id="1-twoSum"><a href="#1-twoSum" class="headerlink" title="1 twoSum"></a>1 twoSum</h1><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:</p>
<p>Given nums = [2, 7, 11, 15], target = 9,</p>
<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - item <span class="keyword">in</span> nums <span class="keyword">and</span> nums.index(target - item) != i:</span><br><span class="line">                <span class="keyword">return</span> [i, nums.index(target - item)]</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>刚开始用了直接for所有的元素的方法，忘记考虑当两个数字重复的时候需要怎么办，考虑了之后在非常大的数的情况下爆炸了</li>
<li>标准答案说到了hash表，但是其实在python实现里面本身就是个hash（不然怎么从索引得到结果），不需要考虑这个问题</li>
<li>然后考虑了把所有东西都放一个dict里面（毕竟hash？），但是遇到的问题是从value直接得到key会生一些问题。如果把数字作为key，索引作为value会发现数字有重复的，会覆盖key的值</li>
<li>这时候突然发现，如果用数字作为索引的话其实dict和list没有本质区别，在list里面操作就行了，而且list的<code>.index()</code>可以直接返回这个值得坐标（找到的是第一个值！！）</li>
<li>所以直接用enumerate把所有的index和item都列出来就可以解决了，神奇。</li>
</ul>
<h1 id="27-remove-element"><a href="#27-remove-element" class="headerlink" title="27 remove element"></a>27 remove element</h1><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>Example 1:</p>
<p>Given nums = [3, 2, 2, 3], val = 3,</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p>It doesn’t matter what you leave beyond the returned length.<br>Example 2:</p>
<p>Given nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2,</p>
<p>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</p>
<p>Note that the order of those five elements can be arbitrary.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        remove_nums = <span class="number">0</span></span><br><span class="line">        ori_length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                remove_nums += <span class="number">1</span></span><br><span class="line">                nums[i] = float(<span class="string">'inf'</span>)</span><br><span class="line">        nums.sort()</span><br><span class="line">        nums = nums[:ori_length - remove_nums]</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>这道题的重点是需要in - place的处理，空间复杂度要求很高（然而我的空间结果很垃圾）。一个重点就是返回的list不需要按照原来的顺序排列</li>
<li>从不需要原来的顺序得到的思路是：我把需要删除的东西的位置改成了inf，然后对所有部分进行排序，得到排序之后的结果再进行切片（这里刚开始的思路是删掉这个地方的东西然后再insert，后来发现直接替换就好了）</li>
<li>其实也可以直接用交换位置的方法，不用切片，因为题目只需要前面的这些元素符合要求就可以了，没有说后面的怎么样。</li>
<li>看了一些discussion都是memory只比5 % 的人少。。。但是差距都不大应该没问题！</li>
</ul>
<p>看到了一个超级牛逼简要写法：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> val <span class="keyword">in</span> nums:</span><br><span class="line">    nums.remove(val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure></p>
<h1 id="80"><a href="#80" class="headerlink" title="80"></a>80</h1><p>Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>Example 1:</p>
<p>Given nums = [1, 1, 1, 2, 2, 3],</p>
<p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</p>
<p>It doesn’t matter what you leave beyond the returned length.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= len(nums) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> len(nums) &gt; <span class="number">2</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">2</span>]:</span><br><span class="line">                    nums = nums[:nums.index(nums[i]) + <span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                next_num = nums[i + <span class="number">1</span>]</span><br><span class="line">                start_index = nums.index(nums[i])</span><br><span class="line">                next_index = nums.index(next_num)</span><br><span class="line">                <span class="keyword">if</span> next_index - start_index &gt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">for</span> l <span class="keyword">in</span> range(start_index + <span class="number">2</span>, next_index):</span><br><span class="line">                        nums[l] = float(<span class="string">'inf'</span>)</span><br><span class="line">                i = next_index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> float(<span class="string">'inf'</span>) <span class="keyword">in</span> nums:</span><br><span class="line">            nums.remove(float(<span class="string">'inf'</span>))</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>我深信我的方法虽然蠢但是没有问题，但是跑出来就是有问题，分明我return之前的数据还都是对的，但是return之后显示的东西就都有问题了</li>
<li>主要思路是这样的<ul>
<li>因为in - place操作，所以就不能直接用remove去掉元素导致下标错乱</li>
<li>本来是想和上面的思路一样，换成inf，然后再把有inf的部分删除掉（参考了  # 27的简易解法）</li>
<li>怎么换成inf呢，我判断的方法是找到下一个值得index，然后计算这个index和上一个之间差多少个数，然后把富裕的数字都替换成inf</li>
</ul>
</li>
<li>忽略的问题：<ul>
<li>数数数错了很多问题</li>
<li>最开始没有考虑到什么停止</li>
<li>然后没有考虑到如果最后一个数字重复了两遍以上要怎么办的问题（这也是我用next_index的一个弊端）</li>
</ul>
</li>
</ul>
<p><strong>然后看着大佬的代码哭出了声！！！</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">2</span> <span class="keyword">or</span> n != nums[i - <span class="number">2</span>]:</span><br><span class="line">                nums[i] = n</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></p>
<p>总结：</p>
<ul>
<li>哇这个思路真的牛逼！</li>
<li>中心思想就是让n来增加但是i不增加，这里已经说了不在意前面项之后list里面的内容，也就是说前n项之后的东西都不用管了。既然如此的话与其用inf来替换这个位置的数字，不如直接用后面的项填在相对应的位置上，只有填成功了才会增加i</li>
<li>这里需要<strong>先判断i的值是否小于2，然后再计算nums[i - 2]，否则会out of range</strong></li>
<li>i跑的速度没有超过n跑的速度所以没有关系</li>
<li>合理利用题里面的条件限制真的很重要！！</li>
</ul>
<h1 id="189-Rotate-array"><a href="#189-Rotate-array" class="headerlink" title="189 Rotate array"></a>189 Rotate array</h1><p>Given an array, rotate the array to the right by k steps, where k is non - negative.</p>
<p>Example 1:</p>
<p>Input: [1, 2, 3, 4, 5, 6, 7] and k = 3<br>Output: [5, 6, 7, 1, 2, 3, 4]<br>Explanation:<br>rotate 1 steps to the right: [7, 1, 2, 3, 4, 5, 6]<br>rotate 2 steps to the right: [6, 7, 1, 2, 3, 4, 5]<br>rotate 3 steps to the right: [5, 6, 7, 1, 2, 3, 4]</p>
<p>Example 2:</p>
<p>Input: [-1, -100, 3, 99] and k = 2<br>Output: [3, 99, -1, -100]<br>Explanation:<br>rotate 1 steps to the right: [99, -1, -100, 3]<br>rotate 2 steps to the right: [3, 99, -1, -100]</p>
<p>Note:</p>
<p>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br>Could you do it in-place with O(1) extra space?</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>需不需要注意k = 0的时候</li>
<li>如果k的个数特别大需不需要简化一下</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        steps = k % len(nums)</span><br><span class="line">        unchange_nums = nums[:len(nums) - steps]</span><br><span class="line">        change_nums = nums[len(nums) - steps:]</span><br><span class="line">        nums[:steps] = change_nums</span><br><span class="line">        nums[steps:] = unchange_nums</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>居然第一种就这么写出来了，实际上就是把后面的数字移动到前面去</li>
<li>注意nums不能直接用change_nums + unchange_nums，大概是他认为这个不是in - place了吧</li>
</ul>
<h1 id="另一种方法：in-place"><a href="#另一种方法：in-place" class="headerlink" title="另一种方法：in-place"></a>另一种方法：in-place</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    k = k % len(nums)</span><br><span class="line">    self.reverse_nums(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">    self.reverse_nums(nums, <span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">    self.reverse_nums(nums, k, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_nums</span><span class="params">(self,nums,start,end)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        temp = nums[start]</span><br><span class="line">        nums[start] = nums[end]</span><br><span class="line">        nums[end] = temp</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">        end -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实际上，rotate的另外一种方法是先把整个list反向，然后把前面的k个反向，然后再把后面的(n-k)个反向（这里我是没想到的）</li>
<li>把一个数组反向的算法就是从两头向中间逼近着交换（我该好好去看看基础的算法了。。）</li>
<li>最后，还有一种方法是跳着设置值，也就是说k个之后的值就应该是现在这个位置的值</li>
</ul>
<h1 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41 First Missing Positive"></a>41 First Missing Positive</h1><p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p>Example 1:</p>
<p>Input: [1,2,0]<br>Output: 3<br>Example 2:</p>
<p>Input: [3,4,-1,1]<br>Output: 2<br>Example 3:</p>
<p>Input: [7,8,9,11,12]<br>Output: 1<br>Note:</p>
<p>Your algorithm should run in O(n) time and uses constant extra space.</p>
<h1 id="第一个思路：时间nlog-n"><a href="#第一个思路：时间nlog-n" class="headerlink" title="第一个思路：时间nlog(n)"></a>第一个思路：时间nlog(n)</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        target = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n == target:</span><br><span class="line">                target += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure>
<ul>
<li>这个思路整体建立在先排序的基础上，但是排序的时间复杂度本身就已经是nlog(n)了</li>
<li>排序 - 找到比0大的数字从这里开始 - 这个数字不符合的话找下一个<ul>
<li>但是我在找比0大的数字的时候还想着把list切片，切片就又需要考虑0啊，1啊，缺多少个数字的问题，空的list。其实根本不用这么麻烦</li>
<li>本质上这个方法就是，找到miss的正数，那就从正数的第一个（1）开始找，如果找到了这个数就继续找下一个（target++），总是能找到的嘛，找到的就是缺的数字了</li>
</ul>
</li>
</ul>
<hr>
<p><strong>自己的方法</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            target_num = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == target_num:</span><br><span class="line">                <span class="keyword">if</span> i == len(nums) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> target_num + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> target_num <span class="keyword">in</span> nums:</span><br><span class="line">                temp = nums.index(target_num)</span><br><span class="line">                nums[temp],nums[i] = nums[i], nums[temp]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> target_num</span><br></pre></td></tr></table></figure></p>
<ul>
<li>桶排序：要把对应的数字放在对应的位置上<ul>
<li>这道题里应该的样子就是nums[index] = index + 1</li>
</ul>
</li>
<li>大佬的思路 -&gt; 首先判断边界条件！！(学到了学到了)</li>
<li>看过了上面的提示写出来的第二版<ul>
<li>判断边界条件</li>
<li>判断这个数字是不是摆在了正确的位置<ul>
<li>正确，判断是否是最后一个数字<ul>
<li>是，输出的是最后一个数字+1</li>
<li>不是，这个位置的正确了，判断下一个位置</li>
</ul>
</li>
<li>没有，判断nums里面还有没有应该摆在这个位置的数字<ul>
<li>有，那就和这个位置交换</li>
<li>没有，那没有的数字就是缺少的数字了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>因为每次都是把数字换到了正确的位置了，所以交换最多进行len(nums)次，时间复杂度是O(n)</li>
</ul>
<hr>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt;= nums[i]<span class="number">-1</span> &lt; len(nums) <span class="keyword">and</span> nums[nums[i]<span class="number">-1</span>] != nums[i]:</span><br><span class="line">            tmp = nums[i]<span class="number">-1</span></span><br><span class="line">            nums[i], nums[tmp] = nums[tmp], nums[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> len(nums)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>大佬的另一个方法，其实思路和上面的差不多，就是把数字换到正确的位置上，但是判断的条件和我的有一点不同，可能因为我的是基于python的功能</li>
<li>其中，换到正确位置的数字就是在1到len(nums)之间的数字。nums[i]-1是这个数字应该的坐标位置，如果应该的位置和现在的位置的数字不一样，那就交换这两个数字<ul>
<li>注意这里需要用while换，要一直换到正确的位置才可以</li>
</ul>
</li>
<li>这样的结果就是大家都按正确的填好了，最后不对的那个位置的index+1就是需要的结果</li>
</ul>
<h1 id="299"><a href="#299" class="headerlink" title="299"></a>299</h1><p>You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. </p>
<p>Please note that both secret number and friend’s guess may contain duplicate digits.</p>
<p>Example 1:</p>
<p>Input: secret = “1807”, guess = “7810”</p>
<p>Output: “1A3B”</p>
<p>Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.<br>Example 2:</p>
<p>Input: secret = “1123”, guess = “0111”</p>
<p>Output: “1A1B”</p>
<p>Explanation: The 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow.<br>Note: You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.</p>
<hr>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHint</span><span class="params">(self, secret: str, guess: str)</span> -&gt; str:</span></span><br><span class="line">        bull = sum(a == b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(secret,guess))</span><br><span class="line">        cow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> set(guess):</span><br><span class="line">            cow  += min(secret.count(x),guess.count(x))        </span><br><span class="line">        <span class="keyword">return</span> str(bull) + <span class="string">"A"</span> + str(cow-bull) + <span class="string">"B"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里自己想了一些比较蠢的想法之后直接参考别人的了<ul>
<li>其一是比对他们两个位置和数字都相同的东西，想要转换成dict来比较，但是后来发现string就可以直接index了不用这么麻烦</li>
<li>想过能不能按位做减法，未果</li>
<li>其二是在得到了bull之后把bull的部分从原来的里面剔除出去然后再比较相似的数字</li>
</ul>
</li>
<li>遇到了主要问题是重复的数字怎么办以及如何剔除出去bull</li>
<li>主要思路是这样的：<ul>
<li>其实cow的数量就是bull-cow都是的数量减去bull的数量，也就相当于维恩图里面，只有A的量是A的量 - 同时AB的量。这里是bull就相当于AB都有，两个里面所有重复的数量就相当于A的量<ul>
<li>这样可以做减法就解决了上面的从bull得到cow的问题！！</li>
<li>所以说看问题还是要看本质</li>
</ul>
</li>
<li>面对重复的数字，居然可以直接把string转换成set<ul>
<li>这里复习一下set好吗！！！这个集合居然可以没有重复的元素，平常我忽视你了呀小可爱，转化成set就不会重复了哦，震惊！！</li>
</ul>
</li>
<li>这样问题就变成了：<ul>
<li>求bull：用<strong>zip</strong>把两个东西一一对应的打包起来（居然还有你小可爱！）直接对比</li>
<li>求both：guess里面猜的次数就是总体的次数，secret里面的次数是真实的次数，对于每个在guess里面（set）的元素都看看分别在两个里面是多少个，然后小的那个就是both的大小<ul>
<li>这里介绍<code>.count()</code>小可爱，居然还可以数数！</li>
</ul>
</li>
<li>最后both-bull就是结果了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="134-gas-station"><a href="#134-gas-station" class="headerlink" title="134 gas station"></a>134 gas station</h1><p>居然自己搞出来了一个看起来很蠢的<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> sum(gas) &lt; sum(cost): <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        tank = <span class="number">0</span></span><br><span class="line">        current = <span class="number">0</span></span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            tank = tank + gas[current] - cost[current]</span><br><span class="line">            <span class="keyword">if</span> tank &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> current &lt; len(gas):</span><br><span class="line">                    current = current + <span class="number">1</span></span><br><span class="line">                    counter = <span class="number">0</span></span><br><span class="line">                    tank = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line">            current = current % len(gas)</span><br><span class="line">            counter += <span class="number">1</span></span><br><span class="line">            <span class="comment"># print(current,counter)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> counter == len(gas):</span><br><span class="line">                <span class="keyword">return</span> current % len(gas)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><del>~时间超过了百分之48的人，感觉可能还可以吧</del>~时间都是骗人的又跑了一次居然超过了百分之86的！！</li>
<li>重点<ul>
<li>一直按着顺序跑，不会跳着走</li>
<li>如果gas的总量从一开始就小于cost的总量，那绝对不可能</li>
</ul>
</li>
<li>我的思路：<ul>
<li>从第一个点开始试着跑，一直到试着从最后一个点开始跑，找到了就直接返回</li>
<li>增加一个计数的var，记一共跑了多远，因为是按着顺序跑的所以这个var等于gas的长度的时候就是跑完了</li>
<li>避免out of range问题，需要求余数</li>
</ul>
</li>
<li>遇到问题：<ul>
<li>当tank小于0，更新完条件之后记得continue继续循环呀</li>
<li>刚开始想用的判断条件是for或者while里面带条件，还想了一下要不要zip这两个数据，但是都是list实在是没有必要。但是感觉是想的实在是太多了</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span> </span><br><span class="line">        <span class="keyword">if</span> sum(gas) &lt; sum(cost): <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        rest = start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            rest += gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">if</span> rest &lt; <span class="number">0</span>:</span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">                rest = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure>
<ul>
<li>居然有这么简要的写法！！</li>
<li><strong>所以只要不是sum(gas) &lt; sum(cost)就一定会有解诶，神奇。也就是说我上面有一个返回的-1是没有意义的</strong></li>
<li>而且用for的话就不用再考虑counter的问题了</li>
<li>从哪里失败就从哪里的下一个爬起来</li>
</ul>
<h1 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118 Pascal’s Triangle"></a>118 Pascal’s Triangle</h1><p>Example:</p>
<p>Input: 5<br>Output:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(numRows):</span><br><span class="line">            now_row = []</span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">0</span>:</span><br><span class="line">                now_row = [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> row == <span class="number">1</span>:</span><br><span class="line">                now_row = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now_row = [<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">for</span> member <span class="keyword">in</span> range(<span class="number">1</span>,row):</span><br><span class="line">                    now_row.append(result[row<span class="number">-1</span>][member<span class="number">-1</span>] + result[row<span class="number">-1</span>][member])</span><br><span class="line">                </span><br><span class="line">                now_row.append(<span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">            result.append(now_row)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>总算是自己写出来一个东西了</li>
<li>好简单，除了前两行是特定的，其他的可以归为一类</li>
<li>求一个简单的数学关系就行了，数数别数错了！！注意数0</li>
<li><strong>唯一没有注意的点就是：事先不知道list的大小，所以初始化成空的之后需要用append添加元素</strong></li>
</ul>
<h1 id="119-杨辉三角形2"><a href="#119-杨辉三角形2" class="headerlink" title="119 杨辉三角形2"></a>119 杨辉三角形2</h1><p>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.</p>
<p>Input: 3<br>Output: [1,3,3,1]</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex: int)</span> -&gt; List[int]:</span></span><br><span class="line">        L = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> len(L) == rowIndex + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> L</span><br><span class="line">            L = [u+v <span class="keyword">for</span> u,v <span class="keyword">in</span> zip([<span class="number">0</span>]+L,L+[<span class="number">0</span>])]</span><br></pre></td></tr></table></figure>
<ul>
<li>没想到杨辉三角形的代码也有简要的解法，这个是用L记录了上一行的信息，然后再把这行扩充两个0，相当于这个三角形的本质是两行错位相加！！</li>
<li>注意最后的L得到的是一个list，list要有list的样子</li>
<li>更加理解了一下zip和单行for的用法</li>
<li>index从0开始，结果开始没有注意到</li>
<li>while true 加上一个 if的效果等同于for的效果！！！越写越糊涂</li>
</ul>
<h1 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169 Majority Element"></a>169 Majority Element</h1><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example 1:</p>
<p>Input: [3,2,3]<br>Output: 3<br>Example 2:</p>
<p>Input: [2,2,1,1,1,2,2]<br>Output: 2</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>思路：这回想到了很多历遍的方法，但是感觉太蠢了，终于开始想怎么才能更好的实现了</li>
<li>在写写画画的时候突然考虑到，如果有超过一半的数量都是这个数的话，把这个list排序之后最中间的那个数肯定是这个数<ul>
<li>极限情况就是两个元素差1，这时候是多一点的那个数的边界上</li>
<li>其他的情况下就是在出现最多的那个数的中间</li>
</ul>
</li>
<li>本来想要用floor的，但是发现需要math包，所以用了 // 来求除之后的整数</li>
</ul>
<h1 id="229-Majority-Element-2"><a href="#229-Majority-Element-2" class="headerlink" title="229 Majority Element 2"></a>229 Majority Element 2</h1><p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</p>
<p>Note: The algorithm should run in linear time and in O(1) space.</p>
<p>Example 1:</p>
<p>Input: [3,2,3]<br>Output: [3]<br>Example 2:</p>
<p>Input: [1,1,1,3,3,2,2,2]<br>Output: [1,2]<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        major1,major2,count1,count2 = <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> major1 == n:</span><br><span class="line">                count1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> major2 ==n:</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count1 ==<span class="number">0</span>:</span><br><span class="line">                major1 = n</span><br><span class="line">                count1 = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count2 == <span class="number">0</span>:</span><br><span class="line">                major2 = n</span><br><span class="line">                count2 =<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count1 -= <span class="number">1</span></span><br><span class="line">                count2 -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [n <span class="keyword">for</span> n <span class="keyword">in</span> (major1,major2) <span class="keyword">if</span> nums.count(n) &gt; len(nums) // <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意这道题说的是出现次数大于1/3的数字，所以结果只有只能是没有，1个或者两个，不存在结果是三个的情况！</li>
<li>这个想了半天不会做，查了一下用的是<a href="https://www.zhihu.com/question/49973163/answer/235921864" target="_blank" rel="noopener">Boyer-Moore Majority Vote algorithm</a><ul>
<li>这个算法的主要意思是如果两拨人打架，打架一对一抵消，然后看看剩下的部分哪个比较多<ul>
<li>记录剩下的东西的方法就是增加了一个额外的部分，包括major和count两部分，major记录的是有剩余的数是什么，count记录还有多少个</li>
<li>如果count没有了，那么就从现在遇到的新的数开始记</li>
<li>如果现在的数不是需要的，那么count - 1，如果是现在需要的那么count + 1</li>
</ul>
</li>
<li>最开始是用在一个数组里面找超过一半的数的，但是我上一道题用了其他方法所以没用到</li>
<li>注意因为是求1/3的数字，所以虽然有剩下的，但是剩下的不一定都是符合要求的，需要再数一下个数对不对（这才有了return这一行里面的东西）</li>
</ul>
</li>
<li>人类的算法真是奇幻无穷</li>
</ul>
<h1 id="274-h-index"><a href="#274-h-index" class="headerlink" title="274 h-index"></a>274 h-index</h1><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”</p>
<p>Example:</p>
<p>Input: citations = [3,0,6,1,5]<br>Output: 3<br>Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had<br>             received 3, 0, 6, 1, 5 citations respectively.<br>             Since the researcher has 3 papers with at least 3 citations each and the remaining<br>             two with no more than 3 citations each, her h-index is 3.<br>Note: If there are several possible values for h, the maximum one is taken as the h-index.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> h_cand <span class="keyword">in</span> range(len(citations) + <span class="number">1</span>):</span><br><span class="line">            h_more = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> citation <span class="keyword">in</span> citations:</span><br><span class="line">                <span class="keyword">if</span> citation &gt;= h_cand:</span><br><span class="line">                    h_more += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> h_more &gt;= h_cand:</span><br><span class="line">                    result = max(result,h_cand)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>思路，非常直观的方法，直接iterate所有的元素，如果找到了更大的result的值就取最大的（根据题目要求）</li>
<li>注意的点在需要 <code>h_more &gt;= h_cand</code>而不是等于，因为给出的定义的意思是index-h是有h个的值大于等于h，h_more的个数会比h_cand多（但是因为取了下面的max，所以等于其实也是可以得）</li>
<li>这个的速度真的好慢，尝试一下binary search</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        bucket = [<span class="number">0</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(len(citations)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> citations:</span><br><span class="line">            <span class="keyword">if</span> nums &gt;= len(citations):</span><br><span class="line">                bucket[len(citations)] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bucket[nums] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> range(len(bucket)):</span><br><span class="line">            nums = len(bucket) - nums <span class="number">-1</span></span><br><span class="line">            result += bucket[nums]</span><br><span class="line">            <span class="keyword">if</span> result &gt;= nums:</span><br><span class="line">                <span class="keyword">return</span> nums</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用了桶排序的神奇方法</li>
<li>还是取决于定义，如果一共有5个paper的话，可以选的h的值有6个，分别是0 1 2 3 4 5，把这留个值分成六个桶，每个里面放的就是比这桶的inde等于的paper的数量<ul>
<li>如果总数直接大于最大的桶数，就放在最后一个里面</li>
<li>这是在第一个循环干的事情</li>
</ul>
</li>
<li>第二个循环里，把这些桶里面的值取出来就是比这个桶的index大于等于的paper的数量，从后往前数，如果这个paper的数量大于了现在的index，那就说明现在的index就是h！</li>
<li>这里学到了一个创建固定长度列表的方法<code>bucket = [0 for n in range(len(citations)+1)]</code></li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        citations.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,n <span class="keyword">in</span> enumerate(citations):</span><br><span class="line">            <span class="keyword">if</span> n &gt;= i+<span class="number">1</span>:</span><br><span class="line">                result = max(result,i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>再另一种思路，用了排序<ul>
<li>如果把这个list按降序排序的话，index的数量加一就是目前数过的paper的数量，citation[index]就是这个数量上面对应的citation的数量，这两个值应该正好相等，或者citation更大一点，需要在排好序的内容里面找到这一项！</li>
</ul>
</li>
<li>这样速度比桶排序稍微慢一点但是还是蛮快的，起码比第一种要快很多了</li>
</ul>
<h1 id="275-h-index-2"><a href="#275-h-index-2" class="headerlink" title="275 h-index 2"></a>275 h-index 2</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(citations)</span><br><span class="line">        l, r = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> citations[mid] &gt;= n-mid:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n-l</span><br></pre></td></tr></table></figure>
<ul>
<li>可以依然沿用上面的方法，但是可能是因为数据量上去的原因，所以速度变慢了</li>
<li>这里可以加入二分法搜索取代上面的直接iterate<ul>
<li>while的条件是因为移动一位，所以会出现l&gt;r的情况，在这种情况下就可以停下来了</li>
<li>二分法就是这么写的！</li>
</ul>
</li>
</ul>
<h1 id="217-contains-duplicate"><a href="#217-contains-duplicate" class="headerlink" title="217 contains duplicate"></a>217 contains duplicate</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> nums.count(n) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        setNums = set(nums)</span><br><span class="line">        <span class="keyword">if</span> len(setNums) == len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>消耗时间太长了！！</li>
<li>说明这个count的时间还是不可以</li>
<li>想到了用set但是没相当怎么用set<ul>
<li>set可以把有重复内容的变成没有重复内容的！！</li>
<li>所以set和list的长度是不一样的</li>
</ul>
</li>
</ul>
<h1 id="219-contains-duplicate2"><a href="#219-contains-duplicate2" class="headerlink" title="219 contains duplicate2"></a>219 contains duplicate2</h1><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1], k = 3<br>Output: true<br>Example 2:</p>
<p>Input: nums = [1,0,1,1], k = 1<br>Output: true<br>Example 3:</p>
<p>Input: nums = [1,2,3,1,2,3], k = 2<br>Output: false</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(set(nums)) &gt;= len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        extra = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> extra <span class="keyword">and</span> i-extra[n] &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            extra[n] = i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意这里需要找到的差的绝对值是最大是k，所以找到一个比k小的很容易！！只要找到就能返回</li>
<li>判断边界条件</li>
<li>把元素作为key放进extra里面，val是这个元素的index，因为key是唯一的所以可以一直找到离得最近的index，这样就越来越能确保满足条件，一旦满足条件就返回，如果所有的都不满足就false</li>
</ul>
<h1 id="220"><a href="#220" class="headerlink" title="220"></a>220</h1><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1], k = 3, t = 0<br>Output: true<br>Example 2:</p>
<p>Input: nums = [1,0,1,1], k = 1, t = 2<br>Output: true<br>Example 3:</p>
<p>Input: nums = [1,5,9,1,5,9], k = 2, t = 3<br>Output: false</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(self, nums: List[int], k: int, t: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> t &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        buckets = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            bucket = nums[i] // (t+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> bucket - <span class="number">1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> nums[i] - buckets[bucket<span class="number">-1</span>] &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> bucket + <span class="number">1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> buckets[bucket+<span class="number">1</span>] - nums[i] &lt;=t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            buckets[bucket] = nums[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                <span class="keyword">del</span> bucket[nums[i-k] // (t+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运用的是桶排序的思路，每个nums[i]会放在一个桶里，这个桶的宽度是这两个数字的差<ul>
<li>如果想要这两个数值的差值小于等于t，那么需要这两个数字在一个桶里或者在相邻的桶里（因为后面增加了k的判断条件，所以不用考虑k）</li>
</ul>
</li>
<li><p>思路</p>
<ul>
<li>首先考虑了一下k，如果i大于k的时候，就可以直接扔掉i-k之前的数据了，只考虑中间的k+1个数据，这样的话空间复杂度很低。这里的扔掉指的是把bucket里面的值直接扔掉，这样就避免了找到在相同的桶里面却i和j的差值超过k的问题</li>
<li>首先iterate整个nums，把不同的数字放在不同的桶里，注意桶的个数是t+1</li>
<li>然后如果在放之前这个桶有东西，或者相邻的桶的值和现在的值的差是小于等于t的，那么就存在，返回true</li>
<li>如果都不存在的话，把现在的数字放到对应的桶里面</li>
</ul>
</li>
<li><p>另外一个思路考虑的是二叉树的数据结构，用这个结构可以很快的搜索到离这个数最近的数据并且判断这个数据和这个数的差是不是小于t！</p>
</li>
</ul>
<h1 id="55-Jump-game"><a href="#55-Jump-game" class="headerlink" title="55 Jump game"></a>55 Jump game</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> []: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        current = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> current &gt;= <span class="number">0</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,current):</span><br><span class="line">                <span class="keyword">if</span> current - i &lt;= nums[i] <span class="keyword">and</span> current &gt;= i:</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    current = i</span><br><span class="line">                    <span class="keyword">if</span> current == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>虽然超时了但是写的还不错的iterate</li>
<li>=。=算了这就是一坨屎！！！</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        current = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> current - i &lt;= nums[i]:</span><br><span class="line">                current = i</span><br><span class="line">                <span class="keyword">if</span> current == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我的方法其实思路是没有问题的，主要在于太啰嗦了而且循环太多了，其实直接从后往前找就行了！！！从后往前找不用考虑怎么让他循环起来呀，直接一个一个往前推就可以了</li>
<li>前面那个的问题在于多叠了一个while，于是时间瞬间爆炸，写前面的那个的时候也在想着如何找回循环里面去，结果还是用了个蠢办法</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> j &lt; i: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            j = max(i+n,j) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>i+n就是从这步开始可以移动的最大距离，j是上一步可以移动的最大距离，这两个哪个大就走哪个</li>
<li>如果这个距离还赶不上i，那就说明走不到最后了，告辞</li>
</ul>
<h1 id="45-Jump-game-2"><a href="#45-Jump-game-2" class="headerlink" title="45 Jump game 2"></a>45 Jump game 2</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        step,maxend = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i+nums[i] &gt;= len(nums) <span class="number">-1</span>: <span class="keyword">return</span> step</span><br><span class="line">                maxend = max(maxend, i + nums[i])</span><br><span class="line">            start = end + <span class="number">1</span></span><br><span class="line">            end = maxend</span><br></pre></td></tr></table></figure>
<ul>
<li>实际上来说用的是BFS的思想，但是不是每次都把东西从queue里面拿出来，而是确定了每次寻找的开始的阀内</li>
<li>start和end分别代表现在可以开始寻找的开始和结束，如果在这个范围里面找到了符合要求的结果，那么直接返回这个步数，如果没找到的话就从下一个范围开始找，下一个范围是上一个范围的end+1 到目前能到的最大的范围</li>
<li>注意符合的要求是大于等于n-1而不是正好走到这个点</li>
<li>求maxend和之前的一样</li>
</ul>
<h1 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121 Best Time to Buy and Sell Stock"></a>121 Best Time to Buy and Sell Stock</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:</p>
<p>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br>             Not 7-1 = 6, as selling price needs to be larger than buying price.<br>Example 2:</p>
<p>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        minBuy = float(<span class="string">'inf'</span>)</span><br><span class="line">        maxProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">if</span> i &lt; minBuy:</span><br><span class="line">                minBuy = i</span><br><span class="line">            <span class="keyword">elif</span> i - minBuy &gt; maxProfit:</span><br><span class="line">                maxProfit = i - minBuy</span><br><span class="line">        <span class="keyword">return</span> maxProfit</span><br></pre></td></tr></table></figure>
<ul>
<li>用brute的算法会time limit，这里用的方法是用两个变量分别记录最低的价钱和最高的利润，这样的话只需要对数组遍历一次就能得到最终的结果</li>
<li>因为判断这个价钱低了的话，求这个东西的最大利润也就只能用这个最低价钱之后的东西求了，所以不会冲突</li>
</ul>
<h1 id="122"><a href="#122" class="headerlink" title="122"></a>122</h1><ul>
<li>现在可以进行多次交易了，但是每次之间不能重叠</li>
<li>其实只要后一次比前一次贵，这个profit就可以一直累计，分为一直上涨或者中间掉下来一下再重新买的感觉</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        maxProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                maxProfit += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> maxProfit</span><br></pre></td></tr></table></figure>
<h1 id="123"><a href="#123" class="headerlink" title="123"></a>123</h1><ul>
<li>现在最多进行两次交易,找到最大的利润</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        cost_1 = float(<span class="string">'inf'</span>)</span><br><span class="line">        profit_1 = <span class="number">0</span></span><br><span class="line">        cost_2 = float(<span class="string">'inf'</span>)</span><br><span class="line">        profit_2 = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            cost_1 = min(cost_1,price)</span><br><span class="line">            profit_1 = max(profit_1, price - cost_1)</span><br><span class="line">            cost_2 = min(cost_2,price - profit_1)</span><br><span class="line">            profit_2 = max(profit_2, price - cost_2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> profit_2</span><br></pre></td></tr></table></figure>
<ul>
<li>其中，下标带1的是第一次交易之后的结果，下标带2的是第二次交易之后的结果</li>
<li>从总体上来看，第二次买入之后花掉的钱实际上是<code>第二次买入的实际花费 - 第一次交易之后挣的钱</code>（可以是负数）。而第二次卖出之后的总的收益为 <code>第二次卖出的钱 - 第二次买入之后的实际花费</code></li>
<li>所以，如果需要利润最大，需要第二次买入的实际花费最小，需要第一次的利润最大，需要第一次买入的花费最小，最终形成了这个代码</li>
</ul>
<h1 id="188"><a href="#188" class="headerlink" title="188"></a>188</h1><ul>
<li>现在需要进行最多k次交易，把profit弄到最大</li>
<li>这部分好像大家都用到了DP</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= n/<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(i-j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(prices[<span class="number">1</span>:],prices[: <span class="number">-1</span>]) <span class="keyword">if</span> i &gt; j)</span><br><span class="line">        profits = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            preprofit = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                profit = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">                preprofit = max(preprofit + profit, profits[i])</span><br><span class="line">                profits[i] = max(preprofit, profits[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> profits[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>首先考虑边界条件，如果k的数量已经比n/2大了，那么可以直接认为可以进行无限次交易了，就和上面的第二题一样</li>
<li>主要思路就是现在定义了两个变量，一个变量表示在前i天完成的交易，已经得到的最大利润。另一个变量定义了在第i天卖出的话，这时候得到的最大利润。这两个变量的都是在在第j次交易里。</li>
<li>用一个长n的list profits来记录这个天数之后获得的利益。在k次交易中一直更新这个profits里面的最大值。所以实际上关于k的变量不需要考虑</li>
<li>首先分析在第i天得到的利润，就是这一天的价格减去前一天的价格。更新之前i天里面的总利润，就是把最开始的preprfit再加上这一天获得的利润，和本来的preprofit来比大小，更新preprofit</li>
<li>更新实际上第i天的利润，对比实际上前一天的利润和前i天的利润哪个大</li>
</ul>
<h1 id="309-中间带冷却的买股票"><a href="#309-中间带冷却的买股票" class="headerlink" title="309 中间带冷却的买股票"></a>309 中间带冷却的买股票</h1><ul>
<li>每次卖出去之后必须要cooldown一轮</li>
<li>用了dp和state machine来表示，一共会有三种状态<ul>
<li>s0(reset) -sell-&gt; s1 -cool-&gt; s2(reset) -buy-&gt; s0</li>
<li>用一个数组来记录在每天在这个状态里面的最大利润，然后再从最后一天的最大利润里面挑出来一个</li>
</ul>
</li>
<li>注意考虑边界条件</li>
<li>学会了一个新的初始化list的方法</li>
<li>感觉自己终于理解了dp呢（并没有）<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s0,s1,s2 = [<span class="number">0</span>]*n,[<span class="number">0</span>]*n,[<span class="number">0</span>]*n</span><br><span class="line">        s0[<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        s1[<span class="number">0</span>] = float(<span class="string">'-inf'</span>)</span><br><span class="line">        s2[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            price = prices[i]</span><br><span class="line">            s0[i] = max(s0[i<span class="number">-1</span>],s2[i<span class="number">-1</span>] - price)</span><br><span class="line">            s1[i] = s0[i<span class="number">-1</span>] + price</span><br><span class="line">            s2[i] = max(s1[i<span class="number">-1</span>],s2[i<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(s0[n<span class="number">-1</span>],s1[n<span class="number">-1</span>],s2[n<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="11-装水"><a href="#11-装水" class="headerlink" title="11 装水"></a>11 装水</h1><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(height)</span><br><span class="line">        start, end  = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            <span class="keyword">if</span> height[start] &gt;= height[end]:</span><br><span class="line">                maxArea = max(maxArea,height[end] * (end-start))</span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxArea = max(maxArea,height[start] * (end-start))</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br></pre></td></tr></table></figure>
<ul>
<li>这道题的重点在这个装水的大小是由比较短的那条边决定的。而且肯定是底边越长越牛逼，所以从底边最长的两边开始找，然后在两个高度里面取比较大的继续找下一个</li>
<li>需要用一个变量来储存 max area的大小（这个我想到了）</li>
<li>然后比较快的方法是从两遍开始逼近，这样的话只遍历了这个list一次，时间复杂度是n，好像有个排序算法和这个的想法也差不多</li>
<li>注意while的判断条件其实就是这个</li>
</ul>
<h1 id="42-装水"><a href="#42-装水" class="headerlink" title="42 装水"></a>42 装水</h1><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="/2019/05/07/Leetcode笔记/42.jpg" alt></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(height)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_max,right_max = [<span class="number">0</span>]*n,[<span class="number">0</span>]*n</span><br><span class="line">        left_max[<span class="number">0</span>],right_max[<span class="number">-1</span>] = height[<span class="number">0</span>],height[<span class="number">-1</span>]</span><br><span class="line">        maxTrap = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            left_max[i] = max(left_max[i<span class="number">-1</span>],height[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">0</span>,n<span class="number">-1</span>)):</span><br><span class="line">            right_max[i] = max(right_max[i+<span class="number">1</span>],height[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            maxTrap += min(left_max[i],right_max[i]) - height[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxTrap</span><br></pre></td></tr></table></figure>
<ul>
<li>用dp解决的这个问题</li>
<li>核心思想在竖着（按列）数每个格子，这个格子可不可以装水和左右两边的最高点有关，这个格子能装多少水和1.最短的高点和2.这个格子本身的高度有关</li>
<li>所以可以用三个循环搞定这个问题，用空间换时间，在list里面记录下来每个列对应的左边的最高点和右边的最高点，然后再数每个列的容量，大小是（左右最高中间短的那个） - （这个列对应的高度）</li>
</ul>
<h1 id="334-升序的三个数字"><a href="#334-升序的三个数字" class="headerlink" title="334 升序的三个数字"></a>334 升序的三个数字</h1><p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Formally the function should:</p>
<p>Return true if there exists i, j, k<br>such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.<br>Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingTriplet</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        first = float(<span class="string">'inf'</span>)</span><br><span class="line">        second = float(<span class="string">'inf'</span>)</span><br><span class="line">        third = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= first:</span><br><span class="line">                first = num</span><br><span class="line">            <span class="keyword">elif</span> num &gt; first <span class="keyword">and</span> num &lt;= second:</span><br><span class="line">                second = num</span><br><span class="line">            <span class="keyword">else</span>: third = num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (third != <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>我最初的思路没有错，需要有变量来保存这三个升序的东西</li>
<li>其实核心的思路在于，如果现在这个数比第一个升序的数字小，那么这个数字完全就可以成为新的第一个数字，比如 3 2 4 5，那么345和245没有什么本质的区别，而一旦third有了取值，那么就说明肯定已经有了一个结果</li>
</ul>
<h1 id="128"><a href="#128" class="headerlink" title="128"></a>128</h1><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<p>Example:</p>
<p>Input: [100, 4, 200, 1, 3, 2]<br>Output: 4<br>Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"><span class="comment">#         if nums == []: return 0</span></span><br><span class="line"><span class="comment">#         max_num = max(nums)</span></span><br><span class="line"><span class="comment">#         min_num = min(nums)</span></span><br><span class="line"><span class="comment">#         if max_num &gt; len(nums) or -max</span></span><br><span class="line"><span class="comment">#         if min_num &lt; 0:</span></span><br><span class="line"><span class="comment">#             max_num -= min_num</span></span><br><span class="line"><span class="comment">#         ass_list = [None] * (max_num + 1)</span></span><br><span class="line"><span class="comment">#         for i,num in enumerate(nums):</span></span><br><span class="line"><span class="comment"># #             确保都是正数</span></span><br><span class="line"><span class="comment">#             if min_num &lt; 0:</span></span><br><span class="line"><span class="comment">#                 num = num-min_num</span></span><br><span class="line"><span class="comment">#             ass_list[num] = 1</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#         max_length = 0</span></span><br><span class="line"><span class="comment">#         prev_length = 0</span></span><br><span class="line"><span class="comment">#         for i in range(len(ass_list)):</span></span><br><span class="line"><span class="comment">#             if ass_list[i] != None:</span></span><br><span class="line"><span class="comment">#                 max_length += 1</span></span><br><span class="line"><span class="comment">#             else:</span></span><br><span class="line"><span class="comment">#                 prev_length = max(max_length,prev_length)</span></span><br><span class="line"><span class="comment">#                 max_length = 0</span></span><br><span class="line"><span class="comment">#         return max(max_length,prev_length)</span></span><br><span class="line">        <span class="keyword">if</span> nums == []: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        current_length,prev_length = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        num_set = set(nums)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> num_set:</span><br><span class="line">            <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                current_num = num</span><br><span class="line">                <span class="keyword">while</span> current_num+<span class="number">1</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                    current_num += <span class="number">1</span></span><br><span class="line">                    current_length += <span class="number">1</span></span><br><span class="line">                prev_length = max(prev_length,current_length)</span><br><span class="line">                current_length = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(current_length, prev_length)</span><br></pre></td></tr></table></figure>
<ul>
<li>这个问题一开始的思路是错的，已经comment掉了，但是感觉这个想法其实就是更具体化的hash表而已，第一个思路是把所有的数字平均的放在一个list里面，然后每个数字的本身就对应的是他的index，这样的话就可以直接知道有哪些数字是连续的了。但是这种方法在数字特别大的时候空间上就爆炸了，空间复杂度也是和数字大小有关</li>
<li>这时候又要拿出来快乐的hash表了，记住python自己自带hash表</li>
<li>每遇到一个数字，需要判断这个数字的下一个数字在不在这个nums里面，如果在的话更新数字和长度，如果不再的话刷新计数器并且开始下一个数字</li>
<li>但是直接这样算还是会时间爆炸（比如一堆连续的只有一个是跳开的），所以又加进去了一个新的判断条件，这个条件的精髓在于，如果这个数之前的数字在nums里面，那么这个数在算他前面那个数的时候就应该被算上了，所以这部分就可以跳过这个数了，只有当前一个数字不在的时候才需要数长度</li>
</ul>
<h1 id="164"><a href="#164" class="headerlink" title="164"></a>164</h1><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>Example 1:</p>
<p>Input: [3,6,9,1]<br>Output: 3<br>Explanation: The sorted form of the array is [1,3,6,9], either<br>             (3,6) or (6,9) has the maximum difference 3.<br>Example 2:</p>
<p>Input: [10]<br>Output: 0<br>Explanation: The array contains less than 2 elements, therefore return 0.<br>Note:</p>
<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.<br>Try to solve it in linear time/space.</p>
<p><img src="/2019/05/07/Leetcode笔记/164.jpg" alt></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        max_gap = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            gap = nums[i] - nums[i<span class="number">-1</span>]</span><br><span class="line">            max_gap = max(max_gap, gap)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_gap</span><br></pre></td></tr></table></figure>
<ul>
<li>直接用python自带的排序速度不一定很慢，虽然只超过了百分了20的人但是最后还是跑出来了</li>
<li>这个方法非常直接了</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_num, min_num = max(nums), min(nums)</span><br><span class="line">        <span class="keyword">if</span> max_num == min_num: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        wide = max((max_num - min_num) // (n<span class="number">-1</span>),<span class="number">1</span>)</span><br><span class="line">        num_b = (max_num - min_num) // wide + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        maxGap = <span class="number">0</span></span><br><span class="line">        <span class="comment"># prev_bucket = float('-inf')</span></span><br><span class="line">        max_b = [<span class="number">0</span>]* num_b</span><br><span class="line">        min_b = [float(<span class="string">'inf'</span>)]* num_b</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            idx = (num-min_num) // wide</span><br><span class="line">            max_b[idx] = max(max_b[idx],num)</span><br><span class="line">            min_b[idx] = min(min_b[idx],num)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        prev_max = max_b[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,num_b):</span><br><span class="line">            <span class="keyword">if</span> max_b[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            maxGap = max(maxGap,min_b[i] - prev_max)</span><br><span class="line">            prev_max = max_b[i]</span><br><span class="line">        <span class="keyword">return</span> maxGap</span><br></pre></td></tr></table></figure>
<ul>
<li>这个桶排序终于写出来了，基本思路是上面的截图，需要注意的有几点<ul>
<li>第一，python不导入math的话没办法求ceiling，但是可以用 -（-a // b）来求</li>
<li>第二，在求bucket的个数的时候，需要多加上一个bucket，因为一个bucket里面最后的数字是放在下一个bucket里面最前面的</li>
<li>第三，可能会有空的bucket，所以不能直接用这个的min减去上一个的max，必须要留一个变量保存上一个的max</li>
<li>第四，当所有数字都相同的时候会变得很麻烦，最后加上去一个条件过滤掉这个部分</li>
</ul>
</li>
</ul>
<h1 id="28-implement-strStr（）"><a href="#28-implement-strStr（）" class="headerlink" title="28 implement strStr（）"></a>28 implement strStr（）</h1><p>Implement strStr().</p>
<p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<p>Example 1:</p>
<p>Input: haystack = “hello”, needle = “ll”<br>Output: 2<br>Example 2:</p>
<p>Input: haystack = “aaaaa”, needle = “bba”<br>Output: -1</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> needle == <span class="string">""</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(haystack):</span><br><span class="line">            <span class="keyword">if</span> ch == needle[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> needle == haystack[i:i+len(needle)]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>刚开始特别快乐的暴力破解了，真是万万没想到</li>
<li>感觉python处理起来字符串是真的开心</li>
<li>但是这个的时间不是很快乐</li>
</ul>
<ul>
<li>关于字符串匹配有另外两个算法KMP和BM（BM更快一点）</li>
</ul>
<h1 id="14"><a href="#14" class="headerlink" title="14"></a>14</h1><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string “”.</p>
<p>Example 1:</p>
<p>Input: [“flower”,”flow”,”flight”]<br>Output: “fl”<br>Example 2:</p>
<p>Input: [“dog”,”racecar”,”car”]<br>Output: “”<br>Explanation: There is no common prefix among the input strings.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(strs) == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> len(strs) == <span class="number">1</span>: <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">        LCP = self.compare(strs[<span class="number">0</span>],strs[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(strs)):</span><br><span class="line">            LCP = self.compare(LCP,strs[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> LCP</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(self,a,b)</span>:</span></span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(a) <span class="keyword">and</span> j &lt; len(b):</span><br><span class="line">            <span class="keyword">if</span> a[i] == b[i]:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> a[:counter]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>思路：平行比较，先找出来前两个里面的prefix，然后再用这个prefix和第三个东西比较</li>
<li>注意输入的长度是1的时候，需要输出整个字符串</li>
<li>注意如果比较失败了的话，要直接停止比较！</li>
</ul>
<h1 id="58"><a href="#58" class="headerlink" title="58"></a>58</h1><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>
<p>Example:</p>
<p>Input: “Hello World”<br>Output: 5<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s[<span class="number">-1</span>] == <span class="string">" "</span>: </span><br><span class="line">            s = s[:<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        new_str = s.split(<span class="string">" "</span>)</span><br><span class="line">        <span class="comment"># return new_str</span></span><br><span class="line">        print(new_str)</span><br><span class="line">        <span class="keyword">return</span> len(new_str[<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># cnt = 0</span></span><br><span class="line">        <span class="comment"># for v in reversed(s):</span></span><br><span class="line">        <span class="comment">#     if v.isspace():</span></span><br><span class="line">        <span class="comment">#         if cnt: break</span></span><br><span class="line">        <span class="comment">#     else: cnt += 1</span></span><br><span class="line">        <span class="comment"># return cnt</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>原来运行时间也很玄学</li>
<li>但是还是别人的代码看起来厉害一点！</li>
</ul>
<h1 id="387"><a href="#387" class="headerlink" title="387"></a>387</h1><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>
<p>Examples:</p>
<p>s = “leetcode”<br>return 0.</p>
<p>s = “loveleetcode”,<br>return 2.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        count = collections.Counter(s)</span><br><span class="line">        </span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> count[ch] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>居然有这么个东西叫做counter，感到震惊！！！</li>
</ul>
<h1 id="383"><a href="#383" class="headerlink" title="383"></a>383</h1><p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>
<p>Each letter in the magazine string can only be used once in your ransom note.</p>
<p>Note:<br>You may assume that both strings contain only lowercase letters.</p>
<p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p>
<ul>
<li><p>这个题目也太写意了吧，意思就是我需要写一个勒索信，然后要从杂志上面找单词，看看能不能用杂志上面的东西拼凑出来这个单词</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span><span class="params">(self, ransomNote: str, magazine: str)</span> -&gt; bool:</span></span><br><span class="line">        alphabet = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> magazine:</span><br><span class="line">            index = ord(ch) - ord(<span class="string">'a'</span>)</span><br><span class="line">            alphabet[index] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> ransomNote:</span><br><span class="line">            index = ord(ch) - ord(<span class="string">'a'</span>)</span><br><span class="line">            alphabet[index] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> alphabet[index] &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>看到了一个清奇的思路然后自己实现了一下</p>
<ul>
<li>统计magazine里面每个字母的数量，和需要的字母数量对比，如果不够的话就不行</li>
<li>我在写的时候多iteration了一次26个字母，但是其实在ransomNote里面直接对比和0的大小就可以了</li>
<li>感觉字母和数字最大的区别就在于字母有限而数字无限</li>
</ul>
</li>
</ul>
<h1 id="344"><a href="#344" class="headerlink" title="344"></a>344</h1><p>reverse一个list，要求in-place而且占用o1的空间<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length // <span class="number">2</span>):</span><br><span class="line">            temp = s[i]</span><br><span class="line">            s[i] = s[length - <span class="number">1</span> - i]</span><br><span class="line">            s[length - <span class="number">1</span> - i] = temp</span><br></pre></td></tr></table></figure></p>
<ul>
<li>其实可以不用temp的，直接用 s[i]，s[length - 1 - i] = s[length - 1 - i], s[i]就可以了</li>
</ul>
<h1 id="151"><a href="#151" class="headerlink" title="151"></a>151</h1><p>reverse一个string，让这句话倒过来，主要会有多个空格<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(s.split()[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<ul>
<li>python真的是很作弊了</li>
<li>split不加参数就可以直接分开所有大小的空格</li>
</ul>
<h1 id="70-爬楼梯-DP"><a href="#70-爬楼梯-DP" class="headerlink" title="70 爬楼梯 DP"></a>70 爬楼梯 DP</h1><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given n will be a positive integer.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n ==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        f = (n+<span class="number">1</span>)*[<span class="number">0</span>]<span class="comment">#走n节的时候可以有的方法数量</span></span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        f[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            f[i] = f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>
<ul>
<li>其实就相当于斐波那契数列，第i种的可能的方法是从i-2走一个2，以及从i-1走一个1的和</li>
</ul>
<h1 id="345"><a href="#345" class="headerlink" title="345"></a>345</h1><p>把一个string里面的原因反序</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        vowels = <span class="string">"AEIOUaeiou"</span></span><br><span class="line">        index = []</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> vowels:</span><br><span class="line">                index.append(i)</span><br><span class="line">        s = list(s)</span><br><span class="line">        i,j = <span class="number">0</span>,len(index)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            s[index[i]],s[index[j]] = s[index[j]],s[index[i]] </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(s)</span><br></pre></td></tr></table></figure>
<ul>
<li>首先判断哪个是原因</li>
<li>然后把元音的部分倒过来</li>
<li>.join把list转回string</li>
</ul>
<h1 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="205 Isomorphic Strings"></a>205 Isomorphic Strings</h1><p>Easy</p>
<p>767</p>
<p>217</p>
<p>Favorite</p>
<p>Share<br>Given two strings s and t, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in s can be replaced to get t.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<p>Example 1:</p>
<p>Input: s = “egg”, t = “add”<br>Output: true<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        sub_1,sub_2 = [<span class="number">0</span>]*<span class="number">256</span>,[<span class="number">0</span>]*<span class="number">256</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            a,b = s[i],t[i]</span><br><span class="line">            <span class="keyword">if</span> sub_1[ord(a)] != sub_2[ord(b)]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            sub_1[ord(a)] = i + <span class="number">1</span></span><br><span class="line">            sub_2[ord(b)] = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意这里面的mapping不一定是字母，也可以是数字</li>
<li>ascii码一共是256个，所以是不会超出这个范围的</li>
<li>主要思路就是这样的，两个数组分别记录的是对应位置的ascii码的mapping的位数，如果这两个位数不一样的话，就说明这两个的mapping方式有问题，所以return False，不然的话return True</li>
</ul>
<h1 id="290-word-pattern"><a href="#290-word-pattern" class="headerlink" title="290 word pattern"></a>290 word pattern</h1><p>Given a pattern and a string str, find if str follows the same pattern.</p>
<p>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</p>
<p>Example 1:</p>
<p>Input: pattern = “abba”, str = “dog cat cat dog”<br>Output: true<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span><span class="params">(self, pattern: str, str: str)</span> -&gt; bool:</span></span><br><span class="line">        pattern = list(pattern)</span><br><span class="line">        string = str.split(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">return</span> len(set(zip(pattern,string))) == len(set(string)) == len(set(pattern)) <span class="keyword">and</span> len(pattern) == len(string)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>又到了活用zip的时候，返回的是一个个对应的东西，也就是说返回的是<ul>
<li>a-dog,b-cat,b-cat,a-dog</li>
<li>这时候把他们转化成set，得到的就是不带重复的东西的长度</li>
</ul>
</li>
<li>如果匹配上的长度和原先的长度全都相同（去掉重复的元素），那么就证明匹配上了</li>
</ul>
<h1 id="49-变位词"><a href="#49-变位词" class="headerlink" title="49 变位词"></a>49 变位词</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="comment"># for i,item in enumerate(strs):</span></span><br><span class="line">        <span class="comment">#     item = list(item)</span></span><br><span class="line">        <span class="comment">#     item.sort()</span></span><br><span class="line">        <span class="comment">#     item = "".join(item)</span></span><br><span class="line">        <span class="comment">#     temp[i],temp_sort = item,item</span></span><br><span class="line">        <span class="comment"># temp_sort.sort()</span></span><br><span class="line">        <span class="comment"># print(temp,strs)</span></span><br><span class="line">        </span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">            key = <span class="string">""</span>.join(sorted(word))</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> d:</span><br><span class="line">                d.get(key).append(word)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[key] = [word]</span><br><span class="line">            <span class="comment"># d[key] = d.get(key,[]) + [word]</span></span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
<ul>
<li>核心思想 -&gt; 排序，排序之后的变位词就都一样了</li>
<li>leetcode 242,49<ul>
<li>这个题的核心思路就是，每个单词按字母顺序排序之后的答案就是这个单词的key，如果两个单词的key一样的话这两个单词就是变位词，如果不一样的话就是新的词</li>
<li>在python里面直接用字典可以很好的储存变位词</li>
</ul>
</li>
</ul>
<h1 id="56-merge-intervals"><a href="#56-merge-intervals" class="headerlink" title="56 merge intervals"></a>56 merge intervals</h1><p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>Example 1:</p>
<p>Input: [[1,3],[2,6],[8,10],[15,18]]<br>Output: [[1,6],[8,10],[15,18]]<br>Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x : x[<span class="number">0</span>])</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> output <span class="keyword">and</span> i[<span class="number">0</span>] &lt;= output[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">                output[<span class="number">-1</span>][<span class="number">1</span>] = max(output[<span class="number">-1</span>][<span class="number">1</span>], i[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output.append(i)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<ul>
<li>注意点：<ul>
<li>给的数据输入并不一定是排好序的，所以需要先排好序。这里用到了排序的key的功能。lambda是定义任意函数 g(x)= x[0]</li>
<li>需要输出的格式是list套list，所以需要append</li>
</ul>
</li>
<li>思路错了的一个方向是，其实每个i不应该和隔壁的i比大小，而是应该和output里面的最终结果比大小，因为需要考虑到好几个内容都可以合并的情况</li>
</ul>
<h1 id="57插入"><a href="#57插入" class="headerlink" title="57插入"></a>57插入</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        out = []</span><br><span class="line">        adding = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(intervals) == <span class="number">0</span>: <span class="keyword">return</span> [newInterval]</span><br><span class="line">        <span class="keyword">if</span> newInterval[<span class="number">1</span>] &lt; intervals[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">            out.append(newInterval)</span><br><span class="line">            adding = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> adding <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">if</span> newInterval[<span class="number">0</span>] &gt; i[<span class="number">1</span>]:</span><br><span class="line">                    out.append(i)</span><br><span class="line">                <span class="keyword">elif</span> newInterval[<span class="number">1</span>] &lt; i[<span class="number">0</span>]:</span><br><span class="line">                    out.append(newInterval)</span><br><span class="line">                    adding = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    after_insert = [min(i[<span class="number">0</span>],newInterval[<span class="number">0</span>]),max(i[<span class="number">1</span>],newInterval[<span class="number">1</span>])]</span><br><span class="line">                    out.append(after_insert)</span><br><span class="line">                    adding = <span class="literal">True</span></span><br><span class="line">                <span class="comment"># print("adding")</span></span><br><span class="line">            <span class="keyword">if</span> adding <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> i[<span class="number">0</span>] &gt; out[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">                    out.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    out[<span class="number">-1</span>][<span class="number">1</span>] = max(out[<span class="number">-1</span>][<span class="number">1</span>],i[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> adding <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            out.append(newInterval)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
<ul>
<li>自己苦思冥想了一个多小时的答案</li>
<li>有点繁琐，debug的时候主要是情况考虑的不够明确，包括没有考虑空的情况，在最后插入的情况，在最前插入的情况</li>
<li>但是最后总结的想，应该对插入的前后一视同仁，因为状况其实是差不多的，而我把前面分成了好多种状况，后面倒是写成了一种情况</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">left = []</span><br><span class="line">right = []</span><br><span class="line">s,e = newInterval[<span class="number">0</span>],newInterval[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">    <span class="keyword">if</span> i[<span class="number">1</span>] &lt; s:</span><br><span class="line">        left.append(i)</span><br><span class="line">    <span class="keyword">elif</span> i[<span class="number">0</span>] &gt; e:</span><br><span class="line">        right.append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s = min(i[<span class="number">0</span>],s)</span><br><span class="line">        e = max(i[<span class="number">1</span>],e)</span><br><span class="line"><span class="keyword">return</span> left + [[s,e]] + right</span><br></pre></td></tr></table></figure>
<ul>
<li>这是discussion里面的一种简要的解法，思路的不同就是他是每次都merge到new里面了（也就是s和e），而我是merge到out里面了</li>
<li>其实我的代码本身的也有merge到new的意思，但是被我分出了太多种太复杂的情况</li>
</ul>
<h1 id="101对称树"><a href="#101对称树" class="headerlink" title="101对称树"></a>101对称树</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        now = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            now.append(root)</span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            vals = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> now:</span><br><span class="line">                <span class="keyword">if</span> i:</span><br><span class="line">                    vals.append(i.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    vals.append(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> list(reversed(vals)) != vals: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now = [j <span class="keyword">for</span> i <span class="keyword">in</span> now <span class="keyword">if</span> i <span class="keyword">for</span> j <span class="keyword">in</span> (i.left, i.right)]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>遍历的方法，最后一个now的表达式值得学习</li>
<li>注意root是node，而这个node实际的值在vals里面，因为好久没处理node了所以忘记了这一点</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Symm</span><span class="params">(L,R)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> L <span class="keyword">and</span> R:</span><br><span class="line">            <span class="keyword">return</span> L.val == R.val <span class="keyword">and</span> Symm(L.left,R.right) <span class="keyword">and</span> Symm(L.right,R.left) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> L == R</span><br><span class="line">            <span class="comment"># return L is None and R is None #同等意义</span></span><br><span class="line">    <span class="keyword">return</span> Symm(root, root)</span><br><span class="line">    <span class="comment"># 没有关于空的树的判断条件，所以需要从root开始</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法过于优雅，我要哭出来了</li>
</ul>
<h1 id="87-Scramble-String"><a href="#87-Scramble-String" class="headerlink" title="87 Scramble String"></a>87 Scramble String</h1><p>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>
<p>Below is one possible representation of s1 = “great”:</p>
<pre><code>great
</code></pre><p>   /    \<br>  gr    eat<br> / \    /  \<br>g   r  e   at<br>           / \<br>          a   t<br>To scramble the string, we may choose any non-leaf node and swap its two children.</p>
<p>For example, if we choose the node “gr” and swap its two children, it produces a scrambled string “rgeat”.</p>
<pre><code>rgeat
</code></pre><p>   /    \<br>  rg    eat<br> / \    /  \<br>r   g  e   at<br>           / \<br>          a   t</p>
<ul>
<li>思路：<ul>
<li>首先，如果我这个单词的substring满足这个要求的话，上面一层的单词就满足这个要求，也就是说可以recursive的完成这个工作，对于不同的substring call这个函数来检验是否满足要求</li>
<li>边界条件：<ul>
<li>如果string的长度小于等于2，那么怎么换其实都是满足的</li>
<li>如果两个string直接相等，那么也是满足的</li>
</ul>
</li>
<li>先决条件：<ul>
<li>如果这两个string的长度都不一样，那么肯定也不一样</li>
<li>如果这两个string里面字母的sort之后都不一样，那么肯定不一样</li>
</ul>
</li>
<li>判断条件：<ul>
<li>对于一个string，如果从k位置来分的话，有两种不同的结果。or关系<ul>
<li>结果1：s1的前k个和s2的前k个一样 and s1的后n-k个和s2的后n-k个一样</li>
<li>结果2：s1的前k个和s2的后k个一样 and s1的前n-k个和s2的前n-k个一样</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        n1,n2 = len(s1),len(s2)</span><br><span class="line">        <span class="keyword">if</span> n1 != n2 <span class="keyword">or</span> sorted(s1) != sorted(s2): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> n1 &lt;= <span class="number">2</span> <span class="keyword">or</span> s1 == s2: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        f = self.isScramble</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n1):</span><br><span class="line">            <span class="keyword">if</span> (f(s1[<span class="number">0</span>:i], s2[<span class="number">0</span>:i]) <span class="keyword">and</span> f(s1[i:],s2[i:])) <span class="keyword">or</span> \</span><br><span class="line">            f(s1[<span class="number">0</span>:i], s2[n2-i:]) <span class="keyword">and</span> f(s1[i:],s2[<span class="number">0</span>:n2-i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="38-count-and-say"><a href="#38-count-and-say" class="headerlink" title="38 count and say"></a>38 count and say</h1><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221<br>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.</li>
</ol>
<p>Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<p><strong>自己的智障解法</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="string">"1"</span></span><br><span class="line">        </span><br><span class="line">        result = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            result = self.Say(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Say</span><span class="params">(self,num)</span>:</span></span><br><span class="line">        n = len(num)</span><br><span class="line">        counter = <span class="number">1</span></span><br><span class="line">        counters = <span class="string">""</span></span><br><span class="line">        nums = str(num[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> num[i] == num[i<span class="number">-1</span>]:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                counters += str(counter)</span><br><span class="line">                counter = <span class="number">1</span></span><br><span class="line">                nums += str(num[i])</span><br><span class="line">        counters += str(counter)</span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(counters)):</span><br><span class="line">            result += counters[i]</span><br><span class="line">            result += nums[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意，如果要把list接成string，需要先把里面的所有项都转成string</li>
<li>感觉自己还是很不擅长recursive</li>
</ul>
<h1 id="316-remove-deplicate-letters"><a href="#316-remove-deplicate-letters" class="headerlink" title="#316 remove deplicate letters"></a>#316 remove deplicate letters</h1><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p>Example 1:</p>
<p>Input: “bcabc”<br>Output: “abc”<br>Example 2:</p>
<p>Input: “cbacdcbc”<br>Output: “acdb”</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># s = sorted(s)</span></span><br><span class="line">        <span class="comment"># i = 0</span></span><br><span class="line">        <span class="comment"># for n in s:</span></span><br><span class="line">        <span class="comment">#     # print(n,i,s[i-1])</span></span><br><span class="line">        <span class="comment">#     if i &lt; 1 or n != s[i-1]:</span></span><br><span class="line">        <span class="comment">#         s[i] = n</span></span><br><span class="line">        <span class="comment">#         i += 1</span></span><br><span class="line">        <span class="comment"># return "".join(s[:i])</span></span><br><span class="line">        s = list(s)</span><br><span class="line">        result = []</span><br><span class="line">        last_occurrence = &#123;c: i <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s)&#125;</span><br><span class="line">        <span class="keyword">for</span> i,n <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                <span class="keyword">while</span> result <span class="keyword">and</span> n &lt; result[<span class="number">-1</span>] <span class="keyword">and</span> result[<span class="number">-1</span>] <span class="keyword">in</span> s[i:]:</span><br><span class="line">                    result.pop()</span><br><span class="line">                result.append(n)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(result)</span><br></pre></td></tr></table></figure>
<ul>
<li>这道题里面的重点在<strong>lexicographical order</strong><ul>
<li>也就是说，在操作的时候，如果这个字母在后面的位置上出现了，但是放在前面的位置上会导致前面变大，那么就取后面的那个结果</li>
</ul>
</li>
<li>本来我想的是可以先把没出现过的放进去，然后再刷新。但是直接放最好的应该更好一些</li>
<li>几种情况：<ul>
<li>如果已经出现了：那么直接跳过</li>
<li>如果没出现：<ul>
<li>如果比之前的小，并且前面的那个在后面还有，就得往前顶。还要考虑顶没了的情况，也就是result不为空</li>
<li>这里注意这三个条件是并列的，需要同时and。我刚开始把在后面出现放到循环里面去了，所以死循环了</li>
<li>在上面顶完之后，再把最新的加到最后</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="168-excel-column-title"><a href="#168-excel-column-title" class="headerlink" title="168 excel column title"></a>168 excel column title</h1><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<pre><code>1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB 
...
</code></pre><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertToTitle</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            letter = n % <span class="number">26</span></span><br><span class="line">            n = n // <span class="number">26</span></span><br><span class="line">            <span class="keyword">if</span> letter == <span class="number">0</span>:</span><br><span class="line">                letter = <span class="number">26</span></span><br><span class="line">                n = n<span class="number">-1</span></span><br><span class="line">            result.append(letter)</span><br><span class="line">        result = result[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i,item <span class="keyword">in</span> enumerate(result):</span><br><span class="line">            item += <span class="number">64</span></span><br><span class="line">            item = str(chr(item))</span><br><span class="line">            result[i] = item</span><br><span class="line">        <span class="comment"># print(result)</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(result)</span><br></pre></td></tr></table></figure>
<ul>
<li>自己的傻逼方法：<ul>
<li>最先得到的余数应该是最后的字母的值，所以这里出来的result需要翻转一下</li>
<li>翻转list最快的方法是 [::-1]</li>
<li>str(chr(n))把数字转成char，ord把char转成数字，大写A是65，小写a是97</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> num == <span class="number">0</span> <span class="keyword">else</span> self.convertToTitle((num - <span class="number">1</span>) / <span class="number">26</span>) + chr((num - <span class="number">1</span>) % <span class="number">26</span> + ord(<span class="string">'A'</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>大佬的一行</li>
<li>忘记了这种str的连接方法</li>
<li>直接减-1计算更方便</li>
</ul>
<h1 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171 Excel Sheet Column Number"></a>171 Excel Sheet Column Number</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">titleToNumber</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># s = s[::-1]</span></span><br><span class="line">        <span class="comment"># result = 0</span></span><br><span class="line">        <span class="comment"># for i,item in enumerate(s):</span></span><br><span class="line">        <span class="comment">#     result += 26^(i) + (ord(item) - ord("A"))</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> s == <span class="string">""</span> <span class="keyword">else</span> self.titleToNumber(s[:<span class="number">-1</span>]) * <span class="number">26</span> + ord(s[<span class="number">-1</span>]) - ord(<span class="string">"A"</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面那道题的友情题，模拟大佬写出了解法</li>
<li>注意list的上限，到-1的话是到-2不包括-1</li>
</ul>
<h1 id="13-roman-to-integer"><a href="#13-roman-to-integer" class="headerlink" title="13 roman to integer"></a>13 roman to integer</h1><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        trans = &#123;</span><br><span class="line">            <span class="string">"I"</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="string">"V"</span>:<span class="number">5</span>,</span><br><span class="line">            <span class="string">"X"</span>:<span class="number">10</span>,</span><br><span class="line">            <span class="string">"L"</span>:<span class="number">50</span>,</span><br><span class="line">            <span class="string">"C"</span>:<span class="number">100</span>,</span><br><span class="line">            <span class="string">"D"</span>:<span class="number">500</span>,</span><br><span class="line">            <span class="string">"M"</span>:<span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        s = s.replace(<span class="string">"IV"</span>,<span class="string">"IIII"</span>).replace(<span class="string">"IX"</span>,<span class="string">"VIIII"</span>)</span><br><span class="line">        s = s.replace(<span class="string">"XL"</span>,<span class="string">"XXXX"</span>).replace(<span class="string">"XC"</span>,<span class="string">"LXXXX"</span>)</span><br><span class="line">        s = s.replace(<span class="string">"CD"</span>,<span class="string">"CCCC"</span>).replace(<span class="string">"CM"</span>,<span class="string">"DCCCC"</span>)</span><br><span class="line">        </span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            result += trans[c]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<ul>
<li>比较典型的用dict解决的例子，善用string里面的replace方法</li>
</ul>
<h1 id="12-int-to-roman"><a href="#12-int-to-roman" class="headerlink" title="12 int to roman"></a>12 int to roman</h1><p>上面的友情题</p>
<ul>
<li>虽然可以穷举实现，但是我骄傲的自己写出来了recursive的方法</li>
<li>需要注意字母的替换顺序，不然会换错<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        space = [<span class="string">"M"</span>, <span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"L"</span>, <span class="string">"X"</span>, <span class="string">"V"</span>, <span class="string">"I"</span>]</span><br><span class="line">        trans = &#123;</span><br><span class="line">            <span class="string">"I"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">"V"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">"X"</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">"L"</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">"C"</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">"D"</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">"M"</span>: <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        s = self.find_raw(num, <span class="number">0</span>, space, trans)</span><br><span class="line"></span><br><span class="line">        s = s.replace(<span class="string">"DCCCC"</span>, <span class="string">"CM"</span>).replace(<span class="string">"CCCC"</span>, <span class="string">"CD"</span>)</span><br><span class="line">        s = s.replace(<span class="string">"LXXXX"</span>, <span class="string">"XC"</span>).replace(<span class="string">"XXXX"</span>, <span class="string">"XL"</span>)</span><br><span class="line">        s = s.replace(<span class="string">"VIIII"</span>, <span class="string">"IX"</span>).replace(<span class="string">"IIII"</span>, <span class="string">"IV"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_raw</span><span class="params">(self, num, name, space, trans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> num * <span class="string">"I"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = (num // trans[space[name]]) * space[name]</span><br><span class="line">            after = self.find_raw(</span><br><span class="line">                num % trans[space[name]], name + <span class="number">1</span>, space, trans)</span><br><span class="line">            <span class="keyword">return</span> temp + after</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.intToRoman(<span class="number">9</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="273-int-to-english"><a href="#273-int-to-english" class="headerlink" title="273 int to english"></a>273 int to english</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberToWords</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        t0to19 = [<span class="string">"Zero"</span>, <span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>, <span class="string">"Four"</span>, <span class="string">"Five"</span>, <span class="string">"Six"</span>, <span class="string">"Seven"</span>, <span class="string">"Eight"</span>, <span class="string">"Nine"</span>, <span class="string">"Ten"</span>, <span class="string">"Eleven"</span>,</span><br><span class="line">                  <span class="string">"Twelve"</span>, <span class="string">"Thirteen"</span>, <span class="string">"Fourteen"</span>,</span><br><span class="line">                  <span class="string">"Fifteen"</span>, <span class="string">"Sixteen"</span>, <span class="string">"Seventeen"</span>, <span class="string">"Eighteen"</span>, <span class="string">"Nineteen"</span>]</span><br><span class="line">        tens = [<span class="string">"Twenty"</span>, <span class="string">"Thirty"</span>, <span class="string">"Forty"</span>, <span class="string">"Fifty"</span>,</span><br><span class="line">                <span class="string">"Sixty"</span>, <span class="string">"Seventy"</span>, <span class="string">"Eighty"</span>, <span class="string">"Ninety"</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">word</span><span class="params">(num, i = <span class="number">0</span>)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">""</span>]</span><br><span class="line">            <span class="keyword">if</span> num &lt; <span class="number">20</span>:</span><br><span class="line">                <span class="keyword">return</span> [t0to19[num]]</span><br><span class="line">            <span class="keyword">if</span> num &lt; <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">return</span> [tens[num // <span class="number">10</span> - <span class="number">2</span>]] + word(num % <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span> num &lt; <span class="number">1000</span>:</span><br><span class="line">                <span class="keyword">return</span> [t0to19[num // <span class="number">100</span>]] + [<span class="string">"Hundred"</span>] + word(num % <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                trans = &#123;<span class="string">"Billion"</span>: int(<span class="number">1e9</span>), <span class="string">"Million"</span>: int(</span><br><span class="line">                    <span class="number">1e6</span>), <span class="string">"Thousand"</span>: int(<span class="number">1e3</span>)&#125;</span><br><span class="line">                part = [<span class="string">"Billion"</span>, <span class="string">"Million"</span>, <span class="string">"Thousand"</span>][i]</span><br><span class="line">                <span class="keyword">if</span> num // trans[part] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> word(num % trans[part], i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> word(num // trans[part]) + [part] + word(num % trans[part], i + <span class="number">1</span>)</span><br><span class="line">        s = word(num, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="string">""</span> <span class="keyword">in</span> s:</span><br><span class="line">            s.remove(<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(s) <span class="keyword">or</span> <span class="string">"Zero"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意移除空项的时候，需要用while而不是if</li>
<li>因为最后需要空格连接，所以最好先扔到list里面再出来</li>
<li>这题也太傻比了=。=无论怎么样都要自己手打这么多东西</li>
</ul>
<h1 id="68-text-justification"><a href="#68-text-justification" class="headerlink" title="# 68 text justification"></a># 68 text justification</h1><p>需要把这一行字左右对齐<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span><span class="params">(self, words: List[str], maxWidth: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="comment"># 每一行填满，如果填不满的时候，词的中间的空格尽量平均</span></span><br><span class="line">        <span class="comment"># 最后一行右边加空格</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每读一个单词后面需要加一行</span></span><br><span class="line">        space = <span class="number">0</span></span><br><span class="line">        line = [<span class="number">0</span>] <span class="comment"># 每一行开头的单词的坐标</span></span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            <span class="keyword">if</span> space + len(word) &lt; maxWidth:</span><br><span class="line">                space += len(word) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> space + len(word) == maxWidth <span class="keyword">and</span> i != len(words) - <span class="number">1</span>:</span><br><span class="line">                space = <span class="number">0</span></span><br><span class="line">                line.append(i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> space + len(word) &gt; maxWidth:</span><br><span class="line">                space = len(word) + <span class="number">1</span> <span class="comment">#注意这里的长度变化了</span></span><br><span class="line">                line.append(i)</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(line)):</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(line) - <span class="number">1</span>:</span><br><span class="line">                s = <span class="string">""</span></span><br><span class="line">                this_line = words[line[i]:line[i+<span class="number">1</span>]]</span><br><span class="line">                length = <span class="number">-1</span> <span class="comment"># 最后一个单词不带空格</span></span><br><span class="line">                <span class="keyword">for</span> w <span class="keyword">in</span> this_line:</span><br><span class="line">                    length += len(w) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> len(this_line) == <span class="number">1</span>:</span><br><span class="line">                    s = this_line[<span class="number">0</span>] + (maxWidth - len(this_line[<span class="number">0</span>])) * <span class="string">" "</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    space_len = (maxWidth - length) // (len(this_line) - <span class="number">1</span>)</span><br><span class="line">                    extra_space = (maxWidth - length) % (len(this_line) - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">for</span> i,w <span class="keyword">in</span> enumerate(this_line):</span><br><span class="line">                        <span class="keyword">if</span> i &lt; len(this_line) - <span class="number">1</span>:</span><br><span class="line">                            s = s + w + <span class="string">" "</span> + space_len*<span class="string">" "</span></span><br><span class="line">                            <span class="keyword">if</span> i &lt;= extra_space - <span class="number">1</span>:</span><br><span class="line">                                s = s + <span class="string">" "</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            s = s + w</span><br><span class="line">                output.append(s)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                this_line = words[line[i]:]</span><br><span class="line">                s = <span class="string">" "</span>.join(this_line)</span><br><span class="line">                s = s + <span class="string">" "</span>*(maxWidth-len(s))</span><br><span class="line">                output.append(s)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></p>
<ul>
<li>思路<ul>
<li>先分开单词</li>
<li>再往里插空格</li>
</ul>
</li>
</ul>
<h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>把整数转过来<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        Positive = <span class="literal">True</span></span><br><span class="line">        x2 = []</span><br><span class="line">        <span class="keyword">if</span> str(x)[<span class="number">0</span>] == <span class="string">"-"</span>:</span><br><span class="line">            Positive = <span class="literal">False</span></span><br><span class="line">            x = int(x - x * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">while</span> x &gt;= <span class="number">10</span>:</span><br><span class="line">            num = x % <span class="number">10</span></span><br><span class="line">            x = x // <span class="number">10</span></span><br><span class="line">            x2.append(str(num))</span><br><span class="line">        x2.append(str(x))</span><br><span class="line">        output = <span class="string">""</span>.join(x2)</span><br><span class="line">        output = int(output)</span><br><span class="line">        <span class="keyword">if</span> Positive:</span><br><span class="line">            output = int(output)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output = int(output) - <span class="number">2</span> * int(output)</span><br><span class="line">        <span class="keyword">if</span> output &gt; <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span> <span class="keyword">or</span> output &lt; <span class="number">-2</span>**<span class="number">31</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意啊2的31次方不是2e31啊啊我在干什么</li>
</ul>
<h1 id="165-Compare-Version-Numbers"><a href="#165-Compare-Version-Numbers" class="headerlink" title="165. Compare Version Numbers"></a>165. Compare Version Numbers</h1><ul>
<li><p>比较两个版本号，需要忽略里面的0</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compareVersion</span><span class="params">(self, version1: str, version2: str)</span> -&gt; int:</span></span><br><span class="line">        v1 = version1.split(<span class="string">"."</span>)</span><br><span class="line">        v2 = version2.split(<span class="string">"."</span>)</span><br><span class="line">        v1 = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> v1]</span><br><span class="line">        v2 = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> v2]</span><br><span class="line">        <span class="comment"># 可以简化为两行</span></span><br><span class="line">        <span class="comment"># versions1 = [int(v) for v in version1.split(".")]</span></span><br><span class="line">        <span class="comment"># versions2 = [int(v) for v in version2.split(".")]</span></span><br><span class="line">        <span class="keyword">if</span> len(v1) &gt; len(v2):</span><br><span class="line">            length = len(v2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            length = len(v1)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            c1,c2 = v1[i],v2[i]</span><br><span class="line">            <span class="keyword">if</span> c1 &gt; c2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c1 &lt; c2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            end = i</span><br><span class="line">        </span><br><span class="line">        rest1,rest2 = v1[i+<span class="number">1</span>:],v2[i+<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> sum(rest1) == sum(rest2): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> sum(rest1) &gt; sum(rest2): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> sum(rest1) &lt; sum(rest2): <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 另一种方法，更简洁</span></span><br><span class="line">        <span class="comment"># for i in range(max(len(versions1),len(versions2))):</span></span><br><span class="line">        <span class="comment">#     v1 = versions1[i] if i &lt; len(versions1) else 0</span></span><br><span class="line">        <span class="comment">#     v2 = versions2[i] if i &lt; len(versions2) else 0</span></span><br><span class="line">        <span class="comment">#     if v1 &gt; v2:</span></span><br><span class="line">        <span class="comment">#         return 1</span></span><br><span class="line">        <span class="comment">#     elif v1 &lt; v2:</span></span><br><span class="line">        <span class="comment">#         return -1;</span></span><br><span class="line">        <span class="comment"># return 0;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>需要考虑的主要就是长度不一样的情况和塞0的情况，我的想法是取比较小的总长度，然后再比较剩余的</p>
</li>
<li>大佬的情况是比较的所有的长度，如果超过了现在的长度就直接设置为0，这样不会影响比较。最后都比完都没差就是0</li>
</ul>
<h1 id="66"><a href="#66" class="headerlink" title="66"></a>66</h1><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p>Example 1:</p>
<p>Input: [1,2,3]<br>Output: [1,2,4]<br>Explanation: The array represents the integer 123.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(digits)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            digits[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> digits[i] &lt; <span class="number">10</span>: <span class="keyword">return</span> digits</span><br><span class="line">            digits[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> digits[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            digits.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">                digits[j] = digits[j<span class="number">-1</span>]</span><br><span class="line">            digits[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>
<ul>
<li>没啥好多说的，所有情况都考虑了就行了</li>
<li>但是其实，如果会产生进位，只有可能是因为最后一位是9，所以我这个判断条件稍微有一点没想清楚的感觉</li>
<li>下面这个写出来更加优雅<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(digits) == <span class="number">1</span> <span class="keyword">and</span> digits[<span class="number">0</span>] == <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> digits[<span class="number">-1</span>] != <span class="number">9</span>:</span><br><span class="line">            digits[<span class="number">-1</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> digits</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            digits[<span class="number">-1</span>] = <span class="number">0</span></span><br><span class="line">            digits[:<span class="number">-1</span>] = self.plusOne(digits[:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="258-一个数字的逐位相加，直到小于9"><a href="#258-一个数字的逐位相加，直到小于9" class="headerlink" title="258 一个数字的逐位相加，直到小于9"></a>258 一个数字的逐位相加，直到小于9</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addDigits</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        Sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> str(num):</span><br><span class="line">            Sum += int(i)</span><br><span class="line">        <span class="keyword">return</span> self.addDigits(Sum)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># if num == 0 : return 0</span></span><br><span class="line">        <span class="comment"># else:return (num - 1) % 9 + 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面那种方法是我写的，复杂度是n</li>
<li>下面的方法是数学规律，复杂度是1</li>
</ul>
<h1 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144 Binary Tree Preorder Traversal"></a>144 Binary Tree Preorder Traversal</h1><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>Example:</p>
<p>Input: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3</p>
<p>Output: [1,2,3]</p>
<ul>
<li>注意审题：这道题并不是按左小右大的顺序排列的，而且<code>preorder traversal</code>指的就是先访问root，再从左到右访问root的子节点</li>
<li>需要注意输入为空的情况</li>
<li>recursive和iterate都可以完成</li>
<li>在recursive里面，因为需要把内容储存在list里面，所以需要新建一个函数<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.preorder(root,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self,root,result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root: result.append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.left: </span><br><span class="line">            self.preorder(root.left,result)</span><br><span class="line">        <span class="keyword">if</span> root.right: </span><br><span class="line">            self.preorder(root.right,result)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            current = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> current:</span><br><span class="line">                result.append(current.val)</span><br><span class="line">                stack.append(current.right)</span><br><span class="line">                stack.append(current.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>注意因为是把内容放在stack里面，所以要先放right才能让他后出来</li>
<li>需要判断current是不是为空</li>
<li>pop默认的就是最后一位</li>
</ul>
<h1 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145 Binary Tree Postorder Traversal"></a>145 Binary Tree Postorder Traversal</h1><ul>
<li>和上一道题反序</li>
<li>注意虽然是post，但是还是需要先访问左child，再访问右child</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.post(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.post(root.left,res)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.post(root.right,res)</span><br><span class="line">        <span class="keyword">if</span> root: res.append(root.val)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            current = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> current:</span><br><span class="line">                res.append(current.val)</span><br><span class="line">                stack.append(current.left)</span><br><span class="line">                stack.append(current.right)</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>iterative的方法可以采用先处理右边的点，再处理左边的点。因为右边的后放进stack所以先出来先进res里面</li>
<li>最后再把结果倒序（牛逼）</li>
</ul>
<h1 id="102"><a href="#102" class="headerlink" title="102"></a>102</h1><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its level order traversal as:<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line"><span class="comment">#         self.levels = []</span></span><br><span class="line"><span class="comment">#         self.find(root,0)</span></span><br><span class="line"><span class="comment">#         return self.levels</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#     def find(self,node, level):</span></span><br><span class="line"><span class="comment">#         if node:</span></span><br><span class="line"><span class="comment">#             if len(self.levels) &lt;= level:</span></span><br><span class="line"><span class="comment">#                 self.levels += [[node.val]]</span></span><br><span class="line"><span class="comment">#             else:</span></span><br><span class="line"><span class="comment">#                 self.levels[level] += [node.val]</span></span><br><span class="line"><span class="comment">#             self.find(node.left, level + 1)</span></span><br><span class="line"><span class="comment">#             self.find(node.right,level + 1)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack, queue, nCount, res = [root],[],<span class="number">1</span>,[[root.val]]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            temp = stack.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> temp.left: stack.append(temp.left)</span><br><span class="line">            <span class="keyword">if</span> temp.right: stack.append(temp.right)</span><br><span class="line">            nCount -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nCount == <span class="number">0</span>:</span><br><span class="line">                queue = [x.val <span class="keyword">for</span> x <span class="keyword">in</span> stack]</span><br><span class="line">                <span class="keyword">if</span> queue:</span><br><span class="line">                    res += [queue]</span><br><span class="line">                nCount = len(stack) <span class="comment">#得到的是下一层的个数</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<ul>
<li>两种方法，重点是找到如何重新计数level的层级，第一种方法不是顺着一步一步写进结果里的，是跳着写进去的。第二个方法是直接写进去的</li>
</ul>
<h1 id="103-把树按层zigzag排列"><a href="#103-把树按层zigzag排列" class="headerlink" title="103 把树按层zigzag排列"></a>103 把树按层zigzag排列</h1><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its zigzag level order traversal as:<br>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        levels = []</span><br><span class="line">        self.Find(root,<span class="number">0</span>,levels)</span><br><span class="line">        <span class="keyword">return</span> levels</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, node, level, levels)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> len(levels) &lt;= level:</span><br><span class="line">                levels.append([node.val])</span><br><span class="line">            <span class="keyword">elif</span> level%<span class="number">2</span>:</span><br><span class="line">                levels[level].insert(<span class="number">0</span>,node.val)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> level%<span class="number">2</span>:</span><br><span class="line">                levels[level].append(node.val)</span><br><span class="line">            </span><br><span class="line">            self.Find(node.left,level+<span class="number">1</span>,levels)</span><br><span class="line">            self.Find(node.right,level+<span class="number">1</span>,levels)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>直接判断层数就可以实现，如果用一个flag表示没法在一整层的层面上实现</li>
<li>list是可以两端插入的</li>
</ul>
<h1 id="100-判断两个tree是不是一样的"><a href="#100-判断两个tree是不是一样的" class="headerlink" title="100 判断两个tree是不是一样的"></a>100 判断两个tree是不是一样的</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># if (not p and q) or (not q and p):</span></span><br><span class="line">        <span class="comment">#     return False</span></span><br><span class="line">        <span class="comment"># if p and q:</span></span><br><span class="line">        <span class="comment">#     if p.val != q.val: return False</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)</span></span><br><span class="line">        <span class="comment"># return p == q</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># if p and q:</span></span><br><span class="line">        <span class="comment">#     return p.val == q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)</span></span><br><span class="line">        <span class="comment"># return p == q</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">if</span> p.val != q.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br><span class="line">        <span class="keyword">return</span> p == q</span><br></pre></td></tr></table></figure>
<ul>
<li>感觉自己写recursive总是有点问题，需要判断好终极条件</li>
</ul>
<h1 id="226-把一个二叉树对称变换"><a href="#226-把一个二叉树对称变换" class="headerlink" title="226 把一个二叉树对称变换"></a>226 把一个二叉树对称变换</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不需要变换树的val，可以直接变换node</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># def invert(L,R):</span></span><br><span class="line">        <span class="comment">#     if L and R:</span></span><br><span class="line">        <span class="comment">#         L.val, R.val = R.val, L.val</span></span><br><span class="line">        <span class="comment">#         invert(L.left,R.right)</span></span><br><span class="line">        <span class="comment">#         invert(L.right,R.left)</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> root: </span><br><span class="line">            invert = self.invertTree</span><br><span class="line">            root.right, root.left = invert(root.left), invert(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<ul>
<li>需要换node而不是换val</li>
</ul>
<h1 id="257"><a href="#257" class="headerlink" title="257"></a>257</h1><p>Given a binary tree, return all root-to-leaf paths.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Input:</p>
<p>   1<br> /   \<br>2     3<br> \<br>  5</p>
<p>Output: [“1-&gt;2-&gt;5”, “1-&gt;3”]</p>
<p>Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root: TreeNode)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack = [(root,<span class="string">""</span>)]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            current,ls = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> current.left <span class="keyword">and</span> <span class="keyword">not</span> current.right:</span><br><span class="line">                result.append(ls+str(current.val))</span><br><span class="line">            <span class="keyword">if</span> current.right:</span><br><span class="line">                stack.append((current.right,ls+str(current.val)+<span class="string">"-&gt;"</span>))</span><br><span class="line">            <span class="keyword">if</span> current.left:</span><br><span class="line">                stack.append((current.left,ls+str(current.val)+<span class="string">"-&gt;"</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<ul>
<li>dfs的方法，终止条件是现在的点没有任何child了。自己搞错的地方主要是需要string跟着stack一起走，而不是两个分别判断。</li>
<li>同样的到底可以写出来第112题，本质上是一样的，就是把求路径换成了这个路径的和</li>
<li>同理写出来113，在tuple里面再加上路径的计算就可以了</li>
<li>129也同理！但是129可以直接在每次recursion里面把上一位数乘10，然后加上这一位数，这样会比得到所有路径再计算的速度快很多</li>
</ul>
<h1 id="111-找出这个tree的最小depth"><a href="#111-找出这个tree的最小depth" class="headerlink" title="111 找出这个tree的最小depth"></a>111 找出这个tree的最小depth</h1><ul>
<li>可以用BFS也可以用DFS，但是注意的是两个return的东西的条件是不一样的。DFS的时候必须把左右树比大小<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># stack = [(root,1)]</span></span><br><span class="line">        <span class="comment"># while stack:</span></span><br><span class="line">        <span class="comment">#     current,depth = stack.pop(0)</span></span><br><span class="line">        <span class="comment">#     if not current.left and not current.right:</span></span><br><span class="line">        <span class="comment">#         return depth</span></span><br><span class="line">        <span class="comment">#     if current.left:</span></span><br><span class="line">        <span class="comment">#         stack.append((current.left,depth+1))</span></span><br><span class="line">        <span class="comment">#     if current.right:</span></span><br><span class="line">        <span class="comment">#         stack.append((current.right,depth+1))</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#         dfs</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> max(self.minDepth(root.left),self.minDepth(root.right))+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> min(self.minDepth(root.left),self.minDepth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="104"><a href="#104" class="headerlink" title="104"></a>104</h1><ul>
<li>寻找最深的层</li>
<li>不用判断条件，直接dfs每次加一就可以实现了<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># if not root.left and not root.right:</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left),self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="110-判断是不是平衡树"><a href="#110-判断是不是平衡树" class="headerlink" title="110 判断是不是平衡树"></a>110 判断是不是平衡树</h1><ul>
<li>recursion的方法，注意的是每次返回的时候连带着子树是否平衡一起返回的，整体思路和之前的带着深度一起返回的感觉差不多</li>
<li>或者也可以直接设置一个函数，计算出各个部分的height，然后再放到isBalance里面从上到下计算<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(root)[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> (<span class="number">0</span>, <span class="literal">True</span>) <span class="comment">#depth, if_balance</span></span><br><span class="line">        l_depth, l_balance = self.dfs(root.left)</span><br><span class="line">        r_depth, r_balance = self.dfs(root.right)</span><br><span class="line">        <span class="keyword">return</span> max(l_depth,r_depth)+<span class="number">1</span>, l_balance <span class="keyword">and</span> r_balance <span class="keyword">and</span> abs(l_depth-r_depth) &lt;= <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="337-213"><a href="#337-213" class="headerlink" title="337/213"></a>337/213</h1><p>都是贼偷东西，不能连着偷两家。简单的动态规划问题。<br>这个问题的主要思路如下：</p>
<ul>
<li>对于每一家，其实都有两种情况：偷这家和不偷这家情况下得到的钱<ul>
<li>偷这家的时候，偷到的钱等于：这家的钱+前一家（childnode）不偷时候得到的钱</li>
<li>不偷这家的时候，偷到得钱等于：max（偷前一家，不偷前一家）<ul>
<li><strong>注意这种情况下，前一家可以偷可以不偷，取决于有多少钱</strong><br>三个题如下：</li>
</ul>
</li>
</ul>
</li>
<li>最简单的情况是数组</li>
<li>中等情况是一个环，即数组的收尾不能连着偷。在这种情况下其实就是计算两次，一次不偷第一家，一次不偷最后一家，看哪种情况多</li>
<li>最后的情况是二叉树的情况，这种情况下可以给每个点都规定一个tuple分别表示偷了和没偷的结果</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#第二种情况下</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> max(self.simple_rob(nums[<span class="number">1</span>:]),self.simple_rob(nums[:<span class="number">-1</span>]))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simple_rob</span><span class="params">(self,nums)</span>:</span></span><br><span class="line">        rob,not_rob = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            rob,not_rob = not_rob+n, max(not_rob,rob)</span><br><span class="line">        <span class="keyword">return</span> max(rob,not_rob)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#第三种情况下</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> max(self.dfs(root))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>,<span class="number">0</span>) <span class="comment"># [0]steal this node, [1] don't steal this node</span></span><br><span class="line">        left = self.dfs(root.left)</span><br><span class="line">        right = self.dfs(root.right)</span><br><span class="line">        <span class="keyword">return</span> (root.val + left[<span class="number">1</span>] + right[<span class="number">1</span>],max(left[<span class="number">0</span>],left[<span class="number">1</span>]) + max(right[<span class="number">0</span>],right[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<h1 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235 Lowest Common Ancestor of a Binary Search Tree"></a>235 Lowest Common Ancestor of a Binary Search Tree</h1><ul>
<li>找到给的两个点的最低的公共的祖先（parent）</li>
<li>其实需要注意这个思路，思路就是当这两个点都比现在的root小的时候，那这个公共点在root的左边，如果都小的时候就在右边。</li>
<li>因为这里要找的是最low的公共点，也就是离root最远的点</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> max(p.val,q.val) &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        <span class="keyword">if</span> min(p.val,q.val) &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1 id="236"><a href="#236" class="headerlink" title="236"></a>236</h1><ul>
<li>依然是找公共祖先，但是不是在BST里面找而是普通的二叉树里面找了，所以也就是不能用BST的性质了<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root==p <span class="keyword">or</span> root ==q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">or</span> right</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="108"><a href="#108" class="headerlink" title="108"></a>108</h1><p> Convert Sorted Array to Binary Search Tree</p>
<ul>
<li>注意，已经给了排好序的array了，而且需要的结果是height-balance的，这里可以直接取这个array最中间的作为root，然后左右分别recursion</li>
<li>如果用平常的插入方法，插入进来的树不一定是平衡的<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = len(nums) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        </span><br><span class="line">        root.left = self.sortedArrayToBST(nums[:mid])</span><br><span class="line">        root.right = self.sortedArrayToBST(nums[mid+<span class="number">1</span>:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="77-回溯法，列举所有组合"><a href="#77-回溯法，列举所有组合" class="headerlink" title="77 回溯法，列举所有组合"></a>77 回溯法，列举所有组合</h1><ul>
<li>回溯法需要注意三个阶段<ul>
<li>可以选择的条件是什么（需要在这些条件里迭代)</li>
<li>对条件的限制是什么。比如在这个例子里面，如果一个数字用过了就不能再用了。不能实现或者已经实现的条件需要弹出</li>
<li>目标：需要得到一个base case。比如这个题里面，字符串的长度到了k，就需要输入了</li>
</ul>
</li>
<li>用于问题种类：计算或者列举全部的可能</li>
<li>这道题的python的问题，在list里面append之后pop明显会出现一些问题<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        all_res = []</span><br><span class="line">        self.search(<span class="number">1</span>,n,k,[],all_res)</span><br><span class="line">        <span class="keyword">return</span> all_res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,index,n,k,res,all_res)</span>:</span> <span class="comment">#start, n, choose num, all result</span></span><br><span class="line">        <span class="keyword">if</span> len(res) == k: </span><br><span class="line">            all_res.append(res)</span><br><span class="line">            <span class="comment"># print(all_res)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># res.append(i)</span></span><br><span class="line">            <span class="comment"># print("before",res)</span></span><br><span class="line">            <span class="comment"># print(i+1,res,all_res)</span></span><br><span class="line">            self.search(i+<span class="number">1</span>,n,k,res+[i],all_res)</span><br><span class="line">            <span class="comment"># del(res[-1])</span></span><br><span class="line">            <span class="comment"># print("after",res)</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="39-所有能到target数字的组合-回溯"><a href="#39-所有能到target数字的组合-回溯" class="headerlink" title="39 所有能到target数字的组合 回溯"></a>39 所有能到target数字的组合 回溯</h1><p>Input: candidates = [2,3,6,7], target = 7,<br>A solution set is:<br>[<br>  [7],<br>  [2,2,3]<br>]<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solver</span><span class="params">(nums,target,index,path,res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># path.sort()</span></span><br><span class="line">                <span class="comment"># if path not in res:</span></span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index,len(nums)):</span><br><span class="line">                solver(nums,target-nums[i],i,path+[nums[i]],res)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        solver(candidates,target,<span class="number">0</span>,[],res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意这里需要每次从i开始进行下一轮，也就是如果第一个2可以加进去，第二次还是从2开始往里试着加。要是2加不进去了，就只会往2后面的index走（也就是默认给你的list已经是排好序的了）</li>
<li>整体思路和前面几道题差不多。重点就是确认停止的条件，然后每次先判断停止条件，如果不符合再进行recursion。注意recursion的每轮的条件判定</li>
</ul>
<h1 id="40"><a href="#40" class="headerlink" title="40"></a>40</h1><ul>
<li>数字不是按顺序排好的了，数字会重复出现了</li>
<li><p>我选择的方法是在每次加入新的path之前，排序，然后比对这个是否在已经算出来的结果里面（虽然好像不快）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solver</span><span class="params">(nums,target,index,path,res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                path.sort()</span><br><span class="line">                <span class="keyword">if</span> path <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                    res.append(path)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index,len(nums)):</span><br><span class="line">                solver(nums,target-nums[i],i+<span class="number">1</span>,path+[nums[i]],res)</span><br><span class="line">        res = []</span><br><span class="line">        solver(candidates,target,<span class="number">0</span>,[],res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>别人的方法主要增加了两个新的判断，第一个是如果在for里面，现在的数字已经比需要的target大了，那么就不需要继续搜索后面所有的部分了（？）。因为现在所有的数字都是positive的</p>
</li>
<li><p>最重要的是，如果这个数字不是第一个放进去的数字，并且这个数字和之前的数字相同，那么这个数字应该直接被ignore</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solver</span><span class="params">(nums,target,index,path,res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                print(path)</span><br><span class="line">                res.append(path)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index,len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; index <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                solver(nums,target-nums[i],i+<span class="number">1</span>,path+[nums[i]],res)</span><br><span class="line">        res = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        solver(candidates,target,<span class="number">0</span>,[],res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>以 1，1，2，5，6，7，10凑8为例子</p>
<ul>
<li>当取第一个1的时候，能组出来116，125，17，三个结果。这时候这三个结果都在第一层的i=0的时候的出来的结果。当这一层所有的结果取过之后，就会从第一个1退出来，进到第二个1.</li>
<li>但是如果直接算第2个1，也能组粗125和17，从结果上说这两个1是重复的，所以代码在这部分直接continue了，没有计算第二个1，而是直接跳到了第三个数字2</li>
<li>这样计算重复的方法比我再sort一次然后search一次消耗的时间少很多</li>
</ul>
</li>
</ul>
<h1 id="216-回溯"><a href="#216-回溯" class="headerlink" title="216 回溯"></a>216 回溯</h1><ul>
<li>从1-9里选k个数字组合，得到目标数字</li>
<li>很简单，没啥可搞的<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k: int, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Solver</span><span class="params">(nums,k,n,index,path,res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == k:</span><br><span class="line">                <span class="keyword">if</span> n &lt;<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                    res.append(path)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index,<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt; n:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                Solver(nums,k,n-nums[i],i+<span class="number">1</span>,path+[nums[i]],res)</span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">        nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">        res = []</span><br><span class="line">        Solver(nums,k,n,<span class="number">0</span>,[],res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="377-虽然放在上面的系列里了但是是DP"><a href="#377-虽然放在上面的系列里了但是是DP" class="headerlink" title="377 虽然放在上面的系列里了但是是DP"></a>377 虽然放在上面的系列里了但是是DP</h1><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
<p>Example:</p>
<p>nums = [1, 2, 3]<br>target = 4</p>
<p>The possible combination ways are:<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)</p>
<p>Note that different sequences are counted as different combinations.</p>
<p>Therefore the output is 7.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        com = [<span class="number">1</span>] + [<span class="number">0</span>]*target</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num &gt; i: <span class="keyword">break</span></span><br><span class="line">                com[i] += com[i-num]</span><br><span class="line">        <span class="keyword">return</span> com[target]</span><br></pre></td></tr></table></figure>
<h1 id="46-找出所有的排列组合"><a href="#46-找出所有的排列组合" class="headerlink" title="46 找出所有的排列组合"></a>46 找出所有的排列组合</h1><p>Given a collection of distinct integers, return all possible permutations.</p>
<p>Example:</p>
<p>Input: [1,2,3]<br>Output:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<ul>
<li>这里每个数字不止用一次，所以需要一个方法来记录已经visit的数字，或者把nums的大小改变（比如每一次新输入的nums都跳过现在使用的数字）</li>
<li>注意这里面没有重复的数字</li>
<li>我这个方法也可以</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Solver</span><span class="params">(nums,index,path,res)</span>:</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> len(path) == len(nums):</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> path:</span><br><span class="line">                    Solver(nums,i+<span class="number">1</span>,path+[i],res)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        Solver(nums,<span class="number">0</span>,[],res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="47在上面的基础上有了重复的数字"><a href="#47在上面的基础上有了重复的数字" class="headerlink" title="47在上面的基础上有了重复的数字"></a>47在上面的基础上有了重复的数字</h1><ul>
<li>首先保证了数组必须要是sort的，这样才能确定相同的数字挨在一起</li>
<li>核心思想就是，每次取出一个数字的时候，把原来nums的这个数直接去掉，下次再从0开始找，这样就能得到所有的数据了</li>
<li>在recursion判断条件上，因为已经确定了数组有序，所有每次记录一个temp，来表示上一个数字，只有当这个数字 第一次被拿出来（index==0）or这个数字和上一个数字不相等or上一个还没有数字的时候，才能进入recursion<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Solver</span><span class="params">(nums,temp,path,res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)):</span><br><span class="line">                <span class="keyword">if</span> temp <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> nums[i] != temp <span class="keyword">or</span> i == <span class="number">0</span>:</span><br><span class="line">                    temp = nums[i]</span><br><span class="line">                    Solver(nums[:i]+nums[i+<span class="number">1</span>:],temp,path+[nums[i]],res)</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        Solver(nums,<span class="literal">None</span>,[],res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="60"><a href="#60" class="headerlink" title="60"></a>60</h1><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order, we get the following sequence for n = 3:</p>
<p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>Given n and k, return the kth permutation sequence.</p>
<ul>
<li>时间太长了，不能用backtracking来做</li>
<li>思路，前（n-1）！个数字的开头是1，然后n-1！个是2，然后是3，以此类推一直到最后。因为一共n个数字，n-1！xn也就是n！了</li>
<li>在确定第一个数字之后，第二个数字的前n-2！个是2，然后是3，然后以此类推</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigphess.github.io/2019/05/07/CS231nassignment2Pytorch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RUOPENG XU">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天开始努力学习">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/07/CS231nassignment2Pytorch/" class="post-title-link" itemprop="url">CS231Nassignment2之Pytorch</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 13:25:38 / Modified: 18:15:35" itemprop="dateCreated datePublished" datetime="2019-05-07T13:25:38+09:00">2019-05-07</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/" itemprop="url" rel="index"><span itemprop="name">图像处理</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/Deep-Learning/" itemprop="url" rel="index"><span itemprop="name">Deep Learning</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/Deep-Learning/CS231n作业/" itemprop="url" rel="index"><span itemprop="name">CS231n作业</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这部分需要在torch和TensorFlow两个framework里面选一个。</p>
<h1 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h1><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><ul>
<li>加入了Tensor的object（类似于narray），不需要手动的backprop了</li>
</ul>
<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><ul>
<li>在GPU上面跑，不需要CUDA就可以在自己的GPU上面跑NN</li>
<li>functions很多</li>
<li>站在巨人的肩膀上！</li>
<li>在实际使用中应该写的深度学习代码</li>
</ul>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul>
<li>Justin Johnson has made an excellent<a href="https://github.com/jcjohnson/pytorch-examples" target="_blank" rel="noopener">tutorial</a> for PyTorch.</li>
<li>Detailed<a href="http: // pytorch.org / docs / stable / index.html" target="_blank" rel="noopener">API doc</a></li>
<li>If you have other questions that are not addressed by the API docs, the <a href="https: // discuss.pytorch.org /" target="_blank" rel="noopener">PyTorch forum</a> is a much better place to ask than StackOverflow.</li>
</ul>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><ul>
<li>第一部分，准备，使用dataset</li>
<li>第二部分，abstraction level1，直接在最底层的Tensors上面操作</li>
<li>第三部分，abstraction level2，<code>nn.Module</code>定义一个任意的NN结构</li>
<li>第四部分，abstraction level3，<code>nn.Sequential</code>，定义一个简单的线性feed - back网络</li>
<li>第五部分，自己调参，尽量让CIFAR - 10的精度尽可能高</li>
</ul>
<h2 id="Part-1-Preparation"><a href="#Part-1-Preparation" class="headerlink" title="Part 1.Preparation"></a>Part 1.Preparation</h2><p>pytorch里面有下载dataset，预处理并且迭代成minibatch的功能</p>
<p><code>import torchvision.transforms as T</code></p>
<ul>
<li>这个包包括了预处理以及增强data的功能，在这里选择了减去平均的RGB并且除以标准差</li>
<li>然后对不同的部分分别构建了一个dataset object（训练，测试，val），这个dataset会载入一次training example，并且在DataLoader部分构建minibatch</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NUM_TRAIN = <span class="number">49000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The torchvision.transforms package provides tools for preprocessing data</span></span><br><span class="line"><span class="comment"># and for performing data augmentation; here we set up a transform to</span></span><br><span class="line"><span class="comment"># preprocess the data by subtracting the mean RGB value and dividing by the</span></span><br><span class="line"><span class="comment"># standard deviation of each RGB value; we've hardcoded the mean and std.</span></span><br><span class="line">transform = T.Compose([</span><br><span class="line">    T.ToTensor(),</span><br><span class="line">    T.Normalize((<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>), (<span class="number">0.2023</span>, <span class="number">0.1994</span>, <span class="number">0.2010</span>))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># We set up a Dataset object for each split (train / val / test); Datasets load</span></span><br><span class="line"><span class="comment"># training examples one at a time, so we wrap each Dataset in a DataLoader which</span></span><br><span class="line"><span class="comment"># iterates through the Dataset and forms minibatches. We divide the CIFAR-10</span></span><br><span class="line"><span class="comment"># training set into train and val sets by passing a Sampler object to the</span></span><br><span class="line"><span class="comment"># DataLoader telling how it should sample from the underlying Dataset.</span></span><br><span class="line">cifar10_train = dset.CIFAR10(<span class="string">'./cs231n/datasets'</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                             transform=transform)</span><br><span class="line">loader_train = DataLoader(cifar10_train, batch_size=<span class="number">64</span>,</span><br><span class="line">                          sampler=sampler.SubsetRandomSampler(range(NUM_TRAIN)))</span><br><span class="line"></span><br><span class="line">cifar10_val = dset.CIFAR10(<span class="string">'./cs231n/datasets'</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                           transform=transform)</span><br><span class="line">loader_val = DataLoader(cifar10_val, batch_size=<span class="number">64</span>,</span><br><span class="line">                        sampler=sampler.SubsetRandomSampler(range(NUM_TRAIN, <span class="number">50000</span>)))</span><br><span class="line"></span><br><span class="line">cifar10_test = dset.CIFAR10(<span class="string">'./cs231n/datasets'</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>,</span><br><span class="line">                            transform=transform)</span><br><span class="line">loader_test = DataLoader(cifar10_test, batch_size=<span class="number">64</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>需要一个是否使用GPU的flag，并且set到true。在这个作业里面不是必须用GPU跑，但是如果电脑不能enableCUDA的话，<strong>就会自动返回CPU模式</strong>。</li>
<li>除此之外，建立了两个global var，dtype代表float32，device代表用哪个</li>
<li>因为mac本身不支持CUDA，而且好像新版本的系统还不能安装N卡的部分，所以现在用的CPU</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">USE_GPU = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">dtype = torch.float32  <span class="comment"># we will be using float throughout this tutorial</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> USE_GPU <span class="keyword">and</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">'cuda'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    device = torch.device(<span class="string">'cpu'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Constant to control how frequently we print train loss</span></span><br><span class="line">print_every = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'using device:'</span>, device)</span><br></pre></td></tr></table></figure>
<h2 id="Part2-Barebones-PyTorch"><a href="#Part2-Barebones-PyTorch" class="headerlink" title="Part2 Barebones PyTorch"></a>Part2 Barebones PyTorch</h2><ul>
<li>虽然有很多高层的API已经有了很多功能，但是这部分从比较底层的部分来进行</li>
<li>建立一个简单的fc - relu net，两个中间层，没有bias</li>
<li>用Tensor的method来计算forward，并且用自带的autograd来计算back</li>
<li>如果设定了<code>requires_grad = True</code>，那么在计算的时候不仅会计算值，还会生成计算back的graph</li>
<li>if x is a Tensor with <code>x.requires_grad == True</code> then after backpropagation x.grad will be another Tensor holding the gradient of x with respect to the scalar loss at the end</li>
</ul>
<h3 id="PyTorch-Tensors-Flatten-Function"><a href="#PyTorch-Tensors-Flatten-Function" class="headerlink" title="PyTorch Tensors: Flatten Function"></a>PyTorch Tensors: Flatten Function</h3><ul>
<li>Tensors是一个和narray很像的东西，定义了很多比较好用的功能，比如<code>flatten</code>来reshape image data</li>
<li>在Tensor里面一个图片的形状是NxCxHxW<ul>
<li>datapoint的数量</li>
<li>channels</li>
<li>feature map的H和W</li>
</ul>
</li>
<li>但是在affine里面我们希望一个datapoint可以表现成一个单独的vector，而不是channel和宽和高</li>
<li>所以在这里用flatten来首先读取NCHW的数据，然后返回这个data的view（<strong>相当于array里面的reshape，把它改成了Nx？？，其中？？可以是任何值</strong>）</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(x)</span>:</span></span><br><span class="line">    N = x.shape[<span class="number">0</span>]  <span class="comment"># read in N, C, H, W</span></span><br><span class="line">    <span class="comment"># "flatten" the C * H * W values into a single vector per image</span></span><br><span class="line">    <span class="keyword">return</span> x.view(N, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Barebones-PyTorch-Two-Layer-Network"><a href="#Barebones-PyTorch-Two-Layer-Network" class="headerlink" title="Barebones PyTorch: Two-Layer Network"></a>Barebones PyTorch: Two-Layer Network</h3><p>当定义一个 two_layer_fc的时候，会有两层的中间带relu的forward，在写好了forward之后需要确保输出的形状是对的并且没有什么问题(最近好像对这个大小已经没有什么疑问了)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F  <span class="comment"># useful stateless functions</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_layer_fc</span><span class="params">(x, params)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A fully-connected neural networks; the architecture is:</span></span><br><span class="line"><span class="string">    NN is fully connected -&gt; ReLU -&gt; fully connected layer.</span></span><br><span class="line"><span class="string">    Note that this function only defines the forward pass; </span></span><br><span class="line"><span class="string">    PyTorch will take care of the backward pass for us.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The input to the network will be a minibatch of data, of shape</span></span><br><span class="line"><span class="string">    (N, d1, ..., dM) where d1 * ... * dM = D. The hidden layer will have H units,</span></span><br><span class="line"><span class="string">    and the output layer will produce scores for C classes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Inputs:</span></span><br><span class="line"><span class="string">    - x: A PyTorch Tensor of shape (N, d1, ..., dM) giving a minibatch of</span></span><br><span class="line"><span class="string">      input data.</span></span><br><span class="line"><span class="string">    - params: A list [w1, w2] of PyTorch Tensors giving weights for the network;</span></span><br><span class="line"><span class="string">      w1 has shape (D, H) and w2 has shape (H, C).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    - scores: A PyTorch Tensor of shape (N, C) giving classification scores for</span></span><br><span class="line"><span class="string">      the input data x.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># first we flatten the image</span></span><br><span class="line">    x = flatten(x)  <span class="comment"># shape: [batch_size, C x H x W]</span></span><br><span class="line"></span><br><span class="line">    w1, w2 = params</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Forward pass: compute predicted y using operations on Tensors. Since w1 and</span></span><br><span class="line">    <span class="comment"># w2 have requires_grad=True, operations involving these Tensors will cause</span></span><br><span class="line">    <span class="comment"># PyTorch to build a computational graph, allowing automatic computation of</span></span><br><span class="line">    <span class="comment"># gradients. Since we are no longer implementing the backward pass by hand we</span></span><br><span class="line">    <span class="comment"># don't need to keep references to intermediate values.</span></span><br><span class="line">    <span class="comment"># you can also use `.clamp(min=0)`, equivalent to F.relu()</span></span><br><span class="line">    x = F.relu(x.mm(w1))</span><br><span class="line">    x = x.mm(w2)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_layer_fc_test</span><span class="params">()</span>:</span></span><br><span class="line">    hidden_layer_size = <span class="number">42</span></span><br><span class="line">    <span class="comment"># minibatch size 64, feature dimension 50</span></span><br><span class="line">    x = torch.zeros((<span class="number">64</span>, <span class="number">50</span>), dtype=dtype)</span><br><span class="line">    w1 = torch.zeros((<span class="number">50</span>, hidden_layer_size), dtype=dtype)</span><br><span class="line">    w2 = torch.zeros((hidden_layer_size, <span class="number">10</span>), dtype=dtype)</span><br><span class="line">    scores = two_layer_fc(x, [w1, w2])</span><br><span class="line">    print(scores.size())  <span class="comment"># you should see [64, 10]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">two_layer_fc_test()</span><br></pre></td></tr></table></figure>
<h3 id="Barebones-PyTorch-Three-Layer-ConvNet"><a href="#Barebones-PyTorch-Three-Layer-ConvNet" class="headerlink" title="Barebones PyTorch: Three-Layer ConvNet"></a>Barebones PyTorch: Three-Layer ConvNet</h3><ul>
<li>上下这两个都是，在测试的时候可以直接pass 0来测试tensor的大小是不是对的</li>
<li>网络的结构<ul>
<li>conv with bias，channel_1 filters，KW1xKH1，2 zero - padding</li>
<li>RELU</li>
<li>conv with bias，channel_2 filters，KW2xKH2，1 zero - padding</li>
<li>RELU</li>
<li>fc with bias，输出C class</li>
</ul>
</li>
<li>注意！在这里fc之后没有softmax的激活层，因为在后面计算loss的时候会提供softmax，计算起来更加有效率</li>
<li>注意2！在conv2d之前不需要flatten，在fc之前才需要flatten</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_layer_convnet</span><span class="params">(x, params)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Performs the forward pass of a three-layer convolutional network with the</span></span><br><span class="line"><span class="string">    architecture defined above.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Inputs:</span></span><br><span class="line"><span class="string">    - x: A PyTorch Tensor of shape (N, 3, H, W) giving a minibatch of images</span></span><br><span class="line"><span class="string">    - params: A list of PyTorch Tensors giving the weights and biases for the</span></span><br><span class="line"><span class="string">      network; should contain the following:</span></span><br><span class="line"><span class="string">      - conv_w1: PyTorch Tensor of shape (channel_1, 3, KH1, KW1) giving weights</span></span><br><span class="line"><span class="string">        for the first convolutional layer</span></span><br><span class="line"><span class="string">      - conv_b1: PyTorch Tensor of shape (channel_1,) giving biases for the first</span></span><br><span class="line"><span class="string">        convolutional layer</span></span><br><span class="line"><span class="string">      - conv_w2: PyTorch Tensor of shape (channel_2, channel_1, KH2, KW2) giving</span></span><br><span class="line"><span class="string">        weights for the second convolutional layer</span></span><br><span class="line"><span class="string">      - conv_b2: PyTorch Tensor of shape (channel_2,) giving biases for the second</span></span><br><span class="line"><span class="string">        convolutional layer</span></span><br><span class="line"><span class="string">      - fc_w: PyTorch Tensor giving weights for the fully-connected layer. Can you</span></span><br><span class="line"><span class="string">        figure out what the shape should be? (N,channel_2*H*W)</span></span><br><span class="line"><span class="string">      - fc_b: PyTorch Tensor giving biases for the fully-connected layer. Can you</span></span><br><span class="line"><span class="string">        figure out what the shape should be? (C,)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    - scores: PyTorch Tensor of shape (N, C) giving classification scores for x</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    conv_w1, conv_b1, conv_w2, conv_b2, fc_w, fc_b = params</span><br><span class="line">    scores = <span class="literal">None</span></span><br><span class="line">    <span class="comment">################################################################################</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Implement the forward pass for the three-layer ConvNet.                #</span></span><br><span class="line">    <span class="comment">################################################################################</span></span><br><span class="line">    <span class="comment"># *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line">    x = nn.functional.conv2d(x, conv_w1, bias=conv_b1, padding=<span class="number">2</span>)</span><br><span class="line">    x = nn.functional.conv2d(F.relu(x), conv_w2, bias=conv_b2, padding=<span class="number">1</span>)</span><br><span class="line">    x = flatten(x)</span><br><span class="line">    x = x.mm(fc_w) + fc_b</span><br><span class="line">    scores = x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line">    <span class="comment">################################################################################</span></span><br><span class="line">    <span class="comment">#                                 END OF YOUR CODE                             #</span></span><br><span class="line">    <span class="comment">################################################################################</span></span><br><span class="line">    <span class="keyword">return</span> scores</span><br></pre></td></tr></table></figure>
<h3 id="Barebones-PyTorch-Initialization"><a href="#Barebones-PyTorch-Initialization" class="headerlink" title="Barebones PyTorch: Initialization"></a>Barebones PyTorch: Initialization</h3><ul>
<li><code>random_weight(shape)</code> initializes a weight tensor with the Kaiming normalization method. -&gt; 使用了KAIMING normal</li>
<li><code>zero_weight(shape)</code> initializes a weight tensor with all zeros. Useful for instantiating bias parameters.</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_weight</span><span class="params">(shape)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create random Tensors for weights; setting requires_grad=True means that we</span></span><br><span class="line"><span class="string">    want to compute gradients for these Tensors during the backward pass.</span></span><br><span class="line"><span class="string">    We use Kaiming normalization: sqrt(2 / fan_in)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(shape) == <span class="number">2</span>:  <span class="comment"># FC weight</span></span><br><span class="line">        fan_in = shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># conv weight [out_channel, in_channel, kH, kW]</span></span><br><span class="line">        fan_in = np.prod(shape[<span class="number">1</span>:])</span><br><span class="line">    <span class="comment"># randn is standard normal distribution generator.</span></span><br><span class="line">    w = torch.randn(shape, device=device, dtype=dtype) * np.sqrt(<span class="number">2.</span> / fan_in)</span><br><span class="line">    w.requires_grad = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zero_weight</span><span class="params">(shape)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> torch.zeros(shape, device=device, dtype=dtype, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># create a weight of shape [3 x 5]</span></span><br><span class="line"><span class="comment"># you should see the type `torch.cuda.FloatTensor` if you use GPU.</span></span><br><span class="line"><span class="comment"># Otherwise it should be `torch.FloatTensor`</span></span><br><span class="line">random_weight((<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Barebones-PyTorch-Check-Accuracy"><a href="#Barebones-PyTorch-Check-Accuracy" class="headerlink" title="Barebones PyTorch: Check Accuracy"></a>Barebones PyTorch: Check Accuracy</h3><ul>
<li>在这部分不需要计算grad，所以要关上<code>torch.no_grad()</code>避免浪费</li>
<li>输入<ul>
<li>一个DataLoader来给我们想要check的data分块</li>
<li>一个表示模型到底是什么样子的model_fn，来计算预测的scores</li>
<li>这个model需要的参数</li>
</ul>
</li>
<li>没有返回值但是会print出来acc</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_accuracy_part2</span><span class="params">(loader, model_fn, params)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Check the accuracy of a classification model.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Inputs:</span></span><br><span class="line"><span class="string">    - loader: A DataLoader for the data split we want to check</span></span><br><span class="line"><span class="string">    - model_fn: A function that performs the forward pass of the model,</span></span><br><span class="line"><span class="string">      with the signature scores = model_fn(x, params)</span></span><br><span class="line"><span class="string">    - params: List of PyTorch Tensors giving parameters of the model</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns: Nothing, but prints the accuracy of the model</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    split = <span class="string">'val'</span> <span class="keyword">if</span> loader.dataset.train <span class="keyword">else</span> <span class="string">'test'</span></span><br><span class="line">    print(<span class="string">'Checking accuracy on the %s set'</span> % split)</span><br><span class="line">    num_correct, num_samples = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> loader:</span><br><span class="line">            x = x.to(device=device, dtype=dtype)  <span class="comment"># move to device, e.g. GPU</span></span><br><span class="line">            y = y.to(device=device, dtype=torch.int64)</span><br><span class="line">            scores = model_fn(x, params)</span><br><span class="line">            _, preds = scores.max(<span class="number">1</span>)</span><br><span class="line">            num_correct += (preds == y).sum()</span><br><span class="line">            num_samples += preds.size(<span class="number">0</span>)</span><br><span class="line">        acc = float(num_correct) / num_samples</span><br><span class="line">        print(<span class="string">'Got %d / %d correct (%.2f%%)'</span> %</span><br><span class="line">              (num_correct, num_samples, <span class="number">100</span> * acc))</span><br></pre></td></tr></table></figure>
<h3 id="BareBones-PyTorch-Training-Loop"><a href="#BareBones-PyTorch-Training-Loop" class="headerlink" title="BareBones PyTorch: Training Loop"></a>BareBones PyTorch: Training Loop</h3><ul>
<li>用stochastic gradient descent without momentum来train，并且用<code>torch.functional.cross_entropy</code>来计算loss</li>
<li>输入<ul>
<li>model_fc</li>
<li>params</li>
<li>learning_rate</li>
</ul>
</li>
<li>没有输出</li>
<li>进行的操作<ul>
<li>把data移动到GPU或者CPU</li>
<li>计算score和loss</li>
<li>loss.backward()</li>
<li>update params，这部分不需要计算grad</li>
</ul>
</li>
</ul>
<h3 id="BareBones-PyTorch-Training-a-ConvNet"><a href="#BareBones-PyTorch-Training-a-ConvNet" class="headerlink" title="BareBones PyTorch: Training a ConvNet"></a>BareBones PyTorch: Training a ConvNet</h3><ul>
<li>需要网络<ol>
<li>Convolutional layer(with bias) with 32 5x5 filters, with zero - padding of 2</li>
<li>ReLU</li>
<li>Convolutional layer(with bias) with 16 3x3 filters, with zero - padding of 1</li>
<li>ReLU</li>
<li>Fully - connected layer(with bias) to compute scores for 10 classes</li>
</ol>
</li>
<li>需要自己初始化参数，不需要tune hypers<ul>
<li>注意1：fc的w的大小是D,C，跟数据无关需要从上一层的输出求</li>
<li>conv之后的图片大小从32-&gt; 30</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">learning_rate = <span class="number">3e-3</span></span><br><span class="line"></span><br><span class="line">channel_1 = <span class="number">32</span></span><br><span class="line">channel_2 = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">conv_w1 = <span class="literal">None</span></span><br><span class="line">conv_b1 = <span class="literal">None</span></span><br><span class="line">conv_w2 = <span class="literal">None</span></span><br><span class="line">conv_b2 = <span class="literal">None</span></span><br><span class="line">fc_w = <span class="literal">None</span></span><br><span class="line">fc_b = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Initialize the parameters of a three-layer ConvNet.                    #</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line">conv_w1 = random_weight((channel_1, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">conv_b1 = zero_weight(channel_1)</span><br><span class="line">conv_w2 = random_weight((channel_2, channel_1, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">conv_b2 = zero_weight(channel_2)</span><br><span class="line">fc_w = random_weight((channel_2 * <span class="number">30</span> * <span class="number">30</span>, <span class="number">10</span>))</span><br><span class="line">fc_b = zero_weight(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#                                 END OF YOUR CODE                             #</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"></span><br><span class="line">params = [conv_w1, conv_b1, conv_w2, conv_b2, fc_w, fc_b]</span><br><span class="line">train_part2(three_layer_convnet, params, learning_rate)</span><br></pre></td></tr></table></figure>
<h2 id="Part3-PyTorch-Module-API"><a href="#Part3-PyTorch-Module-API" class="headerlink" title="Part3 PyTorch Module API"></a>Part3 PyTorch Module API</h2><ul>
<li>上面的所有过程是手算来track整个过程的，但是在更大的net里面就没有什么用了</li>
<li><code>nn.Module</code>来定义网络，并且可以选optmi的方法</li>
</ul>
<ol>
<li><p>Subclass <code>nn.Module</code>. Give your network class an intuitive name like <code>TwoLayerFC</code>. </p>
</li>
<li><p><code>__init__()</code>里面定义自己需要的所有层.  <code>nn.Linear</code> and <code>nn.Conv2d</code> 都在模块里自带了. <code>nn.Module</code> will track these internal parameters for you. Refer to the <a href="http://pytorch.org/docs/master/nn.html" target="_blank" rel="noopener">doc</a> to learn more about the dozens of builtin layers. <strong>Warning</strong>: don’t forget to call the <code>super().__init__()</code> first!（调用父类）</p>
</li>
<li><p>In the <code>forward()</code> method, define the <em>connectivity</em> of your network. 直接用init里面初始化好的方法来forward，不要再forward里面增加新的方法</p>
</li>
</ol>
<h3 id="用上面的方法来写一个三层的layer"><a href="#用上面的方法来写一个三层的layer" class="headerlink" title="用上面的方法来写一个三层的layer"></a>用上面的方法来写一个三层的layer</h3><ul>
<li>注意需要初始化w和b的参数，用kaiming的方法</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeLayerConvNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_channel, channel_1, channel_2, num_classes)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        <span class="comment">########################################################################</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> Set up the layers you need for a three-layer ConvNet with the  #</span></span><br><span class="line">        <span class="comment"># architecture defined above.                                          #</span></span><br><span class="line">        <span class="comment">########################################################################</span></span><br><span class="line">        <span class="comment"># *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line">        self.conv_1 = nn.Conv2d(in_channel,channel_1,<span class="number">5</span>,stride=<span class="number">1</span>, padding=<span class="number">2</span>,bias=<span class="literal">True</span>)</span><br><span class="line">        nn.init.kaiming_normal_(self.conv_1.weight)</span><br><span class="line">        nn.init.constant_(self.conv_1.bias, <span class="number">0</span>)</span><br><span class="line">        self.conv_2 = nn.Conv2d(channel_1,channel_2,<span class="number">3</span>,stride=<span class="number">1</span>, padding=<span class="number">1</span>,bias=<span class="literal">True</span>)</span><br><span class="line">        nn.init.kaiming_normal_(self.conv_2.weight)</span><br><span class="line">        nn.init.constant_(self.conv_2.bias, <span class="number">0</span>)</span><br><span class="line">        self.fc_3 = nn.Linear(channel_2 * <span class="number">32</span> * <span class="number">32</span> , num_classes)</span><br><span class="line">        nn.init.kaiming_normal_(self.fc_3.weight)</span><br><span class="line">        nn.init.constant_(self.fc_3.bias, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line">        <span class="comment">########################################################################</span></span><br><span class="line">        <span class="comment">#                          END OF YOUR CODE                            #       </span></span><br><span class="line">        <span class="comment">########################################################################</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        scores = <span class="literal">None</span></span><br><span class="line">        <span class="comment">########################################################################</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> Implement the forward function for a 3-layer ConvNet. you      #</span></span><br><span class="line">        <span class="comment"># should use the layers you defined in __init__ and specify the        #</span></span><br><span class="line">        <span class="comment"># connectivity of those layers in forward()                            #</span></span><br><span class="line">        <span class="comment">########################################################################</span></span><br><span class="line">        <span class="comment"># *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line">        x = self.conv_1(x)</span><br><span class="line">        x = self.conv_2(F.relu(x))</span><br><span class="line">        x = flatten(F.relu(x))</span><br><span class="line">        x = self.fc_3(x)</span><br><span class="line">        scores = x</span><br><span class="line"></span><br><span class="line">        <span class="comment"># *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line">        <span class="comment">########################################################################</span></span><br><span class="line">        <span class="comment">#                             END OF YOUR CODE                         #</span></span><br><span class="line">        <span class="comment">########################################################################</span></span><br><span class="line">        <span class="keyword">return</span> scores</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_ThreeLayerConvNet</span><span class="params">()</span>:</span></span><br><span class="line">    x = torch.zeros((<span class="number">64</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>), dtype=dtype)  <span class="comment"># minibatch size 64, image size [3, 32, 32]</span></span><br><span class="line">    model = ThreeLayerConvNet(in_channel=<span class="number">3</span>, channel_1=<span class="number">12</span>, channel_2=<span class="number">8</span>, num_classes=<span class="number">10</span>)</span><br><span class="line">    scores = model(x)</span><br><span class="line">    print(scores.size())  <span class="comment"># you should see [64, 10]</span></span><br><span class="line">test_ThreeLayerConvNet()</span><br></pre></td></tr></table></figure>
<h3 id="Module-API-Check-Accuracy"><a href="#Module-API-Check-Accuracy" class="headerlink" title="Module API: Check Accuracy"></a>Module API: Check Accuracy</h3><ul>
<li>不用手动pass参数了，直接就可以得到整个net的acc</li>
</ul>
<h3 id="Module-API-Training-Loop"><a href="#Module-API-Training-Loop" class="headerlink" title="Module API: Training Loop"></a>Module API: Training Loop</h3><ul>
<li>用optimizer这个object来update weights</li>
<li>输入<ul>
<li>model</li>
<li>optimizer</li>
<li>epoch，可选</li>
</ul>
</li>
<li>没有return，但是会打印出来training时候的acc</li>
</ul>
<p>其实就是设置好model和optimizer就可以了</p>
<h2 id="Part4-PyTorch-Sequential-API"><a href="#Part4-PyTorch-Sequential-API" class="headerlink" title="Part4 PyTorch Sequential API"></a>Part4 PyTorch Sequential API</h2><ul>
<li><code>nn.Sequential</code>没有上面的灵活，但是可以集成上面的一串功能</li>
<li>需要提前定义一个在forward里面能用的flatten</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># We need to wrap `flatten` function in a module in order to stack it</span></span><br><span class="line"><span class="comment"># in nn.Sequential</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flatten</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> flatten(x)</span><br><span class="line"></span><br><span class="line">hidden_layer_size = <span class="number">4000</span></span><br><span class="line">learning_rate = <span class="number">1e-2</span></span><br><span class="line"></span><br><span class="line">model = nn.Sequential(</span><br><span class="line">    Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">3</span> * <span class="number">32</span> * <span class="number">32</span>, hidden_layer_size),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(hidden_layer_size, <span class="number">10</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># you can use Nesterov momentum in optim.SGD</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=learning_rate,</span><br><span class="line">                     momentum=<span class="number">0.9</span>, nesterov=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">train_part34(model, optimizer)</span><br></pre></td></tr></table></figure>
<h3 id="实现三层，注意需要初始化参数"><a href="#实现三层，注意需要初始化参数" class="headerlink" title="实现三层，注意需要初始化参数"></a>实现三层，注意需要初始化参数</h3><ul>
<li>这里遇到了一个问题是当用random_weight实现的时候，acc会特别低</li>
<li>从<a href="https://github.com/haofeixu/cs231n/blob/master/assignment2/PyTorch.ipynb" target="_blank" rel="noopener">这里</a>发现可以重新定义另一个计算方法不同的weights</li>
<li>从<a href="http://pytorch.org/docs/stable/nn.html#torch.nn.Module.apply" target="_blank" rel="noopener">这里</a>得知如何给module增加新的function</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xavier_normal</span><span class="params">(shape)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create random Tensors for weights; setting requires_grad=True means that we</span></span><br><span class="line"><span class="string">    want to compute gradients for these Tensors during the backward pass.</span></span><br><span class="line"><span class="string">    We use Xavier normalization: sqrt(2 / (fan_in + fan_out))</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(shape) == <span class="number">2</span>:  <span class="comment"># FC weight</span></span><br><span class="line">        fan_in = shape[<span class="number">1</span>]</span><br><span class="line">        fan_out = shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fan_in = np.prod(shape[<span class="number">1</span>:]) <span class="comment"># conv weight [out_channel, in_channel, kH, kW]</span></span><br><span class="line">        fan_out = shape[<span class="number">0</span>] * shape[<span class="number">2</span>] * shape[<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># randn is standard normal distribution generator. </span></span><br><span class="line">    w = torch.randn(shape, device=device, dtype=dtype) * np.sqrt(<span class="number">2.</span> / (fan_in + fan_out))</span><br><span class="line">    w.requires_grad = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line">channel_1 = <span class="number">32</span></span><br><span class="line">channel_2 = <span class="number">16</span></span><br><span class="line">learning_rate = <span class="number">1e-2</span></span><br><span class="line"></span><br><span class="line">model = <span class="literal">None</span></span><br><span class="line">optimizer = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Rewrite the 2-layer ConvNet with bias from Part III with the           #</span></span><br><span class="line"><span class="comment"># Sequential API.                                                              #</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">3</span>, channel_1,<span class="number">5</span>,stride = <span class="number">1</span>,padding = <span class="number">2</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(channel_1, channel_2,<span class="number">3</span>,stride = <span class="number">1</span>,padding = <span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">32</span>*<span class="number">32</span>*channel_2, <span class="number">10</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_weights</span><span class="params">(m)</span>:</span></span><br><span class="line">    print(m)</span><br><span class="line">    <span class="keyword">if</span> type(m) == nn.Linear:</span><br><span class="line">        m.weight.data = xavier_normal(m.weight.size())</span><br><span class="line">        m.bias.data = zero_weight(m.bias.size())</span><br><span class="line"></span><br><span class="line">model.apply(init_weights)</span><br><span class="line"></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=learning_rate,</span><br><span class="line">                     momentum=<span class="number">0.9</span>, nesterov=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#                                 END OF YOUR CODE                             </span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"></span><br><span class="line">train_part34(model, optimizer)</span><br></pre></td></tr></table></figure>
<h2 id="Part5-来训练CIFAR-10吧！"><a href="#Part5-来训练CIFAR-10吧！" class="headerlink" title="Part5 来训练CIFAR-10吧！"></a>Part5 来训练CIFAR-10吧！</h2><p>自己找net的结构，hyper，loss，optimizers来把CIFAR-10的val_acc在10个epoch之内升到70%以上！</p>
<ul>
<li>Layers in torch.nn package: <a href="http://pytorch.org/docs/stable/nn.html" target="_blank" rel="noopener">http://pytorch.org/docs/stable/nn.html</a></li>
<li>Activations: <a href="http://pytorch.org/docs/stable/nn.html#non-linear-activations" target="_blank" rel="noopener">http://pytorch.org/docs/stable/nn.html#non-linear-activations</a></li>
<li>Loss functions: <a href="http://pytorch.org/docs/stable/nn.html#loss-functions" target="_blank" rel="noopener">http://pytorch.org/docs/stable/nn.html#loss-functions</a></li>
<li>Optimizers: <a href="http://pytorch.org/docs/stable/optim.html" target="_blank" rel="noopener">http://pytorch.org/docs/stable/optim.html</a></li>
</ul>
<p>一些可能的方法：</p>
<ul>
<li><strong>Filter size</strong>: Above we used 5x5; would smaller filters be more efficient?</li>
<li><strong>Number of filters</strong>: Above we used 32 filters. Do more or fewer do better?</li>
<li><strong>Pooling vs Strided Convolution</strong>: Do you use max pooling or just stride convolutions?</li>
<li><strong>Batch normalization</strong>: Try adding spatial batch normalization after convolution layers and vanilla batch normalization after affine layers. Do your networks train faster?</li>
<li><strong>Network architecture</strong>: The network above has two layers of trainable parameters. Can you do better with a deep network? Good architectures to try include:<ul>
<li>[conv-relu-pool]xN -&gt; [affine]xM -&gt; [softmax or SVM]</li>
<li>[conv-relu-conv-relu-pool]xN -&gt; [affine]xM -&gt; [softmax or SVM]</li>
<li>[batchnorm-relu-conv]xN -&gt; [affine]xM -&gt; [softmax or SVM]</li>
</ul>
</li>
<li><strong>Global Average Pooling</strong>: Instead of flattening and then having multiple affine layers, perform convolutions until your image gets small (7x7 or so) and then perform an average pooling operation to get to a 1x1 image picture (1, 1 , Filter#), which is then reshaped into a (Filter#) vector. This is used in <a href="https://arxiv.org/abs/1512.00567" target="_blank" rel="noopener">Google’s Inception Network</a> (See Table 1 for their architecture).</li>
<li><strong>Regularization</strong>: Add l2 weight regularization, or perhaps use Dropout.</li>
</ul>
<p>一些tips：</p>
<ul>
<li>应该会在几百个iter里面就看到进步，如果params work well</li>
<li>tune hyper的时候从一大片range和小的train开始，找到好一些的之后再围绕这个范围找（多训一点）</li>
<li>在找hyper的时候应该用val set</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">model = <span class="literal">None</span></span><br><span class="line">optimizer = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line">channel_1 = <span class="number">16</span></span><br><span class="line">channel_2 = <span class="number">32</span></span><br><span class="line">channel_3 = <span class="number">64</span></span><br><span class="line">channel_4 = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">fc_1 = <span class="number">1024</span></span><br><span class="line">num_classes = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">3</span>, channel_1,<span class="number">3</span>,stride = <span class="number">1</span>,padding = <span class="number">1</span>),</span><br><span class="line">    nn.BatchNorm2d(channel_1),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size = <span class="number">2</span>),</span><br><span class="line">    nn.Conv2d(channel_1, channel_2,<span class="number">3</span>,stride = <span class="number">1</span>,padding = <span class="number">1</span>),</span><br><span class="line">    nn.BatchNorm2d(channel_2),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size = <span class="number">2</span>),</span><br><span class="line">    nn.Conv2d(channel_2, channel_3,<span class="number">3</span>,stride = <span class="number">1</span>,padding = <span class="number">1</span>),</span><br><span class="line">    nn.BatchNorm2d(channel_3),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(channel_3, channel_4,<span class="number">3</span>,stride = <span class="number">1</span>,padding = <span class="number">1</span>),</span><br><span class="line">    nn.BatchNorm2d(channel_4),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size = <span class="number">2</span>),</span><br><span class="line">    Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">4</span>*<span class="number">4</span>*channel_4, num_classes)</span><br><span class="line"><span class="comment">#     nn.Linear(fc_1,num_classes)</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">learning_rate = <span class="number">1e-3</span></span><br><span class="line">optimizer = optim.Adam(model.parameters(), lr=learning_rate,</span><br><span class="line">                     betas=(<span class="number">0.9</span>, <span class="number">0.999</span>), eps=<span class="number">1e-08</span>, weight_decay=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#                                 END OF YOUR CODE                             </span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You should get at least 70% accuracy</span></span><br><span class="line">train_part34(model, optimizer, epochs=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第四层conv试过ksize=1，效果不是很好</li>
<li>BN好像效果很好</li>
<li>maxpool多一些，计算负担少而且效果好像比较好</li>
<li>最终val_acc在77-79左右，test_acc = 76.22</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigphess.github.io/2019/05/07/关于python生成动态变量名/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RUOPENG XU">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天开始努力学习">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/07/关于python生成动态变量名/" class="post-title-link" itemprop="url">关于python生成动态变量名</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 12:29:40 / Modified: 12:38:16" itemprop="dateCreated datePublished" datetime="2019-05-07T12:29:40+09:00">2019-05-07</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程语言/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程语言/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="动态生成变量名"><a href="#动态生成变量名" class="headerlink" title="动态生成变量名"></a>动态生成变量名</h2><p>如果想要生成一系列的a0，a1，….a20这种变量名，直接手写太麻烦了</p>
<h2 id="locals"><a href="#locals" class="headerlink" title="locals"></a>locals</h2><p>local()，以字典的类型返回当前位置的全部局部变量</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arrange_list = locals()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	arrange_list[<span class="string">'list_'</span> + str(i)] = []</span><br></pre></td></tr></table></figure>
<p>调用动态变量，可以用字典的get方法得到变量的值</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arrange_list = locals()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">	<span class="built_in">print</span>(arrange_list.<span class="built_in">get</span>('<span class="built_in">var</span>'+str(i)), end = <span class="string">" "</span>)</span><br></pre></td></tr></table></figure>
<h2 id="利用exec进行赋值"><a href="#利用exec进行赋值" class="headerlink" title="利用exec进行赋值"></a>利用exec进行赋值</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">	exec(<span class="string">'var&#123;&#125; = &#123;&#125;'</span>.format(<span class="selector-tag">i</span>, i))</span><br></pre></td></tr></table></figure>
<p>调用动态变量<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(5):</span><br><span class="line">	exec('<span class="keyword">print</span>(<span class="keyword">var</span>&#123;&#125;, end = <span class="string">" "</span>)'.<span class="keyword">format</span>(i))</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigphess.github.io/2019/04/25/关于多维数组的转置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RUOPENG XU">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天开始努力学习">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/25/关于多维数组的转置/" class="post-title-link" itemprop="url">关于多维数组的转置和增加新的维度</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-25 20:35:23" itemprop="dateCreated datePublished" datetime="2019-04-25T20:35:23+09:00">2019-04-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-26 13:45:52" itemprop="dateModified" datetime="2019-04-26T13:45:52+09:00">2019-04-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程语言/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程语言/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程语言/Python/Numpy/" itemprop="url" rel="index"><span itemprop="name">Numpy</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在二维转置的时候，a[i][j] = a[j][i]<br>在多维数组转置的时候，需要交换他们的下标<br>比如原来的数组是(X,Y,Z)，转置之后是(Z,X,Y)<br>这时候应该用的是np.transpose(A,(2,0,1))</p>
<!-- br -->
<p>np.newaxis -&gt; 增加新的维度<br>原来是（6，）的数组，在行上增加维度变成（1,6）的二维数组，在列上增加维度变为(6,1)的二维数组</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigphess.github.io/2019/04/22/OpenCVCameracalibration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RUOPENG XU">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天开始努力学习">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/22/OpenCVCameracalibration/" class="post-title-link" itemprop="url">学习OpenCV十八章_Camera models & calibration</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-22 13:25:19" itemprop="dateCreated datePublished" datetime="2019-04-22T13:25:19+09:00">2019-04-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-25 16:52:36" itemprop="dateModified" datetime="2019-04-25T16:52:36+09:00">2019-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/" itemprop="url" rel="index"><span itemprop="name">图像处理</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/OpenCV/" itemprop="url" rel="index"><span itemprop="name">OpenCV</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/OpenCV/Calibration/" itemprop="url" rel="index"><span itemprop="name">Calibration</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="camera-models-amp-calibration"><a href="#camera-models-amp-calibration" class="headerlink" title="camera models &amp; calibration"></a>camera models &amp; calibration</h1><p>物体会吸收一部分的光，然后反射一部分的光，反射的光就是他自己的颜色，这个光被我们的眼睛（或者相机）接收，然后投影到我们的视网膜（或者相机的图片）上，这之间的几何关系在CV上面非常重要</p>
<p>其中一个非常简单的模型就是pinhole camera model。光穿过一面墙上的一个小的aperture，这个是这章的模型的开始，但是真实pinhole模型不是很好因为他不能快速曝光（聚集的光不够）-&gt; 眼睛会更厉害一点，但是len还会distort图片。</p>
<p>这章的目的：</p>
<ul>
<li>如何camera calibration</li>
<li>纠正普通的pinhole模型的len的偏差</li>
<li>calibration也同样是获取三维世界的主要方式，因为一个场景不仅仅是三维，他们还有物理的空间和体积，所以获取pixel和三维诗句坐标的关系也很重要</li>
<li>18章纠正的是len的distortion，19章构建整个3D的结构</li>
</ul>
<p>homography transform -&gt; 一个非常重要的要素</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/04/22/OpenCVCameracalibration/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigphess.github.io/2019/04/18/CS231nassignment2CNN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RUOPENG XU">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天开始努力学习">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/18/CS231nassignment2CNN/" class="post-title-link" itemprop="url">CS231nassignment2CNN</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-18 15:12:13" itemprop="dateCreated datePublished" datetime="2019-04-18T15:12:13+09:00">2019-04-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-25 21:05:41" itemprop="dateModified" datetime="2019-04-25T21:05:41+09:00">2019-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/" itemprop="url" rel="index"><span itemprop="name">图像处理</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/Deep-Learning/" itemprop="url" rel="index"><span itemprop="name">Deep Learning</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/Deep-Learning/CS231n作业/" itemprop="url" rel="index"><span itemprop="name">CS231n作业</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><ul>
<li>之前已经实践了fc的相关东西，但是在实际的使用里大家使用的都是CNN</li>
<li>所以这部分就开始实践CNN了</li>
</ul>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/04/18/CS231nassignment2CNN/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigphess.github.io/2019/04/18/CS231nassignment2Dropout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RUOPENG XU">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天开始努力学习">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/18/CS231nassignment2Dropout/" class="post-title-link" itemprop="url">CS231nassignment2之Dropout</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-18 09:51:56 / Modified: 15:11:08" itemprop="dateCreated datePublished" datetime="2019-04-18T09:51:56+09:00">2019-04-18</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/" itemprop="url" rel="index"><span itemprop="name">图像处理</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/Deep-Learning/" itemprop="url" rel="index"><span itemprop="name">Deep Learning</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/Deep-Learning/CS231n作业/" itemprop="url" rel="index"><span itemprop="name">CS231n作业</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul>
<li>regularization NN</li>
<li>randomly setting some features to 0 during <strong>forward pass</strong></li>
</ul>
<p><a href="https://arxiv.org/abs/1207.0580" target="_blank" rel="noopener">Geoffrey E. Hinton et al, “Improving neural networks by preventing co-adaptation of feature detectors”, arXiv 2012</a></p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/04/18/CS231nassignment2Dropout/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigphess.github.io/2019/04/16/OpenGL笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RUOPENG XU">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天开始努力学习">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/16/OpenGL笔记/" class="post-title-link" itemprop="url">OpenGL笔记</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-16 15:57:45" itemprop="dateCreated datePublished" datetime="2019-04-16T15:57:45+09:00">2019-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-05-31 13:04:14" itemprop="dateModified" datetime="2019-05-31T13:04:14+09:00">2019-05-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OpenGl/" itemprop="url" rel="index"><span itemprop="name">OpenGl</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://learnopengl.com/" target="_blank" rel="noopener">Learn OpenGl</a></p>
<p>on Modern OpenGL. -&gt; 从graphics的programming开始讲的</p>
<h1 id="Getting-Start"><a href="#Getting-Start" class="headerlink" title="Getting Start"></a>Getting Start</h1><h2 id="OPENGL"><a href="#OPENGL" class="headerlink" title="OPENGL"></a>OPENGL</h2><ul>
<li>是一个进行图像处理的工具</li>
<li>可以被认为是API，但是实际上是specification<ul>
<li>明确说明了每个function应该的输入和输出，以及如何perform</li>
<li>用户在用这个说明来解决问题，因为没有给出明确的implement的过程，所以只要结果符合规则，怎么implement都可以</li>
</ul>
</li>
</ul>
<h3 id="Core-profile-vs-Immediate-mode"><a href="#Core-profile-vs-Immediate-mode" class="headerlink" title="Core-profile vs Immediate mode"></a>Core-profile vs Immediate mode</h3><ul>
<li>以前的版本用的是immediate mode<ul>
<li>比较好用来画图</li>
<li>具体的是实现都在lib里面，developer不是很好的能看到如何计算</li>
<li>效率越来越低</li>
</ul>
</li>
<li>Core-profile<ul>
<li>在3.2版本之后改成了这个</li>
<li>强制使用modern practices，如果想要用被分出去的function就会直接报错</li>
<li>效率高，更灵活，更难学</li>
</ul>
</li>
</ul>
<h3 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h3><ul>
<li>支持extensions，只要检查支不支持graphic card就可以知道能不能用</li>
<li>可以直接用比较新的东西，不用等着OPENGL更新新的功能</li>
<li>需要在用之前判断他是不是available的，如果不是需要用原来的方法搞</li>
</ul>
<h3 id="State-Machine"><a href="#State-Machine" class="headerlink" title="State Machine"></a>State Machine</h3><ul>
<li>OpenGL自己就是一个State Machine：一个var的集合，来判断他现在应该如何操作</li>
<li>state -&gt; context<ul>
<li>改变state：设定一些options，操作一些buffer，在现在的context来render</li>
</ul>
</li>
<li>例子：<ul>
<li>如果我想画三角形，而不是画线了，就改变draw的state</li>
<li>只要这个改变传达到了，下一条线就画的是三角形了</li>
</ul>
</li>
<li><code>state-changing</code>用来改变context，<code>state-using</code>在现在的state上面开始进行操作</li>
</ul>
<h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><ul>
<li>一个集合来表现OpenGL的subset的state<ul>
<li>比如可以用一个object来表示对window的设定，可以设置大小，设置支持的颜色等等<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The State of OpenGL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenGL_Context</span> &#123;</span></span><br><span class="line">  	...</span><br><span class="line">  	object_name* object_Window_Target;</span><br><span class="line">  	...  	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create object</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> objectId = <span class="number">0</span>;</span><br><span class="line">glGenObject(<span class="number">1</span>, &amp;objectId);</span><br><span class="line"><span class="comment">// bind object to context</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, objectId);</span><br><span class="line"><span class="comment">// set options of object currently bound to GL_WINDOW_TARGET</span></span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="number">800</span>);</span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="number">600</span>);</span><br><span class="line"><span class="comment">// set context target back to default</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>流程<ul>
<li>首先创建了一个object，里面存了一个ref是这个object的id</li>
<li>然后把这个object和context的目标位置bind在了一起</li>
<li>设置了这些window的参数</li>
<li>最后un-bind这两个东西，把window target改回原来的值</li>
</ul>
</li>
<li>这样的话我们可以创建很多object，提前设置好里面的量，等到需要用的时候就直接bind就可以用了<ul>
<li>比如我们有一堆object包含了小人，小马，小鹿</li>
<li>想画哪个就把哪个绑定到draw里面，就可以直接画出来了</li>
</ul>
</li>
</ul>
<h2 id="Crateing-a-window"><a href="#Crateing-a-window" class="headerlink" title="Crateing a window"></a>Crateing a window</h2><p>因为操作系统的问题，所有操作系统上面不是很一样。但是已经有一些提供这些功能的函数了，这里用的是GLFW</p>
<h3 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h3><ul>
<li>一个lib，用C写的，主要目的是提供把东西渲染到屏幕的功能</li>
<li>可以创建一个context，定义窗口的params，处理用户的输入</li>
</ul>
<p>已经一口气配置好了这些！<br><a href="https://www.jianshu.com/p/25d5fbf792a2" target="_blank" rel="noopener">https://www.jianshu.com/p/25d5fbf792a2</a><br><strong>记得在link lib里面把openGL的framework加进去！！！！！</strong></p>
<h3 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h3><ul>
<li>因为openGL还需要不同版本的driver的支持，需要有东西来处理这部分的内容</li>
<li>和其他的东西不同，GLAD用的是<a href="https://glad.dav1d.de/" target="_blank" rel="noopener">web service</a><ul>
<li>在这个网页上选择好语言，版本号，确保profile是core，然后生成</li>
<li>直接下载下来对应的zip，然后把include放进include里面，.c文件放在project里面</li>
</ul>
</li>
<li>莫名其妙并不需要这一步，神奇，可能是我在include里面已经搞进来了！！</li>
</ul>
<h2 id="Hello-Window"><a href="#Hello-Window" class="headerlink" title="Hello Window"></a>Hello Window</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">    <span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先进行了初始化</li>
<li>然后configure了GLFW，设置了a large enum of possible options prefixed with GLFW_. （第三行就是最小） -&gt; 大概是设置要用GLFW的版本号</li>
<li>然后也告诉了他想用core</li>
</ul>
<hr>
<ul>
<li>然后需要使用<code>glfwCreateWindow</code>这个函数，来创建这个<code>GLFWwindow* window</code>的变量<ul>
<li>创建的函数需要窗口的长宽</li>
<li>窗口名</li>
</ul>
</li>
<li>创建完之后就可以把这个窗口设置成<code>glfwMakeContextCurrent(window);</code>也就是说设置成了现在的thread里面<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">glfwMakeContextCurrent(window);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="GLAD-1"><a href="#GLAD-1" class="headerlink" title="GLAD"></a>GLAD</h3><ul>
<li>GLAD是为OpenGL来管理这些函数的，在使用这些函数之前需要初始化GLAD<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="viewpoint"><a href="#viewpoint" class="headerlink" title="viewpoint"></a>viewpoint</h3><ul>
<li>在开始render之前我们还需要告诉GL渲染窗口的大小，用到了<code>glViewport</code>这个函数<ul>
<li>前面两个参数定义了这个窗口左下角的坐标</li>
<li>后面两个参数定义了需要render的窗口的大小</li>
</ul>
</li>
<li>每次调整window的大小的时候viewport也需要被调整</li>
</ul>
<h3 id="engines"><a href="#engines" class="headerlink" title="engines"></a>engines</h3><ul>
<li><p>我们希望这个engine可以一直持续画图，直到最后我们告诉这个窗口要关闭，所以要建立一个循环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    glfwSwapBuffers(window);</span><br><span class="line">    glfwPollEvents();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在这个循环里面，pollevent是来检查是不是有trigger进来的事情（比如键盘输入），更新窗口的状态，并且call相应的函数</p>
</li>
<li>swapbuffer，会交换color buffer（包括每个像素点颜色的buffer），然后show在窗口里面</li>
</ul>
<h3 id="last-thing"><a href="#last-thing" class="headerlink" title="last thing"></a>last thing</h3><ul>
<li><code>glfwTerminate</code>退出这个循环之后，需要清除这些相关的资源，用这个函数放在最底下</li>
</ul>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><ul>
<li>需要一些键盘上的操作来调整的时候，写了一个processInput的函数</li>
<li>比如下面这个函数就是检测了有没有按下去esc，如果按了的话就关闭窗口</li>
<li>写完之后把这个函数在while循环里面调用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="rendering"><a href="#rendering" class="headerlink" title="rendering"></a>rendering</h3><ul>
<li>希望在一个loop里面放上去所有的rendering的命令，整个循环看起来应该是这个样子的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render loop</span></span><br><span class="line"><span class="keyword">while</span>(!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    processInput(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rendering commands here</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check and call events and swap the buffers</span></span><br><span class="line">    glfwPollEvents();</span><br><span class="line">    glfwSwapBuffers(window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="hello-triangle"><a href="#hello-triangle" class="headerlink" title="hello triangle"></a>hello triangle</h2><p><img src="/2019/04/16/OpenGL笔记/1.jpg" alt><br>opengl里面所有东西都是在3D的空间里的，但是屏幕上显示的东西是2D的。整个这个转换的过程叫做<strong>graphics pipeline</strong>，可以分成两个步骤：第一个是把物体的3D坐标转化成2D的坐标，第二个是把2D的坐标转化成pixel上面的具体值</p>
<h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><ul>
<li>所有的转化步骤都可以parallel的进行，现在的显卡有很多小的core来进行 -&gt; shaders</li>
<li>在最开始的时候pass进去了一个list的3D坐标 （Vertex Data）</li>
<li>第一步：vertex shader<ul>
<li>把3D的坐标转化成不同的3D坐标（相当于把数据转化成点？）</li>
</ul>
</li>
<li>primitive assembly<ul>
<li>从上一步得到的左右的点得到输入</li>
<li>然后形成一个基本的图形</li>
</ul>
</li>
<li>geometry shader<ul>
<li>根据新给的点，形成新的不同的形状，比如在例子里面形成了新的一条线</li>
</ul>
</li>
<li>rasterization stage<ul>
<li>把上面得到的primitives map到最后的屏幕上面的相应的pixel上面</li>
</ul>
</li>
<li>Clipping<ul>
<li>这一步丢掉了所有在视线外面的fragments，提升性能</li>
</ul>
</li>
<li>fragment shader<ul>
<li>计算这个pixel最后的颜色，会在这一步计算光影，以及光线的颜色等等东西</li>
</ul>
</li>
<li>当每个像素的颜色决定了以后，这个object会被送到alpha test和blending<ul>
<li>这一步会测试深度原因，判断fragment是在物体的前面还是后面</li>
<li>还会考虑透明度的问题<br>虽然上面的东西很复杂，但是在实际应用的时候只需要要考虑vertex和fragment shader</li>
</ul>
</li>
</ul>
<h3 id="vertex-input"><a href="#vertex-input" class="headerlink" title="vertex input"></a>vertex input</h3><ul>
<li>openGL是3D的东西，所有的点设置input的时候都需要设置三维的坐标 xyz</li>
<li>只有在坐标在 -1 到 1 中间的时候，才会处理这些坐标，这个范围里面的数字是根据屏幕的比例得出来的<code>normalized device coordinates</code></li>
<li><p>比如在这个例子里面，需要的渲染一个三角形，那么需要这个三角形的三个点的坐标。注意这个例子里面根本没有考虑深度，而是直接画在了平面上面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在定义好坐标之后需要把这个东西放进vertex shader里面，需要在GPU里面创建一部分内存来存储这个数据，并且需要在GPU里面存储大量的数据（这样不用每次都送了）</p>
</li>
<li>每个部分的object都会有一个自己的buffer id，可以通过下面的方法生成一个id。也可以把一串array绑到这个id上面<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2019/04/16/OpenGL笔记/2.jpg" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigphess.github.io/2019/04/15/CS231Nassignment2BN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RUOPENG XU">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天开始努力学习">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/15/CS231Nassignment2BN/" class="post-title-link" itemprop="url">CS231Nassignment2之Batch Normalization</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-15 14:21:16" itemprop="dateCreated datePublished" datetime="2019-04-15T14:21:16+09:00">2019-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-18 09:52:30" itemprop="dateModified" datetime="2019-04-18T09:52:30+09:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/" itemprop="url" rel="index"><span itemprop="name">图像处理</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/Deep-Learning/" itemprop="url" rel="index"><span itemprop="name">Deep Learning</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图像处理/Deep-Learning/CS231n作业/" itemprop="url" rel="index"><span itemprop="name">CS231n作业</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><ul>
<li>之前的内容讲了lr的优化方法，比如Adam，另一种方法是根据改变网络的结构，make it easy to train -&gt; batch normalization</li>
<li>想去掉一些uncorrelated features(不相关的特征)，可以在训练数据之前preprocess，变成0-centered分布，这样第一层是没有问题的，但是后面的层里还是会出问题</li>
<li>所以把normalization的部分加入了DN里面，加入了一个BN层，会估计mean和standard deviation of each feature，这样重新centre和normalized</li>
<li>learnable shift and scale parameters for each feature dimension</li>
<li><strong><em>核心思想：粗暴的用BN来解决weights初始化的问题</em></strong></li>
</ul>
<p>ref：<a href="https://kratzert.github.io/2016/02/12/understanding-the-gradient-flow-through-the-batch-normalization-layer.html" target="_blank" rel="noopener">https://kratzert.github.io/2016/02/12/understanding-the-gradient-flow-through-the-batch-normalization-layer.html</a><br></p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/04/15/CS231Nassignment2BN/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigphess.github.io/2019/04/15/CppPrimer笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RUOPENG XU">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天开始努力学习">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/15/CppPrimer笔记/" class="post-title-link" itemprop="url">CppPrimer笔记</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-15 12:04:03" itemprop="dateCreated datePublished" datetime="2019-04-15T12:04:03+09:00">2019-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-16 15:53:30" itemprop="dateModified" datetime="2019-04-16T15:53:30+09:00">2019-04-16</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程语言/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程语言/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="第一部分-Basics"><a href="#第一部分-Basics" class="headerlink" title="第一部分 Basics"></a>第一部分 Basics</h1><ul>
<li>C++在编译的时候就会检查类型</li>
<li>allow programmers to define types that include operations as well as data</li>
</ul>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/04/15/CppPrimer笔记/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpeg" alt="RUOPENG XU">
            
              <p class="site-author-name" itemprop="name">RUOPENG XU</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">76</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">53</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">77</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/Bigphess" title="GitHub &rarr; https://github.com/Bigphess" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:xrp0308@gmail.com" title="E-Mail &rarr; mailto:xrp0308@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  
    <div id="sidebar-dimmer"></div>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RUOPENG XU</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>




  

  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  



  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
