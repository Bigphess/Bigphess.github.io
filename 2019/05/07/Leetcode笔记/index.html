<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.1',
    sidebar: {"position":"right","display":"always","offset":12,"onmobile":true,"dimmer":true},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="#1 twoSumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use t">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode笔记">
<meta property="og:url" content="https://bigphess.github.io/2019/05/07/Leetcode笔记/index.html">
<meta property="og:site_name" content="今天开始努力学习">
<meta property="og:description" content="#1 twoSumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use t">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://bigphess.github.io/2019/05/07/Leetcode笔记/42.jpg">
<meta property="og:image" content="https://bigphess.github.io/2019/05/07/Leetcode笔记/164.jpg">
<meta property="og:updated_time" content="2019-06-05T03:03:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode笔记">
<meta name="twitter:description" content="#1 twoSumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use t">
<meta name="twitter:image" content="https://bigphess.github.io/2019/05/07/Leetcode笔记/42.jpg">






  <link rel="canonical" href="https://bigphess.github.io/2019/05/07/Leetcode笔记/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Leetcode笔记 | 今天开始努力学习</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">今天开始努力学习</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">面向谷歌编程选手许若芃</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories<span class="badge">27</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives<span class="badge">46</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/Bigphess" class="github-corner" title="垃圾代码都在我的github！" aria-label="垃圾代码都在我的github！" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigphess.github.io/2019/05/07/Leetcode笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RUOPENG XU">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天开始努力学习">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode笔记

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 21:57:42" itemprop="dateCreated datePublished" datetime="2019-05-07T21:57:42+09:00">2019-05-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-06-05 12:03:15" itemprop="dateModified" datetime="2019-06-05T12:03:15+09:00">2019-06-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-twoSum"><a href="#1-twoSum" class="headerlink" title="#1 twoSum"></a>#1 twoSum</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:</p>
<p>Given nums = [2, 7, 11, 15], target = 9,</p>
<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - item <span class="keyword">in</span> nums <span class="keyword">and</span> nums.index(target - item) != i:</span><br><span class="line">                <span class="keyword">return</span> [i, nums.index(target - item)]</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>刚开始用了直接for所有的元素的方法，忘记考虑当两个数字重复的时候需要怎么办，考虑了之后在非常大的数的情况下爆炸了</li>
<li>标准答案说到了hash表，但是其实在python实现里面本身就是个hash（不然怎么从索引得到结果），不需要考虑这个问题</li>
<li>然后考虑了把所有东西都放一个dict里面（毕竟hash？），但是遇到的问题是从value直接得到key会生一些问题。如果把数字作为key，索引作为value会发现数字有重复的，会覆盖key的值</li>
<li>这时候突然发现，如果用数字作为索引的话其实dict和list没有本质区别，在list里面操作就行了，而且list的<code>.index()</code>可以直接返回这个值得坐标（找到的是第一个值！！）</li>
<li>所以直接用enumerate把所有的index和item都列出来就可以解决了，神奇。</li>
</ul>
<h2 id="27-remove-element"><a href="#27-remove-element" class="headerlink" title="#27 remove element"></a>#27 remove element</h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>Example 1:</p>
<p>Given nums = [3, 2, 2, 3], val = 3,</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p>It doesn’t matter what you leave beyond the returned length.<br>Example 2:</p>
<p>Given nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2,</p>
<p>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</p>
<p>Note that the order of those five elements can be arbitrary.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        remove_nums = <span class="number">0</span></span><br><span class="line">        ori_length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                remove_nums += <span class="number">1</span></span><br><span class="line">                nums[i] = float(<span class="string">'inf'</span>)</span><br><span class="line">        nums.sort()</span><br><span class="line">        nums = nums[:ori_length - remove_nums]</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>这道题的重点是需要in - place的处理，空间复杂度要求很高（然而我的空间结果很垃圾）。一个重点就是返回的list不需要按照原来的顺序排列</li>
<li>从不需要原来的顺序得到的思路是：我把需要删除的东西的位置改成了inf，然后对所有部分进行排序，得到排序之后的结果再进行切片（这里刚开始的思路是删掉这个地方的东西然后再insert，后来发现直接替换就好了）</li>
<li>其实也可以直接用交换位置的方法，不用切片，因为题目只需要前面的这些元素符合要求就可以了，没有说后面的怎么样。</li>
<li>看了一些discussion都是memory只比5 % 的人少。。。但是差距都不大应该没问题！</li>
</ul>
<p>看到了一个超级牛逼简要写法：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> val <span class="keyword">in</span> nums:</span><br><span class="line">    nums.remove(val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure></p>
<h2 id="80"><a href="#80" class="headerlink" title="#80"></a>#80</h2><p>Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>Example 1:</p>
<p>Given nums = [1,1,1,2,2,3],</p>
<p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</p>
<p>It doesn’t matter what you leave beyond the returned length.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= len(nums) <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> len(nums) &gt; <span class="number">2</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">2</span>]:</span><br><span class="line">                    nums = nums[:nums.index(nums[i])+<span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                next_num = nums[i+<span class="number">1</span>]</span><br><span class="line">                start_index = nums.index(nums[i])</span><br><span class="line">                next_index = nums.index(next_num)</span><br><span class="line">                <span class="keyword">if</span> next_index - start_index &gt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">for</span> l <span class="keyword">in</span> range(start_index+<span class="number">2</span>, next_index):</span><br><span class="line">                        nums[l] = float(<span class="string">'inf'</span>)</span><br><span class="line">                i = next_index</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> float(<span class="string">'inf'</span>) <span class="keyword">in</span> nums:</span><br><span class="line">            nums.remove(float(<span class="string">'inf'</span>))</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>我深信我的方法虽然蠢但是没有问题，但是跑出来就是有问题，分明我return之前的数据还都是对的，但是return之后显示的东西就都有问题了</li>
<li>主要思路是这样的<ul>
<li>因为in-place操作，所以就不能直接用remove去掉元素导致下标错乱</li>
<li>本来是想和上面的思路一样，换成inf，然后再把有inf的部分删除掉（参考了#27的简易解法）</li>
<li>怎么换成inf呢，我判断的方法是找到下一个值得index，然后计算这个index和上一个之间差多少个数，然后把富裕的数字都替换成inf</li>
</ul>
</li>
<li>忽略的问题：<ul>
<li>数数数错了很多问题</li>
<li>最开始没有考虑到什么停止</li>
<li>然后没有考虑到如果最后一个数字重复了两遍以上要怎么办的问题（这也是我用next_index的一个弊端）</li>
</ul>
</li>
</ul>
<p><strong>然后看着大佬的代码哭出了声！！！</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">2</span> <span class="keyword">or</span> n != nums[i<span class="number">-2</span>]:</span><br><span class="line">                nums[i] = n</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></p>
<p>总结：</p>
<ul>
<li>哇这个思路真的牛逼！</li>
<li>中心思想就是让n来增加但是i不增加，这里已经说了不在意前面项之后list里面的内容，也就是说前n项之后的东西都不用管了。既然如此的话与其用inf来替换这个位置的数字，不如直接用后面的项填在相对应的位置上，只有填成功了才会增加i</li>
<li>这里需要<strong>先判断i的值是否小于2，然后再计算nums[i-2]，否则会out of range</strong></li>
<li>i跑的速度没有超过n跑的速度所以没有关系</li>
<li>合理利用题里面的条件限制真的很重要！！</li>
</ul>
<h2 id="189-Rotate-array"><a href="#189-Rotate-array" class="headerlink" title="#189 Rotate array"></a>#189 Rotate array</h2><p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,4,5,6,7] and k = 3<br>Output: [5,6,7,1,2,3,4]<br>Explanation:<br>rotate 1 steps to the right: [7,1,2,3,4,5,6]<br>rotate 2 steps to the right: [6,7,1,2,3,4,5]<br>rotate 3 steps to the right: [5,6,7,1,2,3,4]</p>
<p>Example 2:</p>
<p>Input: [-1,-100,3,99] and k = 2<br>Output: [3,99,-1,-100]<br>Explanation:<br>rotate 1 steps to the right: [99,-1,-100,3]<br>rotate 2 steps to the right: [3,99,-1,-100]</p>
<p>Note:</p>
<p>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br>Could you do it in-place with O(1) extra space?</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>需不需要注意k = 0的时候</li>
<li>如果k的个数特别大需不需要简化一下</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        steps = k % len(nums)</span><br><span class="line">        unchange_nums = nums[:len(nums) - steps]</span><br><span class="line">        change_nums = nums[len(nums) - steps : ]</span><br><span class="line">        nums[:steps] = change_nums</span><br><span class="line">        nums[steps:] = unchange_nums</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>居然第一种就这么写出来了，实际上就是把后面的数字移动到前面去</li>
<li>注意nums不能直接用change_nums + unchange_nums，大概是他认为这个不是in-place了吧</li>
</ul>
<h3 id="另一种方法：in-place"><a href="#另一种方法：in-place" class="headerlink" title="另一种方法：in-place"></a>另一种方法：in-place</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    k = k % len(nums)</span><br><span class="line">    self.reverse_nums(nums,<span class="number">0</span>,len(nums) - <span class="number">1</span>)</span><br><span class="line">    self.reverse_nums(nums,<span class="number">0</span>,k<span class="number">-1</span>)</span><br><span class="line">    self.reverse_nums(nums,k,len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_nums</span><span class="params">(self,nums,start,end)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        temp = nums[start]</span><br><span class="line">        nums[start] = nums[end]</span><br><span class="line">        nums[end] = temp</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">        end -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实际上，rotate的另外一种方法是先把整个list反向，然后把前面的k个反向，然后再把后面的(n-k)个反向（这里我是没想到的）</li>
<li>把一个数组反向的算法就是从两头向中间逼近着交换（我该好好去看看基础的算法了。。）</li>
<li>最后，还有一种方法是跳着设置值，也就是说k个之后的值就应该是现在这个位置的值</li>
</ul>
<h2 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="#41 First Missing Positive"></a>#41 First Missing Positive</h2><p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p>Example 1:</p>
<p>Input: [1,2,0]<br>Output: 3<br>Example 2:</p>
<p>Input: [3,4,-1,1]<br>Output: 2<br>Example 3:</p>
<p>Input: [7,8,9,11,12]<br>Output: 1<br>Note:</p>
<p>Your algorithm should run in O(n) time and uses constant extra space.</p>
<h3 id="第一个思路：时间nlog-n"><a href="#第一个思路：时间nlog-n" class="headerlink" title="第一个思路：时间nlog(n)"></a>第一个思路：时间nlog(n)</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        target = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n == target:</span><br><span class="line">                target += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure>
<ul>
<li>这个思路整体建立在先排序的基础上，但是排序的时间复杂度本身就已经是nlog(n)了</li>
<li>排序 - 找到比0大的数字从这里开始 - 这个数字不符合的话找下一个<ul>
<li>但是我在找比0大的数字的时候还想着把list切片，切片就又需要考虑0啊，1啊，缺多少个数字的问题，空的list。其实根本不用这么麻烦</li>
<li>本质上这个方法就是，找到miss的正数，那就从正数的第一个（1）开始找，如果找到了这个数就继续找下一个（target++），总是能找到的嘛，找到的就是缺的数字了</li>
</ul>
</li>
</ul>
<hr>
<p><strong>自己的方法</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            target_num = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == target_num:</span><br><span class="line">                <span class="keyword">if</span> i == len(nums) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> target_num + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> target_num <span class="keyword">in</span> nums:</span><br><span class="line">                temp = nums.index(target_num)</span><br><span class="line">                nums[temp],nums[i] = nums[i], nums[temp]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> target_num</span><br></pre></td></tr></table></figure></p>
<ul>
<li>桶排序：要把对应的数字放在对应的位置上<ul>
<li>这道题里应该的样子就是nums[index] = index + 1</li>
</ul>
</li>
<li>大佬的思路 -&gt; 首先判断边界条件！！(学到了学到了)</li>
<li>看过了上面的提示写出来的第二版<ul>
<li>判断边界条件</li>
<li>判断这个数字是不是摆在了正确的位置<ul>
<li>正确，判断是否是最后一个数字<ul>
<li>是，输出的是最后一个数字+1</li>
<li>不是，这个位置的正确了，判断下一个位置</li>
</ul>
</li>
<li>没有，判断nums里面还有没有应该摆在这个位置的数字<ul>
<li>有，那就和这个位置交换</li>
<li>没有，那没有的数字就是缺少的数字了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>因为每次都是把数字换到了正确的位置了，所以交换最多进行len(nums)次，时间复杂度是O(n)</li>
</ul>
<hr>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt;= nums[i]<span class="number">-1</span> &lt; len(nums) <span class="keyword">and</span> nums[nums[i]<span class="number">-1</span>] != nums[i]:</span><br><span class="line">            tmp = nums[i]<span class="number">-1</span></span><br><span class="line">            nums[i], nums[tmp] = nums[tmp], nums[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> len(nums)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>大佬的另一个方法，其实思路和上面的差不多，就是把数字换到正确的位置上，但是判断的条件和我的有一点不同，可能因为我的是基于python的功能</li>
<li>其中，换到正确位置的数字就是在1到len(nums)之间的数字。nums[i]-1是这个数字应该的坐标位置，如果应该的位置和现在的位置的数字不一样，那就交换这两个数字<ul>
<li>注意这里需要用while换，要一直换到正确的位置才可以</li>
</ul>
</li>
<li>这样的结果就是大家都按正确的填好了，最后不对的那个位置的index+1就是需要的结果</li>
</ul>
<h2 id="299"><a href="#299" class="headerlink" title="#299"></a>#299</h2><p>You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. </p>
<p>Please note that both secret number and friend’s guess may contain duplicate digits.</p>
<p>Example 1:</p>
<p>Input: secret = “1807”, guess = “7810”</p>
<p>Output: “1A3B”</p>
<p>Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.<br>Example 2:</p>
<p>Input: secret = “1123”, guess = “0111”</p>
<p>Output: “1A1B”</p>
<p>Explanation: The 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow.<br>Note: You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.</p>
<hr>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHint</span><span class="params">(self, secret: str, guess: str)</span> -&gt; str:</span></span><br><span class="line">        bull = sum(a == b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(secret,guess))</span><br><span class="line">        cow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> set(guess):</span><br><span class="line">            cow  += min(secret.count(x),guess.count(x))        </span><br><span class="line">        <span class="keyword">return</span> str(bull) + <span class="string">"A"</span> + str(cow-bull) + <span class="string">"B"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里自己想了一些比较蠢的想法之后直接参考别人的了<ul>
<li>其一是比对他们两个位置和数字都相同的东西，想要转换成dict来比较，但是后来发现string就可以直接index了不用这么麻烦</li>
<li>想过能不能按位做减法，未果</li>
<li>其二是在得到了bull之后把bull的部分从原来的里面剔除出去然后再比较相似的数字</li>
</ul>
</li>
<li>遇到了主要问题是重复的数字怎么办以及如何剔除出去bull</li>
<li>主要思路是这样的：<ul>
<li>其实cow的数量就是bull-cow都是的数量减去bull的数量，也就相当于维恩图里面，只有A的量是A的量 - 同时AB的量。这里是bull就相当于AB都有，两个里面所有重复的数量就相当于A的量<ul>
<li>这样可以做减法就解决了上面的从bull得到cow的问题！！</li>
<li>所以说看问题还是要看本质</li>
</ul>
</li>
<li>面对重复的数字，居然可以直接把string转换成set<ul>
<li>这里复习一下set好吗！！！这个集合居然可以没有重复的元素，平常我忽视你了呀小可爱，转化成set就不会重复了哦，震惊！！</li>
</ul>
</li>
<li>这样问题就变成了：<ul>
<li>求bull：用<strong>zip</strong>把两个东西一一对应的打包起来（居然还有你小可爱！）直接对比</li>
<li>求both：guess里面猜的次数就是总体的次数，secret里面的次数是真实的次数，对于每个在guess里面（set）的元素都看看分别在两个里面是多少个，然后小的那个就是both的大小<ul>
<li>这里介绍<code>.count()</code>小可爱，居然还可以数数！</li>
</ul>
</li>
<li>最后both-bull就是结果了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="134-gas-station"><a href="#134-gas-station" class="headerlink" title="#134 gas station"></a>#134 gas station</h2><p>居然自己搞出来了一个看起来很蠢的<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> sum(gas) &lt; sum(cost): <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        tank = <span class="number">0</span></span><br><span class="line">        current = <span class="number">0</span></span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            tank = tank + gas[current] - cost[current]</span><br><span class="line">            <span class="keyword">if</span> tank &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> current &lt; len(gas):</span><br><span class="line">                    current = current + <span class="number">1</span></span><br><span class="line">                    counter = <span class="number">0</span></span><br><span class="line">                    tank = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line">            current = current % len(gas)</span><br><span class="line">            counter += <span class="number">1</span></span><br><span class="line">            <span class="comment"># print(current,counter)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> counter == len(gas):</span><br><span class="line">                <span class="keyword">return</span> current % len(gas)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><del>~时间超过了百分之48的人，感觉可能还可以吧</del>~时间都是骗人的又跑了一次居然超过了百分之86的！！</li>
<li>重点<ul>
<li>一直按着顺序跑，不会跳着走</li>
<li>如果gas的总量从一开始就小于cost的总量，那绝对不可能</li>
</ul>
</li>
<li>我的思路：<ul>
<li>从第一个点开始试着跑，一直到试着从最后一个点开始跑，找到了就直接返回</li>
<li>增加一个计数的var，记一共跑了多远，因为是按着顺序跑的所以这个var等于gas的长度的时候就是跑完了</li>
<li>避免out of range问题，需要求余数</li>
</ul>
</li>
<li>遇到问题：<ul>
<li>当tank小于0，更新完条件之后记得continue继续循环呀</li>
<li>刚开始想用的判断条件是for或者while里面带条件，还想了一下要不要zip这两个数据，但是都是list实在是没有必要。但是感觉是想的实在是太多了</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span> </span><br><span class="line">        <span class="keyword">if</span> sum(gas) &lt; sum(cost): <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        rest = start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            rest += gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">if</span> rest &lt; <span class="number">0</span>:</span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">                rest = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure>
<ul>
<li>居然有这么简要的写法！！</li>
<li><strong>所以只要不是sum(gas) &lt; sum(cost)就一定会有解诶，神奇。也就是说我上面有一个返回的-1是没有意义的</strong></li>
<li>而且用for的话就不用再考虑counter的问题了</li>
<li>从哪里失败就从哪里的下一个爬起来</li>
</ul>
<h2 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="#118 Pascal’s Triangle"></a>#118 Pascal’s Triangle</h2><p>Example:</p>
<p>Input: 5<br>Output:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(numRows):</span><br><span class="line">            now_row = []</span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">0</span>:</span><br><span class="line">                now_row = [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> row == <span class="number">1</span>:</span><br><span class="line">                now_row = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now_row = [<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">for</span> member <span class="keyword">in</span> range(<span class="number">1</span>,row):</span><br><span class="line">                    now_row.append(result[row<span class="number">-1</span>][member<span class="number">-1</span>] + result[row<span class="number">-1</span>][member])</span><br><span class="line">                </span><br><span class="line">                now_row.append(<span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">            result.append(now_row)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>总算是自己写出来一个东西了</li>
<li>好简单，除了前两行是特定的，其他的可以归为一类</li>
<li>求一个简单的数学关系就行了，数数别数错了！！注意数0</li>
<li><strong>唯一没有注意的点就是：事先不知道list的大小，所以初始化成空的之后需要用append添加元素</strong></li>
</ul>
<h2 id="119-杨辉三角形2"><a href="#119-杨辉三角形2" class="headerlink" title="#119 杨辉三角形2"></a>#119 杨辉三角形2</h2><p>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.</p>
<p>Input: 3<br>Output: [1,3,3,1]</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex: int)</span> -&gt; List[int]:</span></span><br><span class="line">        L = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> len(L) == rowIndex + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> L</span><br><span class="line">            L = [u+v <span class="keyword">for</span> u,v <span class="keyword">in</span> zip([<span class="number">0</span>]+L,L+[<span class="number">0</span>])]</span><br></pre></td></tr></table></figure>
<ul>
<li>没想到杨辉三角形的代码也有简要的解法，这个是用L记录了上一行的信息，然后再把这行扩充两个0，相当于这个三角形的本质是两行错位相加！！</li>
<li>注意最后的L得到的是一个list，list要有list的样子</li>
<li>更加理解了一下zip和单行for的用法</li>
<li>index从0开始，结果开始没有注意到</li>
<li>while true 加上一个 if的效果等同于for的效果！！！越写越糊涂</li>
</ul>
<h2 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="#169 Majority Element"></a>#169 Majority Element</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example 1:</p>
<p>Input: [3,2,3]<br>Output: 3<br>Example 2:</p>
<p>Input: [2,2,1,1,1,2,2]<br>Output: 2</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>思路：这回想到了很多历遍的方法，但是感觉太蠢了，终于开始想怎么才能更好的实现了</li>
<li>在写写画画的时候突然考虑到，如果有超过一半的数量都是这个数的话，把这个list排序之后最中间的那个数肯定是这个数<ul>
<li>极限情况就是两个元素差1，这时候是多一点的那个数的边界上</li>
<li>其他的情况下就是在出现最多的那个数的中间</li>
</ul>
</li>
<li>本来想要用floor的，但是发现需要math包，所以用了 // 来求除之后的整数</li>
</ul>
<h2 id="229-Majority-Element-2"><a href="#229-Majority-Element-2" class="headerlink" title="#229 Majority Element 2"></a>#229 Majority Element 2</h2><p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</p>
<p>Note: The algorithm should run in linear time and in O(1) space.</p>
<p>Example 1:</p>
<p>Input: [3,2,3]<br>Output: [3]<br>Example 2:</p>
<p>Input: [1,1,1,3,3,2,2,2]<br>Output: [1,2]<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        major1,major2,count1,count2 = <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> major1 == n:</span><br><span class="line">                count1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> major2 ==n:</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count1 ==<span class="number">0</span>:</span><br><span class="line">                major1 = n</span><br><span class="line">                count1 = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count2 == <span class="number">0</span>:</span><br><span class="line">                major2 = n</span><br><span class="line">                count2 =<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count1 -= <span class="number">1</span></span><br><span class="line">                count2 -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [n <span class="keyword">for</span> n <span class="keyword">in</span> (major1,major2) <span class="keyword">if</span> nums.count(n) &gt; len(nums) // <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意这道题说的是出现次数大于1/3的数字，所以结果只有只能是没有，1个或者两个，不存在结果是三个的情况！</li>
<li>这个想了半天不会做，查了一下用的是<a href="https://www.zhihu.com/question/49973163/answer/235921864" target="_blank" rel="noopener">Boyer-Moore Majority Vote algorithm</a><ul>
<li>这个算法的主要意思是如果两拨人打架，打架一对一抵消，然后看看剩下的部分哪个比较多<ul>
<li>记录剩下的东西的方法就是增加了一个额外的部分，包括major和count两部分，major记录的是有剩余的数是什么，count记录还有多少个</li>
<li>如果count没有了，那么就从现在遇到的新的数开始记</li>
<li>如果现在的数不是需要的，那么count - 1，如果是现在需要的那么count + 1</li>
</ul>
</li>
<li>最开始是用在一个数组里面找超过一半的数的，但是我上一道题用了其他方法所以没用到</li>
<li>注意因为是求1/3的数字，所以虽然有剩下的，但是剩下的不一定都是符合要求的，需要再数一下个数对不对（这才有了return这一行里面的东西）</li>
</ul>
</li>
<li>人类的算法真是奇幻无穷</li>
</ul>
<h2 id="274-h-index"><a href="#274-h-index" class="headerlink" title="#274 h-index"></a>#274 h-index</h2><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”</p>
<p>Example:</p>
<p>Input: citations = [3,0,6,1,5]<br>Output: 3<br>Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had<br>             received 3, 0, 6, 1, 5 citations respectively.<br>             Since the researcher has 3 papers with at least 3 citations each and the remaining<br>             two with no more than 3 citations each, her h-index is 3.<br>Note: If there are several possible values for h, the maximum one is taken as the h-index.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> h_cand <span class="keyword">in</span> range(len(citations) + <span class="number">1</span>):</span><br><span class="line">            h_more = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> citation <span class="keyword">in</span> citations:</span><br><span class="line">                <span class="keyword">if</span> citation &gt;= h_cand:</span><br><span class="line">                    h_more += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> h_more &gt;= h_cand:</span><br><span class="line">                    result = max(result,h_cand)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>思路，非常直观的方法，直接iterate所有的元素，如果找到了更大的result的值就取最大的（根据题目要求）</li>
<li>注意的点在需要 <code>h_more &gt;= h_cand</code>而不是等于，因为给出的定义的意思是index-h是有h个的值大于等于h，h_more的个数会比h_cand多（但是因为取了下面的max，所以等于其实也是可以得）</li>
<li>这个的速度真的好慢，尝试一下binary search</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        bucket = [<span class="number">0</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(len(citations)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> citations:</span><br><span class="line">            <span class="keyword">if</span> nums &gt;= len(citations):</span><br><span class="line">                bucket[len(citations)] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bucket[nums] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> range(len(bucket)):</span><br><span class="line">            nums = len(bucket) - nums <span class="number">-1</span></span><br><span class="line">            result += bucket[nums]</span><br><span class="line">            <span class="keyword">if</span> result &gt;= nums:</span><br><span class="line">                <span class="keyword">return</span> nums</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用了桶排序的神奇方法</li>
<li>还是取决于定义，如果一共有5个paper的话，可以选的h的值有6个，分别是0 1 2 3 4 5，把这留个值分成六个桶，每个里面放的就是比这桶的inde等于的paper的数量<ul>
<li>如果总数直接大于最大的桶数，就放在最后一个里面</li>
<li>这是在第一个循环干的事情</li>
</ul>
</li>
<li>第二个循环里，把这些桶里面的值取出来就是比这个桶的index大于等于的paper的数量，从后往前数，如果这个paper的数量大于了现在的index，那就说明现在的index就是h！</li>
<li>这里学到了一个创建固定长度列表的方法<code>bucket = [0 for n in range(len(citations)+1)]</code></li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        citations.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,n <span class="keyword">in</span> enumerate(citations):</span><br><span class="line">            <span class="keyword">if</span> n &gt;= i+<span class="number">1</span>:</span><br><span class="line">                result = max(result,i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>再另一种思路，用了排序<ul>
<li>如果把这个list按降序排序的话，index的数量加一就是目前数过的paper的数量，citation[index]就是这个数量上面对应的citation的数量，这两个值应该正好相等，或者citation更大一点，需要在排好序的内容里面找到这一项！</li>
</ul>
</li>
<li>这样速度比桶排序稍微慢一点但是还是蛮快的，起码比第一种要快很多了</li>
</ul>
<h2 id="275-h-index-2"><a href="#275-h-index-2" class="headerlink" title="#275 h-index 2"></a>#275 h-index 2</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(citations)</span><br><span class="line">        l, r = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> citations[mid] &gt;= n-mid:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n-l</span><br></pre></td></tr></table></figure>
<ul>
<li>可以依然沿用上面的方法，但是可能是因为数据量上去的原因，所以速度变慢了</li>
<li>这里可以加入二分法搜索取代上面的直接iterate<ul>
<li>while的条件是因为移动一位，所以会出现l&gt;r的情况，在这种情况下就可以停下来了</li>
<li>二分法就是这么写的！</li>
</ul>
</li>
</ul>
<h2 id="217-contains-duplicate"><a href="#217-contains-duplicate" class="headerlink" title="#217 contains duplicate"></a>#217 contains duplicate</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> nums.count(n) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        setNums = set(nums)</span><br><span class="line">        <span class="keyword">if</span> len(setNums) == len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>消耗时间太长了！！</li>
<li>说明这个count的时间还是不可以</li>
<li>想到了用set但是没相当怎么用set<ul>
<li>set可以把有重复内容的变成没有重复内容的！！</li>
<li>所以set和list的长度是不一样的</li>
</ul>
</li>
</ul>
<h2 id="219-contains-duplicate2"><a href="#219-contains-duplicate2" class="headerlink" title="#219 contains duplicate2"></a>#219 contains duplicate2</h2><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1], k = 3<br>Output: true<br>Example 2:</p>
<p>Input: nums = [1,0,1,1], k = 1<br>Output: true<br>Example 3:</p>
<p>Input: nums = [1,2,3,1,2,3], k = 2<br>Output: false</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(set(nums)) &gt;= len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        extra = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> extra <span class="keyword">and</span> i-extra[n] &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            extra[n] = i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意这里需要找到的差的绝对值是最大是k，所以找到一个比k小的很容易！！只要找到就能返回</li>
<li>判断边界条件</li>
<li>把元素作为key放进extra里面，val是这个元素的index，因为key是唯一的所以可以一直找到离得最近的index，这样就越来越能确保满足条件，一旦满足条件就返回，如果所有的都不满足就false</li>
</ul>
<h2 id="220"><a href="#220" class="headerlink" title="#220"></a>#220</h2><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1], k = 3, t = 0<br>Output: true<br>Example 2:</p>
<p>Input: nums = [1,0,1,1], k = 1, t = 2<br>Output: true<br>Example 3:</p>
<p>Input: nums = [1,5,9,1,5,9], k = 2, t = 3<br>Output: false</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(self, nums: List[int], k: int, t: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> t &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        buckets = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            bucket = nums[i] // (t+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> bucket - <span class="number">1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> nums[i] - buckets[bucket<span class="number">-1</span>] &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> bucket + <span class="number">1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> buckets[bucket+<span class="number">1</span>] - nums[i] &lt;=t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            buckets[bucket] = nums[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                <span class="keyword">del</span> bucket[nums[i-k] // (t+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运用的是桶排序的思路，每个nums[i]会放在一个桶里，这个桶的宽度是这两个数字的差<ul>
<li>如果想要这两个数值的差值小于等于t，那么需要这两个数字在一个桶里或者在相邻的桶里（因为后面增加了k的判断条件，所以不用考虑k）</li>
</ul>
</li>
<li><p>思路</p>
<ul>
<li>首先考虑了一下k，如果i大于k的时候，就可以直接扔掉i-k之前的数据了，只考虑中间的k+1个数据，这样的话空间复杂度很低。这里的扔掉指的是把bucket里面的值直接扔掉，这样就避免了找到在相同的桶里面却i和j的差值超过k的问题</li>
<li>首先iterate整个nums，把不同的数字放在不同的桶里，注意桶的个数是t+1</li>
<li>然后如果在放之前这个桶有东西，或者相邻的桶的值和现在的值的差是小于等于t的，那么就存在，返回true</li>
<li>如果都不存在的话，把现在的数字放到对应的桶里面</li>
</ul>
</li>
<li><p>另外一个思路考虑的是二叉树的数据结构，用这个结构可以很快的搜索到离这个数最近的数据并且判断这个数据和这个数的差是不是小于t！</p>
</li>
</ul>
<h2 id="55-Jump-game"><a href="#55-Jump-game" class="headerlink" title="#55 Jump game"></a>#55 Jump game</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> []: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        current = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> current &gt;= <span class="number">0</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,current):</span><br><span class="line">                <span class="keyword">if</span> current - i &lt;= nums[i] <span class="keyword">and</span> current &gt;= i:</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    current = i</span><br><span class="line">                    <span class="keyword">if</span> current == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>虽然超时了但是写的还不错的iterate</li>
<li>=。=算了这就是一坨屎！！！</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        current = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> current - i &lt;= nums[i]:</span><br><span class="line">                current = i</span><br><span class="line">                <span class="keyword">if</span> current == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我的方法其实思路是没有问题的，主要在于太啰嗦了而且循环太多了，其实直接从后往前找就行了！！！从后往前找不用考虑怎么让他循环起来呀，直接一个一个往前推就可以了</li>
<li>前面那个的问题在于多叠了一个while，于是时间瞬间爆炸，写前面的那个的时候也在想着如何找回循环里面去，结果还是用了个蠢办法</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> j &lt; i: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            j = max(i+n,j) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>i+n就是从这步开始可以移动的最大距离，j是上一步可以移动的最大距离，这两个哪个大就走哪个</li>
<li>如果这个距离还赶不上i，那就说明走不到最后了，告辞</li>
</ul>
<h2 id="45-Jump-game-2"><a href="#45-Jump-game-2" class="headerlink" title="#45 Jump game 2"></a>#45 Jump game 2</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        step,maxend = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i+nums[i] &gt;= len(nums) <span class="number">-1</span>: <span class="keyword">return</span> step</span><br><span class="line">                maxend = max(maxend, i + nums[i])</span><br><span class="line">            start = end + <span class="number">1</span></span><br><span class="line">            end = maxend</span><br></pre></td></tr></table></figure>
<ul>
<li>实际上来说用的是BFS的思想，但是不是每次都把东西从queue里面拿出来，而是确定了每次寻找的开始的阀内</li>
<li>start和end分别代表现在可以开始寻找的开始和结束，如果在这个范围里面找到了符合要求的结果，那么直接返回这个步数，如果没找到的话就从下一个范围开始找，下一个范围是上一个范围的end+1 到目前能到的最大的范围</li>
<li>注意符合的要求是大于等于n-1而不是正好走到这个点</li>
<li>求maxend和之前的一样</li>
</ul>
<h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="#121 Best Time to Buy and Sell Stock"></a>#121 Best Time to Buy and Sell Stock</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:</p>
<p>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br>             Not 7-1 = 6, as selling price needs to be larger than buying price.<br>Example 2:</p>
<p>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        minBuy = float(<span class="string">'inf'</span>)</span><br><span class="line">        maxProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">if</span> i &lt; minBuy:</span><br><span class="line">                minBuy = i</span><br><span class="line">            <span class="keyword">elif</span> i - minBuy &gt; maxProfit:</span><br><span class="line">                maxProfit = i - minBuy</span><br><span class="line">        <span class="keyword">return</span> maxProfit</span><br></pre></td></tr></table></figure>
<ul>
<li>用brute的算法会time limit，这里用的方法是用两个变量分别记录最低的价钱和最高的利润，这样的话只需要对数组遍历一次就能得到最终的结果</li>
<li>因为判断这个价钱低了的话，求这个东西的最大利润也就只能用这个最低价钱之后的东西求了，所以不会冲突</li>
</ul>
<h2 id="122"><a href="#122" class="headerlink" title="#122"></a>#122</h2><ul>
<li>现在可以进行多次交易了，但是每次之间不能重叠</li>
<li>其实只要后一次比前一次贵，这个profit就可以一直累计，分为一直上涨或者中间掉下来一下再重新买的感觉</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        maxProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                maxProfit += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> maxProfit</span><br></pre></td></tr></table></figure>
<h2 id="123"><a href="#123" class="headerlink" title="#123"></a>#123</h2><ul>
<li>现在最多进行两次交易,找到最大的利润</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        cost_1 = float(<span class="string">'inf'</span>)</span><br><span class="line">        profit_1 = <span class="number">0</span></span><br><span class="line">        cost_2 = float(<span class="string">'inf'</span>)</span><br><span class="line">        profit_2 = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            cost_1 = min(cost_1,price)</span><br><span class="line">            profit_1 = max(profit_1, price - cost_1)</span><br><span class="line">            cost_2 = min(cost_2,price - profit_1)</span><br><span class="line">            profit_2 = max(profit_2, price - cost_2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> profit_2</span><br></pre></td></tr></table></figure>
<ul>
<li>其中，下标带1的是第一次交易之后的结果，下标带2的是第二次交易之后的结果</li>
<li>从总体上来看，第二次买入之后花掉的钱实际上是<code>第二次买入的实际花费 - 第一次交易之后挣的钱</code>（可以是负数）。而第二次卖出之后的总的收益为 <code>第二次卖出的钱 - 第二次买入之后的实际花费</code></li>
<li>所以，如果需要利润最大，需要第二次买入的实际花费最小，需要第一次的利润最大，需要第一次买入的花费最小，最终形成了这个代码</li>
</ul>
<h2 id="188"><a href="#188" class="headerlink" title="#188"></a>#188</h2><ul>
<li>现在需要进行最多k次交易，把profit弄到最大</li>
<li>这部分好像大家都用到了DP</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= n/<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(i-j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(prices[<span class="number">1</span>:],prices[: <span class="number">-1</span>]) <span class="keyword">if</span> i &gt; j)</span><br><span class="line">        profits = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            preprofit = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                profit = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">                preprofit = max(preprofit + profit, profits[i])</span><br><span class="line">                profits[i] = max(preprofit, profits[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> profits[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>首先考虑边界条件，如果k的数量已经比n/2大了，那么可以直接认为可以进行无限次交易了，就和上面的第二题一样</li>
<li>主要思路就是现在定义了两个变量，一个变量表示在前i天完成的交易，已经得到的最大利润。另一个变量定义了在第i天卖出的话，这时候得到的最大利润。这两个变量的都是在在第j次交易里。</li>
<li>用一个长n的list profits来记录这个天数之后获得的利益。在k次交易中一直更新这个profits里面的最大值。所以实际上关于k的变量不需要考虑</li>
<li>首先分析在第i天得到的利润，就是这一天的价格减去前一天的价格。更新之前i天里面的总利润，就是把最开始的preprfit再加上这一天获得的利润，和本来的preprofit来比大小，更新preprofit</li>
<li>更新实际上第i天的利润，对比实际上前一天的利润和前i天的利润哪个大</li>
</ul>
<h2 id="309-中间带冷却的买股票"><a href="#309-中间带冷却的买股票" class="headerlink" title="#309 中间带冷却的买股票"></a>#309 中间带冷却的买股票</h2><ul>
<li>每次卖出去之后必须要cooldown一轮</li>
<li>用了dp和state machine来表示，一共会有三种状态<ul>
<li>s0(reset) -sell-&gt; s1 -cool-&gt; s2(reset) -buy-&gt; s0</li>
<li>用一个数组来记录在每天在这个状态里面的最大利润，然后再从最后一天的最大利润里面挑出来一个</li>
</ul>
</li>
<li>注意考虑边界条件</li>
<li>学会了一个新的初始化list的方法</li>
<li>感觉自己终于理解了dp呢（并没有）<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s0,s1,s2 = [<span class="number">0</span>]*n,[<span class="number">0</span>]*n,[<span class="number">0</span>]*n</span><br><span class="line">        s0[<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        s1[<span class="number">0</span>] = float(<span class="string">'-inf'</span>)</span><br><span class="line">        s2[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            price = prices[i]</span><br><span class="line">            s0[i] = max(s0[i<span class="number">-1</span>],s2[i<span class="number">-1</span>] - price)</span><br><span class="line">            s1[i] = s0[i<span class="number">-1</span>] + price</span><br><span class="line">            s2[i] = max(s1[i<span class="number">-1</span>],s2[i<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(s0[n<span class="number">-1</span>],s1[n<span class="number">-1</span>],s2[n<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-装水"><a href="#11-装水" class="headerlink" title="#11 装水"></a>#11 装水</h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(height)</span><br><span class="line">        start, end  = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            <span class="keyword">if</span> height[start] &gt;= height[end]:</span><br><span class="line">                maxArea = max(maxArea,height[end] * (end-start))</span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxArea = max(maxArea,height[start] * (end-start))</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br></pre></td></tr></table></figure>
<ul>
<li>这道题的重点在这个装水的大小是由比较短的那条边决定的。而且肯定是底边越长越牛逼，所以从底边最长的两边开始找，然后在两个高度里面取比较大的继续找下一个</li>
<li>需要用一个变量来储存 max area的大小（这个我想到了）</li>
<li>然后比较快的方法是从两遍开始逼近，这样的话只遍历了这个list一次，时间复杂度是n，好像有个排序算法和这个的想法也差不多</li>
<li>注意while的判断条件其实就是这个</li>
</ul>
<h2 id="42-装水"><a href="#42-装水" class="headerlink" title="#42 装水"></a>#42 装水</h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="/2019/05/07/Leetcode笔记/42.jpg" alt></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(height)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_max,right_max = [<span class="number">0</span>]*n,[<span class="number">0</span>]*n</span><br><span class="line">        left_max[<span class="number">0</span>],right_max[<span class="number">-1</span>] = height[<span class="number">0</span>],height[<span class="number">-1</span>]</span><br><span class="line">        maxTrap = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            left_max[i] = max(left_max[i<span class="number">-1</span>],height[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">0</span>,n<span class="number">-1</span>)):</span><br><span class="line">            right_max[i] = max(right_max[i+<span class="number">1</span>],height[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            maxTrap += min(left_max[i],right_max[i]) - height[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxTrap</span><br></pre></td></tr></table></figure>
<ul>
<li>用dp解决的这个问题</li>
<li>核心思想在竖着（按列）数每个格子，这个格子可不可以装水和左右两边的最高点有关，这个格子能装多少水和1.最短的高点和2.这个格子本身的高度有关</li>
<li>所以可以用三个循环搞定这个问题，用空间换时间，在list里面记录下来每个列对应的左边的最高点和右边的最高点，然后再数每个列的容量，大小是（左右最高中间短的那个） - （这个列对应的高度）</li>
</ul>
<h2 id="334-升序的三个数字"><a href="#334-升序的三个数字" class="headerlink" title="#334 升序的三个数字"></a>#334 升序的三个数字</h2><p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Formally the function should:</p>
<p>Return true if there exists i, j, k<br>such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.<br>Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingTriplet</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        first = float(<span class="string">'inf'</span>)</span><br><span class="line">        second = float(<span class="string">'inf'</span>)</span><br><span class="line">        third = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= first:</span><br><span class="line">                first = num</span><br><span class="line">            <span class="keyword">elif</span> num &gt; first <span class="keyword">and</span> num &lt;= second:</span><br><span class="line">                second = num</span><br><span class="line">            <span class="keyword">else</span>: third = num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (third != <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>我最初的思路没有错，需要有变量来保存这三个升序的东西</li>
<li>其实核心的思路在于，如果现在这个数比第一个升序的数字小，那么这个数字完全就可以成为新的第一个数字，比如 3 2 4 5，那么345和245没有什么本质的区别，而一旦third有了取值，那么就说明肯定已经有了一个结果</li>
</ul>
<h2 id="128"><a href="#128" class="headerlink" title="#128"></a>#128</h2><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<p>Example:</p>
<p>Input: [100, 4, 200, 1, 3, 2]<br>Output: 4<br>Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"><span class="comment">#         if nums == []: return 0</span></span><br><span class="line"><span class="comment">#         max_num = max(nums)</span></span><br><span class="line"><span class="comment">#         min_num = min(nums)</span></span><br><span class="line"><span class="comment">#         if max_num &gt; len(nums) or -max</span></span><br><span class="line"><span class="comment">#         if min_num &lt; 0:</span></span><br><span class="line"><span class="comment">#             max_num -= min_num</span></span><br><span class="line"><span class="comment">#         ass_list = [None] * (max_num + 1)</span></span><br><span class="line"><span class="comment">#         for i,num in enumerate(nums):</span></span><br><span class="line"><span class="comment"># #             确保都是正数</span></span><br><span class="line"><span class="comment">#             if min_num &lt; 0:</span></span><br><span class="line"><span class="comment">#                 num = num-min_num</span></span><br><span class="line"><span class="comment">#             ass_list[num] = 1</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#         max_length = 0</span></span><br><span class="line"><span class="comment">#         prev_length = 0</span></span><br><span class="line"><span class="comment">#         for i in range(len(ass_list)):</span></span><br><span class="line"><span class="comment">#             if ass_list[i] != None:</span></span><br><span class="line"><span class="comment">#                 max_length += 1</span></span><br><span class="line"><span class="comment">#             else:</span></span><br><span class="line"><span class="comment">#                 prev_length = max(max_length,prev_length)</span></span><br><span class="line"><span class="comment">#                 max_length = 0</span></span><br><span class="line"><span class="comment">#         return max(max_length,prev_length)</span></span><br><span class="line">        <span class="keyword">if</span> nums == []: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        current_length,prev_length = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        num_set = set(nums)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> num_set:</span><br><span class="line">            <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                current_num = num</span><br><span class="line">                <span class="keyword">while</span> current_num+<span class="number">1</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                    current_num += <span class="number">1</span></span><br><span class="line">                    current_length += <span class="number">1</span></span><br><span class="line">                prev_length = max(prev_length,current_length)</span><br><span class="line">                current_length = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(current_length, prev_length)</span><br></pre></td></tr></table></figure>
<ul>
<li>这个问题一开始的思路是错的，已经comment掉了，但是感觉这个想法其实就是更具体化的hash表而已，第一个思路是把所有的数字平均的放在一个list里面，然后每个数字的本身就对应的是他的index，这样的话就可以直接知道有哪些数字是连续的了。但是这种方法在数字特别大的时候空间上就爆炸了，空间复杂度也是和数字大小有关</li>
<li>这时候又要拿出来快乐的hash表了，记住python自己自带hash表</li>
<li>每遇到一个数字，需要判断这个数字的下一个数字在不在这个nums里面，如果在的话更新数字和长度，如果不再的话刷新计数器并且开始下一个数字</li>
<li>但是直接这样算还是会时间爆炸（比如一堆连续的只有一个是跳开的），所以又加进去了一个新的判断条件，这个条件的精髓在于，如果这个数之前的数字在nums里面，那么这个数在算他前面那个数的时候就应该被算上了，所以这部分就可以跳过这个数了，只有当前一个数字不在的时候才需要数长度</li>
</ul>
<h2 id="164"><a href="#164" class="headerlink" title="#164"></a>#164</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>Example 1:</p>
<p>Input: [3,6,9,1]<br>Output: 3<br>Explanation: The sorted form of the array is [1,3,6,9], either<br>             (3,6) or (6,9) has the maximum difference 3.<br>Example 2:</p>
<p>Input: [10]<br>Output: 0<br>Explanation: The array contains less than 2 elements, therefore return 0.<br>Note:</p>
<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.<br>Try to solve it in linear time/space.</p>
<p><img src="/2019/05/07/Leetcode笔记/164.jpg" alt></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        max_gap = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            gap = nums[i] - nums[i<span class="number">-1</span>]</span><br><span class="line">            max_gap = max(max_gap, gap)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_gap</span><br></pre></td></tr></table></figure>
<ul>
<li>直接用python自带的排序速度不一定很慢，虽然只超过了百分了20的人但是最后还是跑出来了</li>
<li>这个方法非常直接了</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_num, min_num = max(nums), min(nums)</span><br><span class="line">        <span class="keyword">if</span> max_num == min_num: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        wide = max((max_num - min_num) // (n<span class="number">-1</span>),<span class="number">1</span>)</span><br><span class="line">        num_b = (max_num - min_num) // wide + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        maxGap = <span class="number">0</span></span><br><span class="line">        <span class="comment"># prev_bucket = float('-inf')</span></span><br><span class="line">        max_b = [<span class="number">0</span>]* num_b</span><br><span class="line">        min_b = [float(<span class="string">'inf'</span>)]* num_b</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            idx = (num-min_num) // wide</span><br><span class="line">            max_b[idx] = max(max_b[idx],num)</span><br><span class="line">            min_b[idx] = min(min_b[idx],num)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        prev_max = max_b[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,num_b):</span><br><span class="line">            <span class="keyword">if</span> max_b[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            maxGap = max(maxGap,min_b[i] - prev_max)</span><br><span class="line">            prev_max = max_b[i]</span><br><span class="line">        <span class="keyword">return</span> maxGap</span><br></pre></td></tr></table></figure>
<ul>
<li>这个桶排序终于写出来了，基本思路是上面的截图，需要注意的有几点<ul>
<li>第一，python不导入math的话没办法求ceiling，但是可以用 -（-a // b）来求</li>
<li>第二，在求bucket的个数的时候，需要多加上一个bucket，因为一个bucket里面最后的数字是放在下一个bucket里面最前面的</li>
<li>第三，可能会有空的bucket，所以不能直接用这个的min减去上一个的max，必须要留一个变量保存上一个的max</li>
<li>第四，当所有数字都相同的时候会变得很麻烦，最后加上去一个条件过滤掉这个部分</li>
</ul>
</li>
</ul>
<h2 id="28-implement-strStr（）"><a href="#28-implement-strStr（）" class="headerlink" title="#28 implement strStr（）"></a>#28 implement strStr（）</h2><p>Implement strStr().</p>
<p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<p>Example 1:</p>
<p>Input: haystack = “hello”, needle = “ll”<br>Output: 2<br>Example 2:</p>
<p>Input: haystack = “aaaaa”, needle = “bba”<br>Output: -1</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> needle == <span class="string">""</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(haystack):</span><br><span class="line">            <span class="keyword">if</span> ch == needle[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> needle == haystack[i:i+len(needle)]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>刚开始特别快乐的暴力破解了，真是万万没想到</li>
<li>感觉python处理起来字符串是真的开心</li>
<li>但是这个的时间不是很快乐</li>
</ul>
<ul>
<li>关于字符串匹配有另外两个算法KMP和BM（BM更快一点）</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/07/CS231nassignment2Pytorch/" rel="next" title="CS231Nassignment2之Pytorch">
                <i class="fa fa-chevron-left"></i> CS231Nassignment2之Pytorch
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/08/OpenCV19/" rel="prev" title="学习OpenCV第19章，投影和3D视觉">
                学习OpenCV第19章，投影和3D视觉 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpeg" alt="RUOPENG XU">
            
              <p class="site-author-name" itemprop="name">RUOPENG XU</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">46</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">48</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/Bigphess" title="GitHub &rarr; https://github.com/Bigphess" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:xrp0308@gmail.com" title="E-Mail &rarr; mailto:xrp0308@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-twoSum"><span class="nav-number">1.</span> <span class="nav-text">#1 twoSum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-remove-element"><span class="nav-number">2.</span> <span class="nav-text">#27 remove element</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#80"><span class="nav-number">3.</span> <span class="nav-text">#80</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#189-Rotate-array"><span class="nav-number">4.</span> <span class="nav-text">#189 Rotate array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路"><span class="nav-number">4.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#另一种方法：in-place"><span class="nav-number">4.2.</span> <span class="nav-text">另一种方法：in-place</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-First-Missing-Positive"><span class="nav-number">5.</span> <span class="nav-text">#41 First Missing Positive</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一个思路：时间nlog-n"><span class="nav-number">5.1.</span> <span class="nav-text">第一个思路：时间nlog(n)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#299"><span class="nav-number">6.</span> <span class="nav-text">#299</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#134-gas-station"><span class="nav-number">7.</span> <span class="nav-text">#134 gas station</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#118-Pascal’s-Triangle"><span class="nav-number">8.</span> <span class="nav-text">#118 Pascal’s Triangle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#119-杨辉三角形2"><span class="nav-number">9.</span> <span class="nav-text">#119 杨辉三角形2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#169-Majority-Element"><span class="nav-number">10.</span> <span class="nav-text">#169 Majority Element</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#229-Majority-Element-2"><span class="nav-number">11.</span> <span class="nav-text">#229 Majority Element 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#274-h-index"><span class="nav-number">12.</span> <span class="nav-text">#274 h-index</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#275-h-index-2"><span class="nav-number">13.</span> <span class="nav-text">#275 h-index 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#217-contains-duplicate"><span class="nav-number">14.</span> <span class="nav-text">#217 contains duplicate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#219-contains-duplicate2"><span class="nav-number">15.</span> <span class="nav-text">#219 contains duplicate2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#220"><span class="nav-number">16.</span> <span class="nav-text">#220</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-Jump-game"><span class="nav-number">17.</span> <span class="nav-text">#55 Jump game</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-Jump-game-2"><span class="nav-number">18.</span> <span class="nav-text">#45 Jump game 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-number">19.</span> <span class="nav-text">#121 Best Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122"><span class="nav-number">20.</span> <span class="nav-text">#122</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#123"><span class="nav-number">21.</span> <span class="nav-text">#123</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#188"><span class="nav-number">22.</span> <span class="nav-text">#188</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#309-中间带冷却的买股票"><span class="nav-number">23.</span> <span class="nav-text">#309 中间带冷却的买股票</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-装水"><span class="nav-number">24.</span> <span class="nav-text">#11 装水</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-装水"><span class="nav-number">25.</span> <span class="nav-text">#42 装水</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#334-升序的三个数字"><span class="nav-number">26.</span> <span class="nav-text">#334 升序的三个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#128"><span class="nav-number">27.</span> <span class="nav-text">#128</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#164"><span class="nav-number">28.</span> <span class="nav-text">#164</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-implement-strStr（）"><span class="nav-number">29.</span> <span class="nav-text">#28 implement strStr（）</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  
    <div id="sidebar-dimmer"></div>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RUOPENG XU</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
