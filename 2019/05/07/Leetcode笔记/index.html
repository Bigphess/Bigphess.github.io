<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.1',
    sidebar: {"position":"right","display":"always","offset":12,"onmobile":true,"dimmer":true},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="进度： array部分差不多 string部分提高往后没有继续 math部分浅尝辄止 开始搞树的部分  1 twoSumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input wou">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode笔记">
<meta property="og:url" content="https://bigphess.github.io/2019/05/07/Leetcode笔记/index.html">
<meta property="og:site_name" content="今天开始努力学习">
<meta property="og:description" content="进度： array部分差不多 string部分提高往后没有继续 math部分浅尝辄止 开始搞树的部分  1 twoSumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input wou">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://bigphess.github.io/2019/05/07/Leetcode笔记/42.jpg">
<meta property="og:image" content="https://bigphess.github.io/2019/05/07/Leetcode笔记/164.jpg">
<meta property="og:updated_time" content="2019-10-07T07:53:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode笔记">
<meta name="twitter:description" content="进度： array部分差不多 string部分提高往后没有继续 math部分浅尝辄止 开始搞树的部分  1 twoSumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input wou">
<meta name="twitter:image" content="https://bigphess.github.io/2019/05/07/Leetcode笔记/42.jpg">






  <link rel="canonical" href="https://bigphess.github.io/2019/05/07/Leetcode笔记/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Leetcode笔记 | 今天开始努力学习</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">今天开始努力学习</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">面向谷歌编程选手许若芃</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories<span class="badge">44</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives<span class="badge">64</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/Bigphess" class="github-corner" title="垃圾代码都在我的github！" aria-label="垃圾代码都在我的github！" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigphess.github.io/2019/05/07/Leetcode笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RUOPENG XU">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="今天开始努力学习">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode笔记

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 21:57:42" itemprop="dateCreated datePublished" datetime="2019-05-07T21:57:42+09:00">2019-05-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-10-07 16:53:07" itemprop="dateModified" datetime="2019-10-07T16:53:07+09:00">2019-10-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="进度："><a href="#进度：" class="headerlink" title="进度："></a>进度：</h1><ul>
<li>array部分差不多</li>
<li>string部分提高往后没有继续</li>
<li>math部分浅尝辄止</li>
<li>开始搞树的部分</li>
</ul>
<h1 id="1-twoSum"><a href="#1-twoSum" class="headerlink" title="1 twoSum"></a>1 twoSum</h1><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:</p>
<p>Given nums = [2, 7, 11, 15], target = 9,</p>
<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - item <span class="keyword">in</span> nums <span class="keyword">and</span> nums.index(target - item) != i:</span><br><span class="line">                <span class="keyword">return</span> [i, nums.index(target - item)]</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>刚开始用了直接for所有的元素的方法，忘记考虑当两个数字重复的时候需要怎么办，考虑了之后在非常大的数的情况下爆炸了</li>
<li>标准答案说到了hash表，但是其实在python实现里面本身就是个hash（不然怎么从索引得到结果），不需要考虑这个问题</li>
<li>然后考虑了把所有东西都放一个dict里面（毕竟hash？），但是遇到的问题是从value直接得到key会生一些问题。如果把数字作为key，索引作为value会发现数字有重复的，会覆盖key的值</li>
<li>这时候突然发现，如果用数字作为索引的话其实dict和list没有本质区别，在list里面操作就行了，而且list的<code>.index()</code>可以直接返回这个值得坐标（找到的是第一个值！！）</li>
<li>所以直接用enumerate把所有的index和item都列出来就可以解决了，神奇。</li>
</ul>
<h1 id="27-remove-element"><a href="#27-remove-element" class="headerlink" title="27 remove element"></a>27 remove element</h1><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>Example 1:</p>
<p>Given nums = [3, 2, 2, 3], val = 3,</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p>It doesn’t matter what you leave beyond the returned length.<br>Example 2:</p>
<p>Given nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2,</p>
<p>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</p>
<p>Note that the order of those five elements can be arbitrary.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        remove_nums = <span class="number">0</span></span><br><span class="line">        ori_length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                remove_nums += <span class="number">1</span></span><br><span class="line">                nums[i] = float(<span class="string">'inf'</span>)</span><br><span class="line">        nums.sort()</span><br><span class="line">        nums = nums[:ori_length - remove_nums]</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>这道题的重点是需要in - place的处理，空间复杂度要求很高（然而我的空间结果很垃圾）。一个重点就是返回的list不需要按照原来的顺序排列</li>
<li>从不需要原来的顺序得到的思路是：我把需要删除的东西的位置改成了inf，然后对所有部分进行排序，得到排序之后的结果再进行切片（这里刚开始的思路是删掉这个地方的东西然后再insert，后来发现直接替换就好了）</li>
<li>其实也可以直接用交换位置的方法，不用切片，因为题目只需要前面的这些元素符合要求就可以了，没有说后面的怎么样。</li>
<li>看了一些discussion都是memory只比5 % 的人少。。。但是差距都不大应该没问题！</li>
</ul>
<p>看到了一个超级牛逼简要写法：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> val <span class="keyword">in</span> nums:</span><br><span class="line">    nums.remove(val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure></p>
<h1 id="80"><a href="#80" class="headerlink" title="80"></a>80</h1><p>Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>Example 1:</p>
<p>Given nums = [1, 1, 1, 2, 2, 3],</p>
<p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</p>
<p>It doesn’t matter what you leave beyond the returned length.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= len(nums) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> len(nums) &gt; <span class="number">2</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">2</span>]:</span><br><span class="line">                    nums = nums[:nums.index(nums[i]) + <span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                next_num = nums[i + <span class="number">1</span>]</span><br><span class="line">                start_index = nums.index(nums[i])</span><br><span class="line">                next_index = nums.index(next_num)</span><br><span class="line">                <span class="keyword">if</span> next_index - start_index &gt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">for</span> l <span class="keyword">in</span> range(start_index + <span class="number">2</span>, next_index):</span><br><span class="line">                        nums[l] = float(<span class="string">'inf'</span>)</span><br><span class="line">                i = next_index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> float(<span class="string">'inf'</span>) <span class="keyword">in</span> nums:</span><br><span class="line">            nums.remove(float(<span class="string">'inf'</span>))</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>我深信我的方法虽然蠢但是没有问题，但是跑出来就是有问题，分明我return之前的数据还都是对的，但是return之后显示的东西就都有问题了</li>
<li>主要思路是这样的<ul>
<li>因为in - place操作，所以就不能直接用remove去掉元素导致下标错乱</li>
<li>本来是想和上面的思路一样，换成inf，然后再把有inf的部分删除掉（参考了  # 27的简易解法）</li>
<li>怎么换成inf呢，我判断的方法是找到下一个值得index，然后计算这个index和上一个之间差多少个数，然后把富裕的数字都替换成inf</li>
</ul>
</li>
<li>忽略的问题：<ul>
<li>数数数错了很多问题</li>
<li>最开始没有考虑到什么停止</li>
<li>然后没有考虑到如果最后一个数字重复了两遍以上要怎么办的问题（这也是我用next_index的一个弊端）</li>
</ul>
</li>
</ul>
<p><strong>然后看着大佬的代码哭出了声！！！</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">2</span> <span class="keyword">or</span> n != nums[i - <span class="number">2</span>]:</span><br><span class="line">                nums[i] = n</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></p>
<p>总结：</p>
<ul>
<li>哇这个思路真的牛逼！</li>
<li>中心思想就是让n来增加但是i不增加，这里已经说了不在意前面项之后list里面的内容，也就是说前n项之后的东西都不用管了。既然如此的话与其用inf来替换这个位置的数字，不如直接用后面的项填在相对应的位置上，只有填成功了才会增加i</li>
<li>这里需要<strong>先判断i的值是否小于2，然后再计算nums[i - 2]，否则会out of range</strong></li>
<li>i跑的速度没有超过n跑的速度所以没有关系</li>
<li>合理利用题里面的条件限制真的很重要！！</li>
</ul>
<h1 id="189-Rotate-array"><a href="#189-Rotate-array" class="headerlink" title="189 Rotate array"></a>189 Rotate array</h1><p>Given an array, rotate the array to the right by k steps, where k is non - negative.</p>
<p>Example 1:</p>
<p>Input: [1, 2, 3, 4, 5, 6, 7] and k = 3<br>Output: [5, 6, 7, 1, 2, 3, 4]<br>Explanation:<br>rotate 1 steps to the right: [7, 1, 2, 3, 4, 5, 6]<br>rotate 2 steps to the right: [6, 7, 1, 2, 3, 4, 5]<br>rotate 3 steps to the right: [5, 6, 7, 1, 2, 3, 4]</p>
<p>Example 2:</p>
<p>Input: [-1, -100, 3, 99] and k = 2<br>Output: [3, 99, -1, -100]<br>Explanation:<br>rotate 1 steps to the right: [99, -1, -100, 3]<br>rotate 2 steps to the right: [3, 99, -1, -100]</p>
<p>Note:</p>
<p>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br>Could you do it in-place with O(1) extra space?</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>需不需要注意k = 0的时候</li>
<li>如果k的个数特别大需不需要简化一下</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        steps = k % len(nums)</span><br><span class="line">        unchange_nums = nums[:len(nums) - steps]</span><br><span class="line">        change_nums = nums[len(nums) - steps:]</span><br><span class="line">        nums[:steps] = change_nums</span><br><span class="line">        nums[steps:] = unchange_nums</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>居然第一种就这么写出来了，实际上就是把后面的数字移动到前面去</li>
<li>注意nums不能直接用change_nums + unchange_nums，大概是他认为这个不是in - place了吧</li>
</ul>
<h1 id="另一种方法：in-place"><a href="#另一种方法：in-place" class="headerlink" title="另一种方法：in-place"></a>另一种方法：in-place</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    k = k % len(nums)</span><br><span class="line">    self.reverse_nums(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">    self.reverse_nums(nums, <span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">    self.reverse_nums(nums, k, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_nums</span><span class="params">(self,nums,start,end)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        temp = nums[start]</span><br><span class="line">        nums[start] = nums[end]</span><br><span class="line">        nums[end] = temp</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">        end -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实际上，rotate的另外一种方法是先把整个list反向，然后把前面的k个反向，然后再把后面的(n-k)个反向（这里我是没想到的）</li>
<li>把一个数组反向的算法就是从两头向中间逼近着交换（我该好好去看看基础的算法了。。）</li>
<li>最后，还有一种方法是跳着设置值，也就是说k个之后的值就应该是现在这个位置的值</li>
</ul>
<h1 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41 First Missing Positive"></a>41 First Missing Positive</h1><p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p>Example 1:</p>
<p>Input: [1,2,0]<br>Output: 3<br>Example 2:</p>
<p>Input: [3,4,-1,1]<br>Output: 2<br>Example 3:</p>
<p>Input: [7,8,9,11,12]<br>Output: 1<br>Note:</p>
<p>Your algorithm should run in O(n) time and uses constant extra space.</p>
<h1 id="第一个思路：时间nlog-n"><a href="#第一个思路：时间nlog-n" class="headerlink" title="第一个思路：时间nlog(n)"></a>第一个思路：时间nlog(n)</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        target = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n == target:</span><br><span class="line">                target += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure>
<ul>
<li>这个思路整体建立在先排序的基础上，但是排序的时间复杂度本身就已经是nlog(n)了</li>
<li>排序 - 找到比0大的数字从这里开始 - 这个数字不符合的话找下一个<ul>
<li>但是我在找比0大的数字的时候还想着把list切片，切片就又需要考虑0啊，1啊，缺多少个数字的问题，空的list。其实根本不用这么麻烦</li>
<li>本质上这个方法就是，找到miss的正数，那就从正数的第一个（1）开始找，如果找到了这个数就继续找下一个（target++），总是能找到的嘛，找到的就是缺的数字了</li>
</ul>
</li>
</ul>
<hr>
<p><strong>自己的方法</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            target_num = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == target_num:</span><br><span class="line">                <span class="keyword">if</span> i == len(nums) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> target_num + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> target_num <span class="keyword">in</span> nums:</span><br><span class="line">                temp = nums.index(target_num)</span><br><span class="line">                nums[temp],nums[i] = nums[i], nums[temp]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> target_num</span><br></pre></td></tr></table></figure></p>
<ul>
<li>桶排序：要把对应的数字放在对应的位置上<ul>
<li>这道题里应该的样子就是nums[index] = index + 1</li>
</ul>
</li>
<li>大佬的思路 -&gt; 首先判断边界条件！！(学到了学到了)</li>
<li>看过了上面的提示写出来的第二版<ul>
<li>判断边界条件</li>
<li>判断这个数字是不是摆在了正确的位置<ul>
<li>正确，判断是否是最后一个数字<ul>
<li>是，输出的是最后一个数字+1</li>
<li>不是，这个位置的正确了，判断下一个位置</li>
</ul>
</li>
<li>没有，判断nums里面还有没有应该摆在这个位置的数字<ul>
<li>有，那就和这个位置交换</li>
<li>没有，那没有的数字就是缺少的数字了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>因为每次都是把数字换到了正确的位置了，所以交换最多进行len(nums)次，时间复杂度是O(n)</li>
</ul>
<hr>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt;= nums[i]<span class="number">-1</span> &lt; len(nums) <span class="keyword">and</span> nums[nums[i]<span class="number">-1</span>] != nums[i]:</span><br><span class="line">            tmp = nums[i]<span class="number">-1</span></span><br><span class="line">            nums[i], nums[tmp] = nums[tmp], nums[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> len(nums)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>大佬的另一个方法，其实思路和上面的差不多，就是把数字换到正确的位置上，但是判断的条件和我的有一点不同，可能因为我的是基于python的功能</li>
<li>其中，换到正确位置的数字就是在1到len(nums)之间的数字。nums[i]-1是这个数字应该的坐标位置，如果应该的位置和现在的位置的数字不一样，那就交换这两个数字<ul>
<li>注意这里需要用while换，要一直换到正确的位置才可以</li>
</ul>
</li>
<li>这样的结果就是大家都按正确的填好了，最后不对的那个位置的index+1就是需要的结果</li>
</ul>
<h1 id="299"><a href="#299" class="headerlink" title="299"></a>299</h1><p>You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. </p>
<p>Please note that both secret number and friend’s guess may contain duplicate digits.</p>
<p>Example 1:</p>
<p>Input: secret = “1807”, guess = “7810”</p>
<p>Output: “1A3B”</p>
<p>Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.<br>Example 2:</p>
<p>Input: secret = “1123”, guess = “0111”</p>
<p>Output: “1A1B”</p>
<p>Explanation: The 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow.<br>Note: You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.</p>
<hr>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHint</span><span class="params">(self, secret: str, guess: str)</span> -&gt; str:</span></span><br><span class="line">        bull = sum(a == b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(secret,guess))</span><br><span class="line">        cow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> set(guess):</span><br><span class="line">            cow  += min(secret.count(x),guess.count(x))        </span><br><span class="line">        <span class="keyword">return</span> str(bull) + <span class="string">"A"</span> + str(cow-bull) + <span class="string">"B"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里自己想了一些比较蠢的想法之后直接参考别人的了<ul>
<li>其一是比对他们两个位置和数字都相同的东西，想要转换成dict来比较，但是后来发现string就可以直接index了不用这么麻烦</li>
<li>想过能不能按位做减法，未果</li>
<li>其二是在得到了bull之后把bull的部分从原来的里面剔除出去然后再比较相似的数字</li>
</ul>
</li>
<li>遇到了主要问题是重复的数字怎么办以及如何剔除出去bull</li>
<li>主要思路是这样的：<ul>
<li>其实cow的数量就是bull-cow都是的数量减去bull的数量，也就相当于维恩图里面，只有A的量是A的量 - 同时AB的量。这里是bull就相当于AB都有，两个里面所有重复的数量就相当于A的量<ul>
<li>这样可以做减法就解决了上面的从bull得到cow的问题！！</li>
<li>所以说看问题还是要看本质</li>
</ul>
</li>
<li>面对重复的数字，居然可以直接把string转换成set<ul>
<li>这里复习一下set好吗！！！这个集合居然可以没有重复的元素，平常我忽视你了呀小可爱，转化成set就不会重复了哦，震惊！！</li>
</ul>
</li>
<li>这样问题就变成了：<ul>
<li>求bull：用<strong>zip</strong>把两个东西一一对应的打包起来（居然还有你小可爱！）直接对比</li>
<li>求both：guess里面猜的次数就是总体的次数，secret里面的次数是真实的次数，对于每个在guess里面（set）的元素都看看分别在两个里面是多少个，然后小的那个就是both的大小<ul>
<li>这里介绍<code>.count()</code>小可爱，居然还可以数数！</li>
</ul>
</li>
<li>最后both-bull就是结果了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="134-gas-station"><a href="#134-gas-station" class="headerlink" title="134 gas station"></a>134 gas station</h1><p>居然自己搞出来了一个看起来很蠢的<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> sum(gas) &lt; sum(cost): <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        tank = <span class="number">0</span></span><br><span class="line">        current = <span class="number">0</span></span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            tank = tank + gas[current] - cost[current]</span><br><span class="line">            <span class="keyword">if</span> tank &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> current &lt; len(gas):</span><br><span class="line">                    current = current + <span class="number">1</span></span><br><span class="line">                    counter = <span class="number">0</span></span><br><span class="line">                    tank = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line">            current = current % len(gas)</span><br><span class="line">            counter += <span class="number">1</span></span><br><span class="line">            <span class="comment"># print(current,counter)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> counter == len(gas):</span><br><span class="line">                <span class="keyword">return</span> current % len(gas)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><del>~时间超过了百分之48的人，感觉可能还可以吧</del>~时间都是骗人的又跑了一次居然超过了百分之86的！！</li>
<li>重点<ul>
<li>一直按着顺序跑，不会跳着走</li>
<li>如果gas的总量从一开始就小于cost的总量，那绝对不可能</li>
</ul>
</li>
<li>我的思路：<ul>
<li>从第一个点开始试着跑，一直到试着从最后一个点开始跑，找到了就直接返回</li>
<li>增加一个计数的var，记一共跑了多远，因为是按着顺序跑的所以这个var等于gas的长度的时候就是跑完了</li>
<li>避免out of range问题，需要求余数</li>
</ul>
</li>
<li>遇到问题：<ul>
<li>当tank小于0，更新完条件之后记得continue继续循环呀</li>
<li>刚开始想用的判断条件是for或者while里面带条件，还想了一下要不要zip这两个数据，但是都是list实在是没有必要。但是感觉是想的实在是太多了</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span> </span><br><span class="line">        <span class="keyword">if</span> sum(gas) &lt; sum(cost): <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        rest = start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            rest += gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">if</span> rest &lt; <span class="number">0</span>:</span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">                rest = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure>
<ul>
<li>居然有这么简要的写法！！</li>
<li><strong>所以只要不是sum(gas) &lt; sum(cost)就一定会有解诶，神奇。也就是说我上面有一个返回的-1是没有意义的</strong></li>
<li>而且用for的话就不用再考虑counter的问题了</li>
<li>从哪里失败就从哪里的下一个爬起来</li>
</ul>
<h1 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118 Pascal’s Triangle"></a>118 Pascal’s Triangle</h1><p>Example:</p>
<p>Input: 5<br>Output:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(numRows):</span><br><span class="line">            now_row = []</span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">0</span>:</span><br><span class="line">                now_row = [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> row == <span class="number">1</span>:</span><br><span class="line">                now_row = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now_row = [<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">for</span> member <span class="keyword">in</span> range(<span class="number">1</span>,row):</span><br><span class="line">                    now_row.append(result[row<span class="number">-1</span>][member<span class="number">-1</span>] + result[row<span class="number">-1</span>][member])</span><br><span class="line">                </span><br><span class="line">                now_row.append(<span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">            result.append(now_row)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>总算是自己写出来一个东西了</li>
<li>好简单，除了前两行是特定的，其他的可以归为一类</li>
<li>求一个简单的数学关系就行了，数数别数错了！！注意数0</li>
<li><strong>唯一没有注意的点就是：事先不知道list的大小，所以初始化成空的之后需要用append添加元素</strong></li>
</ul>
<h1 id="119-杨辉三角形2"><a href="#119-杨辉三角形2" class="headerlink" title="119 杨辉三角形2"></a>119 杨辉三角形2</h1><p>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.</p>
<p>Input: 3<br>Output: [1,3,3,1]</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex: int)</span> -&gt; List[int]:</span></span><br><span class="line">        L = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> len(L) == rowIndex + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> L</span><br><span class="line">            L = [u+v <span class="keyword">for</span> u,v <span class="keyword">in</span> zip([<span class="number">0</span>]+L,L+[<span class="number">0</span>])]</span><br></pre></td></tr></table></figure>
<ul>
<li>没想到杨辉三角形的代码也有简要的解法，这个是用L记录了上一行的信息，然后再把这行扩充两个0，相当于这个三角形的本质是两行错位相加！！</li>
<li>注意最后的L得到的是一个list，list要有list的样子</li>
<li>更加理解了一下zip和单行for的用法</li>
<li>index从0开始，结果开始没有注意到</li>
<li>while true 加上一个 if的效果等同于for的效果！！！越写越糊涂</li>
</ul>
<h1 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169 Majority Element"></a>169 Majority Element</h1><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example 1:</p>
<p>Input: [3,2,3]<br>Output: 3<br>Example 2:</p>
<p>Input: [2,2,1,1,1,2,2]<br>Output: 2</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>思路：这回想到了很多历遍的方法，但是感觉太蠢了，终于开始想怎么才能更好的实现了</li>
<li>在写写画画的时候突然考虑到，如果有超过一半的数量都是这个数的话，把这个list排序之后最中间的那个数肯定是这个数<ul>
<li>极限情况就是两个元素差1，这时候是多一点的那个数的边界上</li>
<li>其他的情况下就是在出现最多的那个数的中间</li>
</ul>
</li>
<li>本来想要用floor的，但是发现需要math包，所以用了 // 来求除之后的整数</li>
</ul>
<h1 id="229-Majority-Element-2"><a href="#229-Majority-Element-2" class="headerlink" title="229 Majority Element 2"></a>229 Majority Element 2</h1><p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</p>
<p>Note: The algorithm should run in linear time and in O(1) space.</p>
<p>Example 1:</p>
<p>Input: [3,2,3]<br>Output: [3]<br>Example 2:</p>
<p>Input: [1,1,1,3,3,2,2,2]<br>Output: [1,2]<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        major1,major2,count1,count2 = <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> major1 == n:</span><br><span class="line">                count1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> major2 ==n:</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count1 ==<span class="number">0</span>:</span><br><span class="line">                major1 = n</span><br><span class="line">                count1 = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count2 == <span class="number">0</span>:</span><br><span class="line">                major2 = n</span><br><span class="line">                count2 =<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count1 -= <span class="number">1</span></span><br><span class="line">                count2 -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [n <span class="keyword">for</span> n <span class="keyword">in</span> (major1,major2) <span class="keyword">if</span> nums.count(n) &gt; len(nums) // <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意这道题说的是出现次数大于1/3的数字，所以结果只有只能是没有，1个或者两个，不存在结果是三个的情况！</li>
<li>这个想了半天不会做，查了一下用的是<a href="https://www.zhihu.com/question/49973163/answer/235921864" target="_blank" rel="noopener">Boyer-Moore Majority Vote algorithm</a><ul>
<li>这个算法的主要意思是如果两拨人打架，打架一对一抵消，然后看看剩下的部分哪个比较多<ul>
<li>记录剩下的东西的方法就是增加了一个额外的部分，包括major和count两部分，major记录的是有剩余的数是什么，count记录还有多少个</li>
<li>如果count没有了，那么就从现在遇到的新的数开始记</li>
<li>如果现在的数不是需要的，那么count - 1，如果是现在需要的那么count + 1</li>
</ul>
</li>
<li>最开始是用在一个数组里面找超过一半的数的，但是我上一道题用了其他方法所以没用到</li>
<li>注意因为是求1/3的数字，所以虽然有剩下的，但是剩下的不一定都是符合要求的，需要再数一下个数对不对（这才有了return这一行里面的东西）</li>
</ul>
</li>
<li>人类的算法真是奇幻无穷</li>
</ul>
<h1 id="274-h-index"><a href="#274-h-index" class="headerlink" title="274 h-index"></a>274 h-index</h1><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”</p>
<p>Example:</p>
<p>Input: citations = [3,0,6,1,5]<br>Output: 3<br>Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had<br>             received 3, 0, 6, 1, 5 citations respectively.<br>             Since the researcher has 3 papers with at least 3 citations each and the remaining<br>             two with no more than 3 citations each, her h-index is 3.<br>Note: If there are several possible values for h, the maximum one is taken as the h-index.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> h_cand <span class="keyword">in</span> range(len(citations) + <span class="number">1</span>):</span><br><span class="line">            h_more = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> citation <span class="keyword">in</span> citations:</span><br><span class="line">                <span class="keyword">if</span> citation &gt;= h_cand:</span><br><span class="line">                    h_more += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> h_more &gt;= h_cand:</span><br><span class="line">                    result = max(result,h_cand)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>思路，非常直观的方法，直接iterate所有的元素，如果找到了更大的result的值就取最大的（根据题目要求）</li>
<li>注意的点在需要 <code>h_more &gt;= h_cand</code>而不是等于，因为给出的定义的意思是index-h是有h个的值大于等于h，h_more的个数会比h_cand多（但是因为取了下面的max，所以等于其实也是可以得）</li>
<li>这个的速度真的好慢，尝试一下binary search</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        bucket = [<span class="number">0</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(len(citations)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> citations:</span><br><span class="line">            <span class="keyword">if</span> nums &gt;= len(citations):</span><br><span class="line">                bucket[len(citations)] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bucket[nums] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> range(len(bucket)):</span><br><span class="line">            nums = len(bucket) - nums <span class="number">-1</span></span><br><span class="line">            result += bucket[nums]</span><br><span class="line">            <span class="keyword">if</span> result &gt;= nums:</span><br><span class="line">                <span class="keyword">return</span> nums</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用了桶排序的神奇方法</li>
<li>还是取决于定义，如果一共有5个paper的话，可以选的h的值有6个，分别是0 1 2 3 4 5，把这留个值分成六个桶，每个里面放的就是比这桶的inde等于的paper的数量<ul>
<li>如果总数直接大于最大的桶数，就放在最后一个里面</li>
<li>这是在第一个循环干的事情</li>
</ul>
</li>
<li>第二个循环里，把这些桶里面的值取出来就是比这个桶的index大于等于的paper的数量，从后往前数，如果这个paper的数量大于了现在的index，那就说明现在的index就是h！</li>
<li>这里学到了一个创建固定长度列表的方法<code>bucket = [0 for n in range(len(citations)+1)]</code></li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        citations.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,n <span class="keyword">in</span> enumerate(citations):</span><br><span class="line">            <span class="keyword">if</span> n &gt;= i+<span class="number">1</span>:</span><br><span class="line">                result = max(result,i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>再另一种思路，用了排序<ul>
<li>如果把这个list按降序排序的话，index的数量加一就是目前数过的paper的数量，citation[index]就是这个数量上面对应的citation的数量，这两个值应该正好相等，或者citation更大一点，需要在排好序的内容里面找到这一项！</li>
</ul>
</li>
<li>这样速度比桶排序稍微慢一点但是还是蛮快的，起码比第一种要快很多了</li>
</ul>
<h1 id="275-h-index-2"><a href="#275-h-index-2" class="headerlink" title="275 h-index 2"></a>275 h-index 2</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(citations)</span><br><span class="line">        l, r = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> citations[mid] &gt;= n-mid:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n-l</span><br></pre></td></tr></table></figure>
<ul>
<li>可以依然沿用上面的方法，但是可能是因为数据量上去的原因，所以速度变慢了</li>
<li>这里可以加入二分法搜索取代上面的直接iterate<ul>
<li>while的条件是因为移动一位，所以会出现l&gt;r的情况，在这种情况下就可以停下来了</li>
<li>二分法就是这么写的！</li>
</ul>
</li>
</ul>
<h1 id="217-contains-duplicate"><a href="#217-contains-duplicate" class="headerlink" title="217 contains duplicate"></a>217 contains duplicate</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> nums.count(n) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        setNums = set(nums)</span><br><span class="line">        <span class="keyword">if</span> len(setNums) == len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>消耗时间太长了！！</li>
<li>说明这个count的时间还是不可以</li>
<li>想到了用set但是没相当怎么用set<ul>
<li>set可以把有重复内容的变成没有重复内容的！！</li>
<li>所以set和list的长度是不一样的</li>
</ul>
</li>
</ul>
<h1 id="219-contains-duplicate2"><a href="#219-contains-duplicate2" class="headerlink" title="219 contains duplicate2"></a>219 contains duplicate2</h1><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1], k = 3<br>Output: true<br>Example 2:</p>
<p>Input: nums = [1,0,1,1], k = 1<br>Output: true<br>Example 3:</p>
<p>Input: nums = [1,2,3,1,2,3], k = 2<br>Output: false</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(set(nums)) &gt;= len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        extra = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> extra <span class="keyword">and</span> i-extra[n] &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            extra[n] = i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意这里需要找到的差的绝对值是最大是k，所以找到一个比k小的很容易！！只要找到就能返回</li>
<li>判断边界条件</li>
<li>把元素作为key放进extra里面，val是这个元素的index，因为key是唯一的所以可以一直找到离得最近的index，这样就越来越能确保满足条件，一旦满足条件就返回，如果所有的都不满足就false</li>
</ul>
<h1 id="220"><a href="#220" class="headerlink" title="220"></a>220</h1><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1], k = 3, t = 0<br>Output: true<br>Example 2:</p>
<p>Input: nums = [1,0,1,1], k = 1, t = 2<br>Output: true<br>Example 3:</p>
<p>Input: nums = [1,5,9,1,5,9], k = 2, t = 3<br>Output: false</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(self, nums: List[int], k: int, t: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> t &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        buckets = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            bucket = nums[i] // (t+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> bucket - <span class="number">1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> nums[i] - buckets[bucket<span class="number">-1</span>] &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> bucket + <span class="number">1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> buckets[bucket+<span class="number">1</span>] - nums[i] &lt;=t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            buckets[bucket] = nums[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                <span class="keyword">del</span> bucket[nums[i-k] // (t+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运用的是桶排序的思路，每个nums[i]会放在一个桶里，这个桶的宽度是这两个数字的差<ul>
<li>如果想要这两个数值的差值小于等于t，那么需要这两个数字在一个桶里或者在相邻的桶里（因为后面增加了k的判断条件，所以不用考虑k）</li>
</ul>
</li>
<li><p>思路</p>
<ul>
<li>首先考虑了一下k，如果i大于k的时候，就可以直接扔掉i-k之前的数据了，只考虑中间的k+1个数据，这样的话空间复杂度很低。这里的扔掉指的是把bucket里面的值直接扔掉，这样就避免了找到在相同的桶里面却i和j的差值超过k的问题</li>
<li>首先iterate整个nums，把不同的数字放在不同的桶里，注意桶的个数是t+1</li>
<li>然后如果在放之前这个桶有东西，或者相邻的桶的值和现在的值的差是小于等于t的，那么就存在，返回true</li>
<li>如果都不存在的话，把现在的数字放到对应的桶里面</li>
</ul>
</li>
<li><p>另外一个思路考虑的是二叉树的数据结构，用这个结构可以很快的搜索到离这个数最近的数据并且判断这个数据和这个数的差是不是小于t！</p>
</li>
</ul>
<h1 id="55-Jump-game"><a href="#55-Jump-game" class="headerlink" title="55 Jump game"></a>55 Jump game</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> []: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        current = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> current &gt;= <span class="number">0</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,current):</span><br><span class="line">                <span class="keyword">if</span> current - i &lt;= nums[i] <span class="keyword">and</span> current &gt;= i:</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    current = i</span><br><span class="line">                    <span class="keyword">if</span> current == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>虽然超时了但是写的还不错的iterate</li>
<li>=。=算了这就是一坨屎！！！</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        current = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> current - i &lt;= nums[i]:</span><br><span class="line">                current = i</span><br><span class="line">                <span class="keyword">if</span> current == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我的方法其实思路是没有问题的，主要在于太啰嗦了而且循环太多了，其实直接从后往前找就行了！！！从后往前找不用考虑怎么让他循环起来呀，直接一个一个往前推就可以了</li>
<li>前面那个的问题在于多叠了一个while，于是时间瞬间爆炸，写前面的那个的时候也在想着如何找回循环里面去，结果还是用了个蠢办法</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> j &lt; i: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            j = max(i+n,j) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>i+n就是从这步开始可以移动的最大距离，j是上一步可以移动的最大距离，这两个哪个大就走哪个</li>
<li>如果这个距离还赶不上i，那就说明走不到最后了，告辞</li>
</ul>
<h1 id="45-Jump-game-2"><a href="#45-Jump-game-2" class="headerlink" title="45 Jump game 2"></a>45 Jump game 2</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        step,maxend = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i+nums[i] &gt;= len(nums) <span class="number">-1</span>: <span class="keyword">return</span> step</span><br><span class="line">                maxend = max(maxend, i + nums[i])</span><br><span class="line">            start = end + <span class="number">1</span></span><br><span class="line">            end = maxend</span><br></pre></td></tr></table></figure>
<ul>
<li>实际上来说用的是BFS的思想，但是不是每次都把东西从queue里面拿出来，而是确定了每次寻找的开始的阀内</li>
<li>start和end分别代表现在可以开始寻找的开始和结束，如果在这个范围里面找到了符合要求的结果，那么直接返回这个步数，如果没找到的话就从下一个范围开始找，下一个范围是上一个范围的end+1 到目前能到的最大的范围</li>
<li>注意符合的要求是大于等于n-1而不是正好走到这个点</li>
<li>求maxend和之前的一样</li>
</ul>
<h1 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121 Best Time to Buy and Sell Stock"></a>121 Best Time to Buy and Sell Stock</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:</p>
<p>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br>             Not 7-1 = 6, as selling price needs to be larger than buying price.<br>Example 2:</p>
<p>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        minBuy = float(<span class="string">'inf'</span>)</span><br><span class="line">        maxProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">if</span> i &lt; minBuy:</span><br><span class="line">                minBuy = i</span><br><span class="line">            <span class="keyword">elif</span> i - minBuy &gt; maxProfit:</span><br><span class="line">                maxProfit = i - minBuy</span><br><span class="line">        <span class="keyword">return</span> maxProfit</span><br></pre></td></tr></table></figure>
<ul>
<li>用brute的算法会time limit，这里用的方法是用两个变量分别记录最低的价钱和最高的利润，这样的话只需要对数组遍历一次就能得到最终的结果</li>
<li>因为判断这个价钱低了的话，求这个东西的最大利润也就只能用这个最低价钱之后的东西求了，所以不会冲突</li>
</ul>
<h1 id="122"><a href="#122" class="headerlink" title="122"></a>122</h1><ul>
<li>现在可以进行多次交易了，但是每次之间不能重叠</li>
<li>其实只要后一次比前一次贵，这个profit就可以一直累计，分为一直上涨或者中间掉下来一下再重新买的感觉</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        maxProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                maxProfit += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> maxProfit</span><br></pre></td></tr></table></figure>
<h1 id="123"><a href="#123" class="headerlink" title="123"></a>123</h1><ul>
<li>现在最多进行两次交易,找到最大的利润</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        cost_1 = float(<span class="string">'inf'</span>)</span><br><span class="line">        profit_1 = <span class="number">0</span></span><br><span class="line">        cost_2 = float(<span class="string">'inf'</span>)</span><br><span class="line">        profit_2 = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            cost_1 = min(cost_1,price)</span><br><span class="line">            profit_1 = max(profit_1, price - cost_1)</span><br><span class="line">            cost_2 = min(cost_2,price - profit_1)</span><br><span class="line">            profit_2 = max(profit_2, price - cost_2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> profit_2</span><br></pre></td></tr></table></figure>
<ul>
<li>其中，下标带1的是第一次交易之后的结果，下标带2的是第二次交易之后的结果</li>
<li>从总体上来看，第二次买入之后花掉的钱实际上是<code>第二次买入的实际花费 - 第一次交易之后挣的钱</code>（可以是负数）。而第二次卖出之后的总的收益为 <code>第二次卖出的钱 - 第二次买入之后的实际花费</code></li>
<li>所以，如果需要利润最大，需要第二次买入的实际花费最小，需要第一次的利润最大，需要第一次买入的花费最小，最终形成了这个代码</li>
</ul>
<h1 id="188"><a href="#188" class="headerlink" title="188"></a>188</h1><ul>
<li>现在需要进行最多k次交易，把profit弄到最大</li>
<li>这部分好像大家都用到了DP</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= n/<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(i-j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(prices[<span class="number">1</span>:],prices[: <span class="number">-1</span>]) <span class="keyword">if</span> i &gt; j)</span><br><span class="line">        profits = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            preprofit = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                profit = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">                preprofit = max(preprofit + profit, profits[i])</span><br><span class="line">                profits[i] = max(preprofit, profits[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> profits[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>首先考虑边界条件，如果k的数量已经比n/2大了，那么可以直接认为可以进行无限次交易了，就和上面的第二题一样</li>
<li>主要思路就是现在定义了两个变量，一个变量表示在前i天完成的交易，已经得到的最大利润。另一个变量定义了在第i天卖出的话，这时候得到的最大利润。这两个变量的都是在在第j次交易里。</li>
<li>用一个长n的list profits来记录这个天数之后获得的利益。在k次交易中一直更新这个profits里面的最大值。所以实际上关于k的变量不需要考虑</li>
<li>首先分析在第i天得到的利润，就是这一天的价格减去前一天的价格。更新之前i天里面的总利润，就是把最开始的preprfit再加上这一天获得的利润，和本来的preprofit来比大小，更新preprofit</li>
<li>更新实际上第i天的利润，对比实际上前一天的利润和前i天的利润哪个大</li>
</ul>
<h1 id="309-中间带冷却的买股票"><a href="#309-中间带冷却的买股票" class="headerlink" title="309 中间带冷却的买股票"></a>309 中间带冷却的买股票</h1><ul>
<li>每次卖出去之后必须要cooldown一轮</li>
<li>用了dp和state machine来表示，一共会有三种状态<ul>
<li>s0(reset) -sell-&gt; s1 -cool-&gt; s2(reset) -buy-&gt; s0</li>
<li>用一个数组来记录在每天在这个状态里面的最大利润，然后再从最后一天的最大利润里面挑出来一个</li>
</ul>
</li>
<li>注意考虑边界条件</li>
<li>学会了一个新的初始化list的方法</li>
<li>感觉自己终于理解了dp呢（并没有）<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s0,s1,s2 = [<span class="number">0</span>]*n,[<span class="number">0</span>]*n,[<span class="number">0</span>]*n</span><br><span class="line">        s0[<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        s1[<span class="number">0</span>] = float(<span class="string">'-inf'</span>)</span><br><span class="line">        s2[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            price = prices[i]</span><br><span class="line">            s0[i] = max(s0[i<span class="number">-1</span>],s2[i<span class="number">-1</span>] - price)</span><br><span class="line">            s1[i] = s0[i<span class="number">-1</span>] + price</span><br><span class="line">            s2[i] = max(s1[i<span class="number">-1</span>],s2[i<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(s0[n<span class="number">-1</span>],s1[n<span class="number">-1</span>],s2[n<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="11-装水"><a href="#11-装水" class="headerlink" title="11 装水"></a>11 装水</h1><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(height)</span><br><span class="line">        start, end  = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            <span class="keyword">if</span> height[start] &gt;= height[end]:</span><br><span class="line">                maxArea = max(maxArea,height[end] * (end-start))</span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxArea = max(maxArea,height[start] * (end-start))</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br></pre></td></tr></table></figure>
<ul>
<li>这道题的重点在这个装水的大小是由比较短的那条边决定的。而且肯定是底边越长越牛逼，所以从底边最长的两边开始找，然后在两个高度里面取比较大的继续找下一个</li>
<li>需要用一个变量来储存 max area的大小（这个我想到了）</li>
<li>然后比较快的方法是从两遍开始逼近，这样的话只遍历了这个list一次，时间复杂度是n，好像有个排序算法和这个的想法也差不多</li>
<li>注意while的判断条件其实就是这个</li>
</ul>
<h1 id="42-装水"><a href="#42-装水" class="headerlink" title="42 装水"></a>42 装水</h1><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="/2019/05/07/Leetcode笔记/42.jpg" alt></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(height)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_max,right_max = [<span class="number">0</span>]*n,[<span class="number">0</span>]*n</span><br><span class="line">        left_max[<span class="number">0</span>],right_max[<span class="number">-1</span>] = height[<span class="number">0</span>],height[<span class="number">-1</span>]</span><br><span class="line">        maxTrap = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            left_max[i] = max(left_max[i<span class="number">-1</span>],height[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">0</span>,n<span class="number">-1</span>)):</span><br><span class="line">            right_max[i] = max(right_max[i+<span class="number">1</span>],height[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            maxTrap += min(left_max[i],right_max[i]) - height[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxTrap</span><br></pre></td></tr></table></figure>
<ul>
<li>用dp解决的这个问题</li>
<li>核心思想在竖着（按列）数每个格子，这个格子可不可以装水和左右两边的最高点有关，这个格子能装多少水和1.最短的高点和2.这个格子本身的高度有关</li>
<li>所以可以用三个循环搞定这个问题，用空间换时间，在list里面记录下来每个列对应的左边的最高点和右边的最高点，然后再数每个列的容量，大小是（左右最高中间短的那个） - （这个列对应的高度）</li>
</ul>
<h1 id="334-升序的三个数字"><a href="#334-升序的三个数字" class="headerlink" title="334 升序的三个数字"></a>334 升序的三个数字</h1><p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Formally the function should:</p>
<p>Return true if there exists i, j, k<br>such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.<br>Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingTriplet</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        first = float(<span class="string">'inf'</span>)</span><br><span class="line">        second = float(<span class="string">'inf'</span>)</span><br><span class="line">        third = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= first:</span><br><span class="line">                first = num</span><br><span class="line">            <span class="keyword">elif</span> num &gt; first <span class="keyword">and</span> num &lt;= second:</span><br><span class="line">                second = num</span><br><span class="line">            <span class="keyword">else</span>: third = num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (third != <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>我最初的思路没有错，需要有变量来保存这三个升序的东西</li>
<li>其实核心的思路在于，如果现在这个数比第一个升序的数字小，那么这个数字完全就可以成为新的第一个数字，比如 3 2 4 5，那么345和245没有什么本质的区别，而一旦third有了取值，那么就说明肯定已经有了一个结果</li>
</ul>
<h1 id="128"><a href="#128" class="headerlink" title="128"></a>128</h1><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<p>Example:</p>
<p>Input: [100, 4, 200, 1, 3, 2]<br>Output: 4<br>Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"><span class="comment">#         if nums == []: return 0</span></span><br><span class="line"><span class="comment">#         max_num = max(nums)</span></span><br><span class="line"><span class="comment">#         min_num = min(nums)</span></span><br><span class="line"><span class="comment">#         if max_num &gt; len(nums) or -max</span></span><br><span class="line"><span class="comment">#         if min_num &lt; 0:</span></span><br><span class="line"><span class="comment">#             max_num -= min_num</span></span><br><span class="line"><span class="comment">#         ass_list = [None] * (max_num + 1)</span></span><br><span class="line"><span class="comment">#         for i,num in enumerate(nums):</span></span><br><span class="line"><span class="comment"># #             确保都是正数</span></span><br><span class="line"><span class="comment">#             if min_num &lt; 0:</span></span><br><span class="line"><span class="comment">#                 num = num-min_num</span></span><br><span class="line"><span class="comment">#             ass_list[num] = 1</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#         max_length = 0</span></span><br><span class="line"><span class="comment">#         prev_length = 0</span></span><br><span class="line"><span class="comment">#         for i in range(len(ass_list)):</span></span><br><span class="line"><span class="comment">#             if ass_list[i] != None:</span></span><br><span class="line"><span class="comment">#                 max_length += 1</span></span><br><span class="line"><span class="comment">#             else:</span></span><br><span class="line"><span class="comment">#                 prev_length = max(max_length,prev_length)</span></span><br><span class="line"><span class="comment">#                 max_length = 0</span></span><br><span class="line"><span class="comment">#         return max(max_length,prev_length)</span></span><br><span class="line">        <span class="keyword">if</span> nums == []: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        current_length,prev_length = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        num_set = set(nums)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> num_set:</span><br><span class="line">            <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                current_num = num</span><br><span class="line">                <span class="keyword">while</span> current_num+<span class="number">1</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                    current_num += <span class="number">1</span></span><br><span class="line">                    current_length += <span class="number">1</span></span><br><span class="line">                prev_length = max(prev_length,current_length)</span><br><span class="line">                current_length = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(current_length, prev_length)</span><br></pre></td></tr></table></figure>
<ul>
<li>这个问题一开始的思路是错的，已经comment掉了，但是感觉这个想法其实就是更具体化的hash表而已，第一个思路是把所有的数字平均的放在一个list里面，然后每个数字的本身就对应的是他的index，这样的话就可以直接知道有哪些数字是连续的了。但是这种方法在数字特别大的时候空间上就爆炸了，空间复杂度也是和数字大小有关</li>
<li>这时候又要拿出来快乐的hash表了，记住python自己自带hash表</li>
<li>每遇到一个数字，需要判断这个数字的下一个数字在不在这个nums里面，如果在的话更新数字和长度，如果不再的话刷新计数器并且开始下一个数字</li>
<li>但是直接这样算还是会时间爆炸（比如一堆连续的只有一个是跳开的），所以又加进去了一个新的判断条件，这个条件的精髓在于，如果这个数之前的数字在nums里面，那么这个数在算他前面那个数的时候就应该被算上了，所以这部分就可以跳过这个数了，只有当前一个数字不在的时候才需要数长度</li>
</ul>
<h1 id="164"><a href="#164" class="headerlink" title="164"></a>164</h1><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>Example 1:</p>
<p>Input: [3,6,9,1]<br>Output: 3<br>Explanation: The sorted form of the array is [1,3,6,9], either<br>             (3,6) or (6,9) has the maximum difference 3.<br>Example 2:</p>
<p>Input: [10]<br>Output: 0<br>Explanation: The array contains less than 2 elements, therefore return 0.<br>Note:</p>
<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.<br>Try to solve it in linear time/space.</p>
<p><img src="/2019/05/07/Leetcode笔记/164.jpg" alt></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        max_gap = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            gap = nums[i] - nums[i<span class="number">-1</span>]</span><br><span class="line">            max_gap = max(max_gap, gap)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_gap</span><br></pre></td></tr></table></figure>
<ul>
<li>直接用python自带的排序速度不一定很慢，虽然只超过了百分了20的人但是最后还是跑出来了</li>
<li>这个方法非常直接了</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_num, min_num = max(nums), min(nums)</span><br><span class="line">        <span class="keyword">if</span> max_num == min_num: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        wide = max((max_num - min_num) // (n<span class="number">-1</span>),<span class="number">1</span>)</span><br><span class="line">        num_b = (max_num - min_num) // wide + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        maxGap = <span class="number">0</span></span><br><span class="line">        <span class="comment"># prev_bucket = float('-inf')</span></span><br><span class="line">        max_b = [<span class="number">0</span>]* num_b</span><br><span class="line">        min_b = [float(<span class="string">'inf'</span>)]* num_b</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            idx = (num-min_num) // wide</span><br><span class="line">            max_b[idx] = max(max_b[idx],num)</span><br><span class="line">            min_b[idx] = min(min_b[idx],num)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        prev_max = max_b[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,num_b):</span><br><span class="line">            <span class="keyword">if</span> max_b[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            maxGap = max(maxGap,min_b[i] - prev_max)</span><br><span class="line">            prev_max = max_b[i]</span><br><span class="line">        <span class="keyword">return</span> maxGap</span><br></pre></td></tr></table></figure>
<ul>
<li>这个桶排序终于写出来了，基本思路是上面的截图，需要注意的有几点<ul>
<li>第一，python不导入math的话没办法求ceiling，但是可以用 -（-a // b）来求</li>
<li>第二，在求bucket的个数的时候，需要多加上一个bucket，因为一个bucket里面最后的数字是放在下一个bucket里面最前面的</li>
<li>第三，可能会有空的bucket，所以不能直接用这个的min减去上一个的max，必须要留一个变量保存上一个的max</li>
<li>第四，当所有数字都相同的时候会变得很麻烦，最后加上去一个条件过滤掉这个部分</li>
</ul>
</li>
</ul>
<h1 id="28-implement-strStr（）"><a href="#28-implement-strStr（）" class="headerlink" title="28 implement strStr（）"></a>28 implement strStr（）</h1><p>Implement strStr().</p>
<p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<p>Example 1:</p>
<p>Input: haystack = “hello”, needle = “ll”<br>Output: 2<br>Example 2:</p>
<p>Input: haystack = “aaaaa”, needle = “bba”<br>Output: -1</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> needle == <span class="string">""</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(haystack):</span><br><span class="line">            <span class="keyword">if</span> ch == needle[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> needle == haystack[i:i+len(needle)]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>刚开始特别快乐的暴力破解了，真是万万没想到</li>
<li>感觉python处理起来字符串是真的开心</li>
<li>但是这个的时间不是很快乐</li>
</ul>
<ul>
<li>关于字符串匹配有另外两个算法KMP和BM（BM更快一点）</li>
</ul>
<h1 id="14"><a href="#14" class="headerlink" title="14"></a>14</h1><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string “”.</p>
<p>Example 1:</p>
<p>Input: [“flower”,”flow”,”flight”]<br>Output: “fl”<br>Example 2:</p>
<p>Input: [“dog”,”racecar”,”car”]<br>Output: “”<br>Explanation: There is no common prefix among the input strings.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(strs) == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> len(strs) == <span class="number">1</span>: <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">        LCP = self.compare(strs[<span class="number">0</span>],strs[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(strs)):</span><br><span class="line">            LCP = self.compare(LCP,strs[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> LCP</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(self,a,b)</span>:</span></span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(a) <span class="keyword">and</span> j &lt; len(b):</span><br><span class="line">            <span class="keyword">if</span> a[i] == b[i]:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> a[:counter]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>思路：平行比较，先找出来前两个里面的prefix，然后再用这个prefix和第三个东西比较</li>
<li>注意输入的长度是1的时候，需要输出整个字符串</li>
<li>注意如果比较失败了的话，要直接停止比较！</li>
</ul>
<h1 id="58"><a href="#58" class="headerlink" title="58"></a>58</h1><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>
<p>Example:</p>
<p>Input: “Hello World”<br>Output: 5<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s[<span class="number">-1</span>] == <span class="string">" "</span>: </span><br><span class="line">            s = s[:<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        new_str = s.split(<span class="string">" "</span>)</span><br><span class="line">        <span class="comment"># return new_str</span></span><br><span class="line">        print(new_str)</span><br><span class="line">        <span class="keyword">return</span> len(new_str[<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># cnt = 0</span></span><br><span class="line">        <span class="comment"># for v in reversed(s):</span></span><br><span class="line">        <span class="comment">#     if v.isspace():</span></span><br><span class="line">        <span class="comment">#         if cnt: break</span></span><br><span class="line">        <span class="comment">#     else: cnt += 1</span></span><br><span class="line">        <span class="comment"># return cnt</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>原来运行时间也很玄学</li>
<li>但是还是别人的代码看起来厉害一点！</li>
</ul>
<h1 id="387"><a href="#387" class="headerlink" title="387"></a>387</h1><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>
<p>Examples:</p>
<p>s = “leetcode”<br>return 0.</p>
<p>s = “loveleetcode”,<br>return 2.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        count = collections.Counter(s)</span><br><span class="line">        </span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> count[ch] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>居然有这么个东西叫做counter，感到震惊！！！</li>
</ul>
<h1 id="383"><a href="#383" class="headerlink" title="383"></a>383</h1><p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>
<p>Each letter in the magazine string can only be used once in your ransom note.</p>
<p>Note:<br>You may assume that both strings contain only lowercase letters.</p>
<p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p>
<ul>
<li><p>这个题目也太写意了吧，意思就是我需要写一个勒索信，然后要从杂志上面找单词，看看能不能用杂志上面的东西拼凑出来这个单词</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span><span class="params">(self, ransomNote: str, magazine: str)</span> -&gt; bool:</span></span><br><span class="line">        alphabet = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> magazine:</span><br><span class="line">            index = ord(ch) - ord(<span class="string">'a'</span>)</span><br><span class="line">            alphabet[index] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> ransomNote:</span><br><span class="line">            index = ord(ch) - ord(<span class="string">'a'</span>)</span><br><span class="line">            alphabet[index] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> alphabet[index] &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>看到了一个清奇的思路然后自己实现了一下</p>
<ul>
<li>统计magazine里面每个字母的数量，和需要的字母数量对比，如果不够的话就不行</li>
<li>我在写的时候多iteration了一次26个字母，但是其实在ransomNote里面直接对比和0的大小就可以了</li>
<li>感觉字母和数字最大的区别就在于字母有限而数字无限</li>
</ul>
</li>
</ul>
<h1 id="344"><a href="#344" class="headerlink" title="344"></a>344</h1><p>reverse一个list，要求in-place而且占用o1的空间<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length // <span class="number">2</span>):</span><br><span class="line">            temp = s[i]</span><br><span class="line">            s[i] = s[length - <span class="number">1</span> - i]</span><br><span class="line">            s[length - <span class="number">1</span> - i] = temp</span><br></pre></td></tr></table></figure></p>
<ul>
<li>其实可以不用temp的，直接用 s[i]，s[length - 1 - i] = s[length - 1 - i], s[i]就可以了</li>
</ul>
<h1 id="151"><a href="#151" class="headerlink" title="151"></a>151</h1><p>reverse一个string，让这句话倒过来，主要会有多个空格<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(s.split()[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<ul>
<li>python真的是很作弊了</li>
<li>split不加参数就可以直接分开所有大小的空格</li>
</ul>
<h1 id="70-爬楼梯-DP"><a href="#70-爬楼梯-DP" class="headerlink" title="70 爬楼梯 DP"></a>70 爬楼梯 DP</h1><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given n will be a positive integer.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n ==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        f = (n+<span class="number">1</span>)*[<span class="number">0</span>]<span class="comment">#走n节的时候可以有的方法数量</span></span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        f[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            f[i] = f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>
<ul>
<li>其实就相当于斐波那契数列，第i种的可能的方法是从i-2走一个2，以及从i-1走一个1的和</li>
</ul>
<h1 id="345"><a href="#345" class="headerlink" title="345"></a>345</h1><p>把一个string里面的原因反序</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        vowels = <span class="string">"AEIOUaeiou"</span></span><br><span class="line">        index = []</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> vowels:</span><br><span class="line">                index.append(i)</span><br><span class="line">        s = list(s)</span><br><span class="line">        i,j = <span class="number">0</span>,len(index)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            s[index[i]],s[index[j]] = s[index[j]],s[index[i]] </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(s)</span><br></pre></td></tr></table></figure>
<ul>
<li>首先判断哪个是原因</li>
<li>然后把元音的部分倒过来</li>
<li>.join把list转回string</li>
</ul>
<h1 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="205 Isomorphic Strings"></a>205 Isomorphic Strings</h1><p>Easy</p>
<p>767</p>
<p>217</p>
<p>Favorite</p>
<p>Share<br>Given two strings s and t, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in s can be replaced to get t.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<p>Example 1:</p>
<p>Input: s = “egg”, t = “add”<br>Output: true<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        sub_1,sub_2 = [<span class="number">0</span>]*<span class="number">256</span>,[<span class="number">0</span>]*<span class="number">256</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            a,b = s[i],t[i]</span><br><span class="line">            <span class="keyword">if</span> sub_1[ord(a)] != sub_2[ord(b)]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            sub_1[ord(a)] = i + <span class="number">1</span></span><br><span class="line">            sub_2[ord(b)] = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意这里面的mapping不一定是字母，也可以是数字</li>
<li>ascii码一共是256个，所以是不会超出这个范围的</li>
<li>主要思路就是这样的，两个数组分别记录的是对应位置的ascii码的mapping的位数，如果这两个位数不一样的话，就说明这两个的mapping方式有问题，所以return False，不然的话return True</li>
</ul>
<h1 id="290-word-pattern"><a href="#290-word-pattern" class="headerlink" title="290 word pattern"></a>290 word pattern</h1><p>Given a pattern and a string str, find if str follows the same pattern.</p>
<p>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</p>
<p>Example 1:</p>
<p>Input: pattern = “abba”, str = “dog cat cat dog”<br>Output: true<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span><span class="params">(self, pattern: str, str: str)</span> -&gt; bool:</span></span><br><span class="line">        pattern = list(pattern)</span><br><span class="line">        string = str.split(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">return</span> len(set(zip(pattern,string))) == len(set(string)) == len(set(pattern)) <span class="keyword">and</span> len(pattern) == len(string)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>又到了活用zip的时候，返回的是一个个对应的东西，也就是说返回的是<ul>
<li>a-dog,b-cat,b-cat,a-dog</li>
<li>这时候把他们转化成set，得到的就是不带重复的东西的长度</li>
</ul>
</li>
<li>如果匹配上的长度和原先的长度全都相同（去掉重复的元素），那么就证明匹配上了</li>
</ul>
<h1 id="49-变位词"><a href="#49-变位词" class="headerlink" title="49 变位词"></a>49 变位词</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="comment"># for i,item in enumerate(strs):</span></span><br><span class="line">        <span class="comment">#     item = list(item)</span></span><br><span class="line">        <span class="comment">#     item.sort()</span></span><br><span class="line">        <span class="comment">#     item = "".join(item)</span></span><br><span class="line">        <span class="comment">#     temp[i],temp_sort = item,item</span></span><br><span class="line">        <span class="comment"># temp_sort.sort()</span></span><br><span class="line">        <span class="comment"># print(temp,strs)</span></span><br><span class="line">        </span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">            key = <span class="string">""</span>.join(sorted(word))</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> d:</span><br><span class="line">                d.get(key).append(word)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[key] = [word]</span><br><span class="line">            <span class="comment"># d[key] = d.get(key,[]) + [word]</span></span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
<ul>
<li>核心思想 -&gt; 排序，排序之后的变位词就都一样了</li>
<li>leetcode 242,49<ul>
<li>这个题的核心思路就是，每个单词按字母顺序排序之后的答案就是这个单词的key，如果两个单词的key一样的话这两个单词就是变位词，如果不一样的话就是新的词</li>
<li>在python里面直接用字典可以很好的储存变位词</li>
</ul>
</li>
</ul>
<h1 id="56-merge-intervals"><a href="#56-merge-intervals" class="headerlink" title="56 merge intervals"></a>56 merge intervals</h1><p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>Example 1:</p>
<p>Input: [[1,3],[2,6],[8,10],[15,18]]<br>Output: [[1,6],[8,10],[15,18]]<br>Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x : x[<span class="number">0</span>])</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> output <span class="keyword">and</span> i[<span class="number">0</span>] &lt;= output[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">                output[<span class="number">-1</span>][<span class="number">1</span>] = max(output[<span class="number">-1</span>][<span class="number">1</span>], i[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output.append(i)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<ul>
<li>注意点：<ul>
<li>给的数据输入并不一定是排好序的，所以需要先排好序。这里用到了排序的key的功能。lambda是定义任意函数 g(x)= x[0]</li>
<li>需要输出的格式是list套list，所以需要append</li>
</ul>
</li>
<li>思路错了的一个方向是，其实每个i不应该和隔壁的i比大小，而是应该和output里面的最终结果比大小，因为需要考虑到好几个内容都可以合并的情况</li>
</ul>
<h1 id="57插入"><a href="#57插入" class="headerlink" title="57插入"></a>57插入</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        out = []</span><br><span class="line">        adding = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(intervals) == <span class="number">0</span>: <span class="keyword">return</span> [newInterval]</span><br><span class="line">        <span class="keyword">if</span> newInterval[<span class="number">1</span>] &lt; intervals[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">            out.append(newInterval)</span><br><span class="line">            adding = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> adding <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">if</span> newInterval[<span class="number">0</span>] &gt; i[<span class="number">1</span>]:</span><br><span class="line">                    out.append(i)</span><br><span class="line">                <span class="keyword">elif</span> newInterval[<span class="number">1</span>] &lt; i[<span class="number">0</span>]:</span><br><span class="line">                    out.append(newInterval)</span><br><span class="line">                    adding = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    after_insert = [min(i[<span class="number">0</span>],newInterval[<span class="number">0</span>]),max(i[<span class="number">1</span>],newInterval[<span class="number">1</span>])]</span><br><span class="line">                    out.append(after_insert)</span><br><span class="line">                    adding = <span class="literal">True</span></span><br><span class="line">                <span class="comment"># print("adding")</span></span><br><span class="line">            <span class="keyword">if</span> adding <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> i[<span class="number">0</span>] &gt; out[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">                    out.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    out[<span class="number">-1</span>][<span class="number">1</span>] = max(out[<span class="number">-1</span>][<span class="number">1</span>],i[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> adding <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            out.append(newInterval)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
<ul>
<li>自己苦思冥想了一个多小时的答案</li>
<li>有点繁琐，debug的时候主要是情况考虑的不够明确，包括没有考虑空的情况，在最后插入的情况，在最前插入的情况</li>
<li>但是最后总结的想，应该对插入的前后一视同仁，因为状况其实是差不多的，而我把前面分成了好多种状况，后面倒是写成了一种情况</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">left = []</span><br><span class="line">right = []</span><br><span class="line">s,e = newInterval[<span class="number">0</span>],newInterval[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">    <span class="keyword">if</span> i[<span class="number">1</span>] &lt; s:</span><br><span class="line">        left.append(i)</span><br><span class="line">    <span class="keyword">elif</span> i[<span class="number">0</span>] &gt; e:</span><br><span class="line">        right.append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s = min(i[<span class="number">0</span>],s)</span><br><span class="line">        e = max(i[<span class="number">1</span>],e)</span><br><span class="line"><span class="keyword">return</span> left + [[s,e]] + right</span><br></pre></td></tr></table></figure>
<ul>
<li>这是discussion里面的一种简要的解法，思路的不同就是他是每次都merge到new里面了（也就是s和e），而我是merge到out里面了</li>
<li>其实我的代码本身的也有merge到new的意思，但是被我分出了太多种太复杂的情况</li>
</ul>
<h1 id="101对称树"><a href="#101对称树" class="headerlink" title="101对称树"></a>101对称树</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        now = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            now.append(root)</span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            vals = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> now:</span><br><span class="line">                <span class="keyword">if</span> i:</span><br><span class="line">                    vals.append(i.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    vals.append(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> list(reversed(vals)) != vals: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now = [j <span class="keyword">for</span> i <span class="keyword">in</span> now <span class="keyword">if</span> i <span class="keyword">for</span> j <span class="keyword">in</span> (i.left, i.right)]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>遍历的方法，最后一个now的表达式值得学习</li>
<li>注意root是node，而这个node实际的值在vals里面，因为好久没处理node了所以忘记了这一点</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Symm</span><span class="params">(L,R)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> L <span class="keyword">and</span> R:</span><br><span class="line">            <span class="keyword">return</span> L.val == R.val <span class="keyword">and</span> Symm(L.left,R.right) <span class="keyword">and</span> Symm(L.right,R.left) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> L == R</span><br><span class="line">            <span class="comment"># return L is None and R is None #同等意义</span></span><br><span class="line">    <span class="keyword">return</span> Symm(root, root)</span><br><span class="line">    <span class="comment"># 没有关于空的树的判断条件，所以需要从root开始</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法过于优雅，我要哭出来了</li>
</ul>
<h1 id="87-Scramble-String"><a href="#87-Scramble-String" class="headerlink" title="87 Scramble String"></a>87 Scramble String</h1><p>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>
<p>Below is one possible representation of s1 = “great”:</p>
<pre><code>great
</code></pre><p>   /    \<br>  gr    eat<br> / \    /  \<br>g   r  e   at<br>           / \<br>          a   t<br>To scramble the string, we may choose any non-leaf node and swap its two children.</p>
<p>For example, if we choose the node “gr” and swap its two children, it produces a scrambled string “rgeat”.</p>
<pre><code>rgeat
</code></pre><p>   /    \<br>  rg    eat<br> / \    /  \<br>r   g  e   at<br>           / \<br>          a   t</p>
<ul>
<li>思路：<ul>
<li>首先，如果我这个单词的substring满足这个要求的话，上面一层的单词就满足这个要求，也就是说可以recursive的完成这个工作，对于不同的substring call这个函数来检验是否满足要求</li>
<li>边界条件：<ul>
<li>如果string的长度小于等于2，那么怎么换其实都是满足的</li>
<li>如果两个string直接相等，那么也是满足的</li>
</ul>
</li>
<li>先决条件：<ul>
<li>如果这两个string的长度都不一样，那么肯定也不一样</li>
<li>如果这两个string里面字母的sort之后都不一样，那么肯定不一样</li>
</ul>
</li>
<li>判断条件：<ul>
<li>对于一个string，如果从k位置来分的话，有两种不同的结果。or关系<ul>
<li>结果1：s1的前k个和s2的前k个一样 and s1的后n-k个和s2的后n-k个一样</li>
<li>结果2：s1的前k个和s2的后k个一样 and s1的前n-k个和s2的前n-k个一样</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        n1,n2 = len(s1),len(s2)</span><br><span class="line">        <span class="keyword">if</span> n1 != n2 <span class="keyword">or</span> sorted(s1) != sorted(s2): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> n1 &lt;= <span class="number">2</span> <span class="keyword">or</span> s1 == s2: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        f = self.isScramble</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n1):</span><br><span class="line">            <span class="keyword">if</span> (f(s1[<span class="number">0</span>:i], s2[<span class="number">0</span>:i]) <span class="keyword">and</span> f(s1[i:],s2[i:])) <span class="keyword">or</span> \</span><br><span class="line">            f(s1[<span class="number">0</span>:i], s2[n2-i:]) <span class="keyword">and</span> f(s1[i:],s2[<span class="number">0</span>:n2-i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="38-count-and-say"><a href="#38-count-and-say" class="headerlink" title="38 count and say"></a>38 count and say</h1><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221<br>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.</li>
</ol>
<p>Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<p><strong>自己的智障解法</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="string">"1"</span></span><br><span class="line">        </span><br><span class="line">        result = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            result = self.Say(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Say</span><span class="params">(self,num)</span>:</span></span><br><span class="line">        n = len(num)</span><br><span class="line">        counter = <span class="number">1</span></span><br><span class="line">        counters = <span class="string">""</span></span><br><span class="line">        nums = str(num[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> num[i] == num[i<span class="number">-1</span>]:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                counters += str(counter)</span><br><span class="line">                counter = <span class="number">1</span></span><br><span class="line">                nums += str(num[i])</span><br><span class="line">        counters += str(counter)</span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(counters)):</span><br><span class="line">            result += counters[i]</span><br><span class="line">            result += nums[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意，如果要把list接成string，需要先把里面的所有项都转成string</li>
<li>感觉自己还是很不擅长recursive</li>
</ul>
<h1 id="316-remove-deplicate-letters"><a href="#316-remove-deplicate-letters" class="headerlink" title="#316 remove deplicate letters"></a>#316 remove deplicate letters</h1><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p>Example 1:</p>
<p>Input: “bcabc”<br>Output: “abc”<br>Example 2:</p>
<p>Input: “cbacdcbc”<br>Output: “acdb”</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># s = sorted(s)</span></span><br><span class="line">        <span class="comment"># i = 0</span></span><br><span class="line">        <span class="comment"># for n in s:</span></span><br><span class="line">        <span class="comment">#     # print(n,i,s[i-1])</span></span><br><span class="line">        <span class="comment">#     if i &lt; 1 or n != s[i-1]:</span></span><br><span class="line">        <span class="comment">#         s[i] = n</span></span><br><span class="line">        <span class="comment">#         i += 1</span></span><br><span class="line">        <span class="comment"># return "".join(s[:i])</span></span><br><span class="line">        s = list(s)</span><br><span class="line">        result = []</span><br><span class="line">        last_occurrence = &#123;c: i <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s)&#125;</span><br><span class="line">        <span class="keyword">for</span> i,n <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                <span class="keyword">while</span> result <span class="keyword">and</span> n &lt; result[<span class="number">-1</span>] <span class="keyword">and</span> result[<span class="number">-1</span>] <span class="keyword">in</span> s[i:]:</span><br><span class="line">                    result.pop()</span><br><span class="line">                result.append(n)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(result)</span><br></pre></td></tr></table></figure>
<ul>
<li>这道题里面的重点在<strong>lexicographical order</strong><ul>
<li>也就是说，在操作的时候，如果这个字母在后面的位置上出现了，但是放在前面的位置上会导致前面变大，那么就取后面的那个结果</li>
</ul>
</li>
<li>本来我想的是可以先把没出现过的放进去，然后再刷新。但是直接放最好的应该更好一些</li>
<li>几种情况：<ul>
<li>如果已经出现了：那么直接跳过</li>
<li>如果没出现：<ul>
<li>如果比之前的小，并且前面的那个在后面还有，就得往前顶。还要考虑顶没了的情况，也就是result不为空</li>
<li>这里注意这三个条件是并列的，需要同时and。我刚开始把在后面出现放到循环里面去了，所以死循环了</li>
<li>在上面顶完之后，再把最新的加到最后</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="168-excel-column-title"><a href="#168-excel-column-title" class="headerlink" title="168 excel column title"></a>168 excel column title</h1><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<pre><code>1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB 
...
</code></pre><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertToTitle</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            letter = n % <span class="number">26</span></span><br><span class="line">            n = n // <span class="number">26</span></span><br><span class="line">            <span class="keyword">if</span> letter == <span class="number">0</span>:</span><br><span class="line">                letter = <span class="number">26</span></span><br><span class="line">                n = n<span class="number">-1</span></span><br><span class="line">            result.append(letter)</span><br><span class="line">        result = result[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i,item <span class="keyword">in</span> enumerate(result):</span><br><span class="line">            item += <span class="number">64</span></span><br><span class="line">            item = str(chr(item))</span><br><span class="line">            result[i] = item</span><br><span class="line">        <span class="comment"># print(result)</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(result)</span><br></pre></td></tr></table></figure>
<ul>
<li>自己的傻逼方法：<ul>
<li>最先得到的余数应该是最后的字母的值，所以这里出来的result需要翻转一下</li>
<li>翻转list最快的方法是 [::-1]</li>
<li>str(chr(n))把数字转成char，ord把char转成数字，大写A是65，小写a是97</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> num == <span class="number">0</span> <span class="keyword">else</span> self.convertToTitle((num - <span class="number">1</span>) / <span class="number">26</span>) + chr((num - <span class="number">1</span>) % <span class="number">26</span> + ord(<span class="string">'A'</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>大佬的一行</li>
<li>忘记了这种str的连接方法</li>
<li>直接减-1计算更方便</li>
</ul>
<h1 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171 Excel Sheet Column Number"></a>171 Excel Sheet Column Number</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">titleToNumber</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># s = s[::-1]</span></span><br><span class="line">        <span class="comment"># result = 0</span></span><br><span class="line">        <span class="comment"># for i,item in enumerate(s):</span></span><br><span class="line">        <span class="comment">#     result += 26^(i) + (ord(item) - ord("A"))</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> s == <span class="string">""</span> <span class="keyword">else</span> self.titleToNumber(s[:<span class="number">-1</span>]) * <span class="number">26</span> + ord(s[<span class="number">-1</span>]) - ord(<span class="string">"A"</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面那道题的友情题，模拟大佬写出了解法</li>
<li>注意list的上限，到-1的话是到-2不包括-1</li>
</ul>
<h1 id="13-roman-to-integer"><a href="#13-roman-to-integer" class="headerlink" title="13 roman to integer"></a>13 roman to integer</h1><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        trans = &#123;</span><br><span class="line">            <span class="string">"I"</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="string">"V"</span>:<span class="number">5</span>,</span><br><span class="line">            <span class="string">"X"</span>:<span class="number">10</span>,</span><br><span class="line">            <span class="string">"L"</span>:<span class="number">50</span>,</span><br><span class="line">            <span class="string">"C"</span>:<span class="number">100</span>,</span><br><span class="line">            <span class="string">"D"</span>:<span class="number">500</span>,</span><br><span class="line">            <span class="string">"M"</span>:<span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        s = s.replace(<span class="string">"IV"</span>,<span class="string">"IIII"</span>).replace(<span class="string">"IX"</span>,<span class="string">"VIIII"</span>)</span><br><span class="line">        s = s.replace(<span class="string">"XL"</span>,<span class="string">"XXXX"</span>).replace(<span class="string">"XC"</span>,<span class="string">"LXXXX"</span>)</span><br><span class="line">        s = s.replace(<span class="string">"CD"</span>,<span class="string">"CCCC"</span>).replace(<span class="string">"CM"</span>,<span class="string">"DCCCC"</span>)</span><br><span class="line">        </span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            result += trans[c]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<ul>
<li>比较典型的用dict解决的例子，善用string里面的replace方法</li>
</ul>
<h1 id="12-int-to-roman"><a href="#12-int-to-roman" class="headerlink" title="12 int to roman"></a>12 int to roman</h1><p>上面的友情题</p>
<ul>
<li>虽然可以穷举实现，但是我骄傲的自己写出来了recursive的方法</li>
<li>需要注意字母的替换顺序，不然会换错<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        space = [<span class="string">"M"</span>, <span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"L"</span>, <span class="string">"X"</span>, <span class="string">"V"</span>, <span class="string">"I"</span>]</span><br><span class="line">        trans = &#123;</span><br><span class="line">            <span class="string">"I"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">"V"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">"X"</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">"L"</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">"C"</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">"D"</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">"M"</span>: <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        s = self.find_raw(num, <span class="number">0</span>, space, trans)</span><br><span class="line"></span><br><span class="line">        s = s.replace(<span class="string">"DCCCC"</span>, <span class="string">"CM"</span>).replace(<span class="string">"CCCC"</span>, <span class="string">"CD"</span>)</span><br><span class="line">        s = s.replace(<span class="string">"LXXXX"</span>, <span class="string">"XC"</span>).replace(<span class="string">"XXXX"</span>, <span class="string">"XL"</span>)</span><br><span class="line">        s = s.replace(<span class="string">"VIIII"</span>, <span class="string">"IX"</span>).replace(<span class="string">"IIII"</span>, <span class="string">"IV"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_raw</span><span class="params">(self, num, name, space, trans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> num * <span class="string">"I"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = (num // trans[space[name]]) * space[name]</span><br><span class="line">            after = self.find_raw(</span><br><span class="line">                num % trans[space[name]], name + <span class="number">1</span>, space, trans)</span><br><span class="line">            <span class="keyword">return</span> temp + after</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.intToRoman(<span class="number">9</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="273-int-to-english"><a href="#273-int-to-english" class="headerlink" title="273 int to english"></a>273 int to english</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberToWords</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        t0to19 = [<span class="string">"Zero"</span>, <span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>, <span class="string">"Four"</span>, <span class="string">"Five"</span>, <span class="string">"Six"</span>, <span class="string">"Seven"</span>, <span class="string">"Eight"</span>, <span class="string">"Nine"</span>, <span class="string">"Ten"</span>, <span class="string">"Eleven"</span>,</span><br><span class="line">                  <span class="string">"Twelve"</span>, <span class="string">"Thirteen"</span>, <span class="string">"Fourteen"</span>,</span><br><span class="line">                  <span class="string">"Fifteen"</span>, <span class="string">"Sixteen"</span>, <span class="string">"Seventeen"</span>, <span class="string">"Eighteen"</span>, <span class="string">"Nineteen"</span>]</span><br><span class="line">        tens = [<span class="string">"Twenty"</span>, <span class="string">"Thirty"</span>, <span class="string">"Forty"</span>, <span class="string">"Fifty"</span>,</span><br><span class="line">                <span class="string">"Sixty"</span>, <span class="string">"Seventy"</span>, <span class="string">"Eighty"</span>, <span class="string">"Ninety"</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">word</span><span class="params">(num, i = <span class="number">0</span>)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">""</span>]</span><br><span class="line">            <span class="keyword">if</span> num &lt; <span class="number">20</span>:</span><br><span class="line">                <span class="keyword">return</span> [t0to19[num]]</span><br><span class="line">            <span class="keyword">if</span> num &lt; <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">return</span> [tens[num // <span class="number">10</span> - <span class="number">2</span>]] + word(num % <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span> num &lt; <span class="number">1000</span>:</span><br><span class="line">                <span class="keyword">return</span> [t0to19[num // <span class="number">100</span>]] + [<span class="string">"Hundred"</span>] + word(num % <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                trans = &#123;<span class="string">"Billion"</span>: int(<span class="number">1e9</span>), <span class="string">"Million"</span>: int(</span><br><span class="line">                    <span class="number">1e6</span>), <span class="string">"Thousand"</span>: int(<span class="number">1e3</span>)&#125;</span><br><span class="line">                part = [<span class="string">"Billion"</span>, <span class="string">"Million"</span>, <span class="string">"Thousand"</span>][i]</span><br><span class="line">                <span class="keyword">if</span> num // trans[part] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> word(num % trans[part], i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> word(num // trans[part]) + [part] + word(num % trans[part], i + <span class="number">1</span>)</span><br><span class="line">        s = word(num, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="string">""</span> <span class="keyword">in</span> s:</span><br><span class="line">            s.remove(<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(s) <span class="keyword">or</span> <span class="string">"Zero"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意移除空项的时候，需要用while而不是if</li>
<li>因为最后需要空格连接，所以最好先扔到list里面再出来</li>
<li>这题也太傻比了=。=无论怎么样都要自己手打这么多东西</li>
</ul>
<h1 id="68-text-justification"><a href="#68-text-justification" class="headerlink" title="# 68 text justification"></a># 68 text justification</h1><p>需要把这一行字左右对齐<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span><span class="params">(self, words: List[str], maxWidth: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="comment"># 每一行填满，如果填不满的时候，词的中间的空格尽量平均</span></span><br><span class="line">        <span class="comment"># 最后一行右边加空格</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每读一个单词后面需要加一行</span></span><br><span class="line">        space = <span class="number">0</span></span><br><span class="line">        line = [<span class="number">0</span>] <span class="comment"># 每一行开头的单词的坐标</span></span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            <span class="keyword">if</span> space + len(word) &lt; maxWidth:</span><br><span class="line">                space += len(word) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> space + len(word) == maxWidth <span class="keyword">and</span> i != len(words) - <span class="number">1</span>:</span><br><span class="line">                space = <span class="number">0</span></span><br><span class="line">                line.append(i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> space + len(word) &gt; maxWidth:</span><br><span class="line">                space = len(word) + <span class="number">1</span> <span class="comment">#注意这里的长度变化了</span></span><br><span class="line">                line.append(i)</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(line)):</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(line) - <span class="number">1</span>:</span><br><span class="line">                s = <span class="string">""</span></span><br><span class="line">                this_line = words[line[i]:line[i+<span class="number">1</span>]]</span><br><span class="line">                length = <span class="number">-1</span> <span class="comment"># 最后一个单词不带空格</span></span><br><span class="line">                <span class="keyword">for</span> w <span class="keyword">in</span> this_line:</span><br><span class="line">                    length += len(w) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> len(this_line) == <span class="number">1</span>:</span><br><span class="line">                    s = this_line[<span class="number">0</span>] + (maxWidth - len(this_line[<span class="number">0</span>])) * <span class="string">" "</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    space_len = (maxWidth - length) // (len(this_line) - <span class="number">1</span>)</span><br><span class="line">                    extra_space = (maxWidth - length) % (len(this_line) - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">for</span> i,w <span class="keyword">in</span> enumerate(this_line):</span><br><span class="line">                        <span class="keyword">if</span> i &lt; len(this_line) - <span class="number">1</span>:</span><br><span class="line">                            s = s + w + <span class="string">" "</span> + space_len*<span class="string">" "</span></span><br><span class="line">                            <span class="keyword">if</span> i &lt;= extra_space - <span class="number">1</span>:</span><br><span class="line">                                s = s + <span class="string">" "</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            s = s + w</span><br><span class="line">                output.append(s)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                this_line = words[line[i]:]</span><br><span class="line">                s = <span class="string">" "</span>.join(this_line)</span><br><span class="line">                s = s + <span class="string">" "</span>*(maxWidth-len(s))</span><br><span class="line">                output.append(s)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></p>
<ul>
<li>思路<ul>
<li>先分开单词</li>
<li>再往里插空格</li>
</ul>
</li>
</ul>
<h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>把整数转过来<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        Positive = <span class="literal">True</span></span><br><span class="line">        x2 = []</span><br><span class="line">        <span class="keyword">if</span> str(x)[<span class="number">0</span>] == <span class="string">"-"</span>:</span><br><span class="line">            Positive = <span class="literal">False</span></span><br><span class="line">            x = int(x - x * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">while</span> x &gt;= <span class="number">10</span>:</span><br><span class="line">            num = x % <span class="number">10</span></span><br><span class="line">            x = x // <span class="number">10</span></span><br><span class="line">            x2.append(str(num))</span><br><span class="line">        x2.append(str(x))</span><br><span class="line">        output = <span class="string">""</span>.join(x2)</span><br><span class="line">        output = int(output)</span><br><span class="line">        <span class="keyword">if</span> Positive:</span><br><span class="line">            output = int(output)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output = int(output) - <span class="number">2</span> * int(output)</span><br><span class="line">        <span class="keyword">if</span> output &gt; <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span> <span class="keyword">or</span> output &lt; <span class="number">-2</span>**<span class="number">31</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意啊2的31次方不是2e31啊啊我在干什么</li>
</ul>
<h1 id="165-Compare-Version-Numbers"><a href="#165-Compare-Version-Numbers" class="headerlink" title="165. Compare Version Numbers"></a>165. Compare Version Numbers</h1><ul>
<li><p>比较两个版本号，需要忽略里面的0</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compareVersion</span><span class="params">(self, version1: str, version2: str)</span> -&gt; int:</span></span><br><span class="line">        v1 = version1.split(<span class="string">"."</span>)</span><br><span class="line">        v2 = version2.split(<span class="string">"."</span>)</span><br><span class="line">        v1 = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> v1]</span><br><span class="line">        v2 = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> v2]</span><br><span class="line">        <span class="comment"># 可以简化为两行</span></span><br><span class="line">        <span class="comment"># versions1 = [int(v) for v in version1.split(".")]</span></span><br><span class="line">        <span class="comment"># versions2 = [int(v) for v in version2.split(".")]</span></span><br><span class="line">        <span class="keyword">if</span> len(v1) &gt; len(v2):</span><br><span class="line">            length = len(v2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            length = len(v1)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            c1,c2 = v1[i],v2[i]</span><br><span class="line">            <span class="keyword">if</span> c1 &gt; c2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c1 &lt; c2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            end = i</span><br><span class="line">        </span><br><span class="line">        rest1,rest2 = v1[i+<span class="number">1</span>:],v2[i+<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> sum(rest1) == sum(rest2): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> sum(rest1) &gt; sum(rest2): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> sum(rest1) &lt; sum(rest2): <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 另一种方法，更简洁</span></span><br><span class="line">        <span class="comment"># for i in range(max(len(versions1),len(versions2))):</span></span><br><span class="line">        <span class="comment">#     v1 = versions1[i] if i &lt; len(versions1) else 0</span></span><br><span class="line">        <span class="comment">#     v2 = versions2[i] if i &lt; len(versions2) else 0</span></span><br><span class="line">        <span class="comment">#     if v1 &gt; v2:</span></span><br><span class="line">        <span class="comment">#         return 1</span></span><br><span class="line">        <span class="comment">#     elif v1 &lt; v2:</span></span><br><span class="line">        <span class="comment">#         return -1;</span></span><br><span class="line">        <span class="comment"># return 0;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>需要考虑的主要就是长度不一样的情况和塞0的情况，我的想法是取比较小的总长度，然后再比较剩余的</p>
</li>
<li>大佬的情况是比较的所有的长度，如果超过了现在的长度就直接设置为0，这样不会影响比较。最后都比完都没差就是0</li>
</ul>
<h1 id="66"><a href="#66" class="headerlink" title="66"></a>66</h1><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p>Example 1:</p>
<p>Input: [1,2,3]<br>Output: [1,2,4]<br>Explanation: The array represents the integer 123.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(digits)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            digits[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> digits[i] &lt; <span class="number">10</span>: <span class="keyword">return</span> digits</span><br><span class="line">            digits[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> digits[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            digits.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">                digits[j] = digits[j<span class="number">-1</span>]</span><br><span class="line">            digits[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>
<ul>
<li>没啥好多说的，所有情况都考虑了就行了</li>
<li>但是其实，如果会产生进位，只有可能是因为最后一位是9，所以我这个判断条件稍微有一点没想清楚的感觉</li>
<li>下面这个写出来更加优雅<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(digits) == <span class="number">1</span> <span class="keyword">and</span> digits[<span class="number">0</span>] == <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> digits[<span class="number">-1</span>] != <span class="number">9</span>:</span><br><span class="line">            digits[<span class="number">-1</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> digits</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            digits[<span class="number">-1</span>] = <span class="number">0</span></span><br><span class="line">            digits[:<span class="number">-1</span>] = self.plusOne(digits[:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="258-一个数字的逐位相加，直到小于9"><a href="#258-一个数字的逐位相加，直到小于9" class="headerlink" title="258 一个数字的逐位相加，直到小于9"></a>258 一个数字的逐位相加，直到小于9</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addDigits</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        Sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> str(num):</span><br><span class="line">            Sum += int(i)</span><br><span class="line">        <span class="keyword">return</span> self.addDigits(Sum)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># if num == 0 : return 0</span></span><br><span class="line">        <span class="comment"># else:return (num - 1) % 9 + 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面那种方法是我写的，复杂度是n</li>
<li>下面的方法是数学规律，复杂度是1</li>
</ul>
<h1 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144 Binary Tree Preorder Traversal"></a>144 Binary Tree Preorder Traversal</h1><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>Example:</p>
<p>Input: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3</p>
<p>Output: [1,2,3]</p>
<ul>
<li>注意审题：这道题并不是按左小右大的顺序排列的，而且<code>preorder traversal</code>指的就是先访问root，再从左到右访问root的子节点</li>
<li>需要注意输入为空的情况</li>
<li>recursive和iterate都可以完成</li>
<li>在recursive里面，因为需要把内容储存在list里面，所以需要新建一个函数<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.preorder(root,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self,root,result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root: result.append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.left: </span><br><span class="line">            self.preorder(root.left,result)</span><br><span class="line">        <span class="keyword">if</span> root.right: </span><br><span class="line">            self.preorder(root.right,result)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            current = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> current:</span><br><span class="line">                result.append(current.val)</span><br><span class="line">                stack.append(current.right)</span><br><span class="line">                stack.append(current.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>注意因为是把内容放在stack里面，所以要先放right才能让他后出来</li>
<li>需要判断current是不是为空</li>
<li>pop默认的就是最后一位</li>
</ul>
<h1 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145 Binary Tree Postorder Traversal"></a>145 Binary Tree Postorder Traversal</h1><ul>
<li>和上一道题反序</li>
<li>注意虽然是post，但是还是需要先访问左child，再访问右child</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.post(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.post(root.left,res)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.post(root.right,res)</span><br><span class="line">        <span class="keyword">if</span> root: res.append(root.val)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            current = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> current:</span><br><span class="line">                res.append(current.val)</span><br><span class="line">                stack.append(current.left)</span><br><span class="line">                stack.append(current.right)</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>iterative的方法可以采用先处理右边的点，再处理左边的点。因为右边的后放进stack所以先出来先进res里面</li>
<li>最后再把结果倒序（牛逼）</li>
</ul>
<h1 id="102"><a href="#102" class="headerlink" title="102"></a>102</h1><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its level order traversal as:<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line"><span class="comment">#         self.levels = []</span></span><br><span class="line"><span class="comment">#         self.find(root,0)</span></span><br><span class="line"><span class="comment">#         return self.levels</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#     def find(self,node, level):</span></span><br><span class="line"><span class="comment">#         if node:</span></span><br><span class="line"><span class="comment">#             if len(self.levels) &lt;= level:</span></span><br><span class="line"><span class="comment">#                 self.levels += [[node.val]]</span></span><br><span class="line"><span class="comment">#             else:</span></span><br><span class="line"><span class="comment">#                 self.levels[level] += [node.val]</span></span><br><span class="line"><span class="comment">#             self.find(node.left, level + 1)</span></span><br><span class="line"><span class="comment">#             self.find(node.right,level + 1)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack, queue, nCount, res = [root],[],<span class="number">1</span>,[[root.val]]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            temp = stack.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> temp.left: stack.append(temp.left)</span><br><span class="line">            <span class="keyword">if</span> temp.right: stack.append(temp.right)</span><br><span class="line">            nCount -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nCount == <span class="number">0</span>:</span><br><span class="line">                queue = [x.val <span class="keyword">for</span> x <span class="keyword">in</span> stack]</span><br><span class="line">                <span class="keyword">if</span> queue:</span><br><span class="line">                    res += [queue]</span><br><span class="line">                nCount = len(stack) <span class="comment">#得到的是下一层的个数</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<ul>
<li>两种方法，重点是找到如何重新计数level的层级，第一种方法不是顺着一步一步写进结果里的，是跳着写进去的。第二个方法是直接写进去的</li>
</ul>
<h1 id="103-把树按层zigzag排列"><a href="#103-把树按层zigzag排列" class="headerlink" title="103 把树按层zigzag排列"></a>103 把树按层zigzag排列</h1><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its zigzag level order traversal as:<br>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        levels = []</span><br><span class="line">        self.Find(root,<span class="number">0</span>,levels)</span><br><span class="line">        <span class="keyword">return</span> levels</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, node, level, levels)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> len(levels) &lt;= level:</span><br><span class="line">                levels.append([node.val])</span><br><span class="line">            <span class="keyword">elif</span> level%<span class="number">2</span>:</span><br><span class="line">                levels[level].insert(<span class="number">0</span>,node.val)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> level%<span class="number">2</span>:</span><br><span class="line">                levels[level].append(node.val)</span><br><span class="line">            </span><br><span class="line">            self.Find(node.left,level+<span class="number">1</span>,levels)</span><br><span class="line">            self.Find(node.right,level+<span class="number">1</span>,levels)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>直接判断层数就可以实现，如果用一个flag表示没法在一整层的层面上实现</li>
<li>list是可以两端插入的</li>
</ul>
<h1 id="100-判断两个tree是不是一样的"><a href="#100-判断两个tree是不是一样的" class="headerlink" title="100 判断两个tree是不是一样的"></a>100 判断两个tree是不是一样的</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># if (not p and q) or (not q and p):</span></span><br><span class="line">        <span class="comment">#     return False</span></span><br><span class="line">        <span class="comment"># if p and q:</span></span><br><span class="line">        <span class="comment">#     if p.val != q.val: return False</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)</span></span><br><span class="line">        <span class="comment"># return p == q</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># if p and q:</span></span><br><span class="line">        <span class="comment">#     return p.val == q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)</span></span><br><span class="line">        <span class="comment"># return p == q</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">if</span> p.val != q.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br><span class="line">        <span class="keyword">return</span> p == q</span><br></pre></td></tr></table></figure>
<ul>
<li>感觉自己写recursive总是有点问题，需要判断好终极条件</li>
</ul>
<h1 id="226-把一个二叉树对称变换"><a href="#226-把一个二叉树对称变换" class="headerlink" title="226 把一个二叉树对称变换"></a>226 把一个二叉树对称变换</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不需要变换树的val，可以直接变换node</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># def invert(L,R):</span></span><br><span class="line">        <span class="comment">#     if L and R:</span></span><br><span class="line">        <span class="comment">#         L.val, R.val = R.val, L.val</span></span><br><span class="line">        <span class="comment">#         invert(L.left,R.right)</span></span><br><span class="line">        <span class="comment">#         invert(L.right,R.left)</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> root: </span><br><span class="line">            invert = self.invertTree</span><br><span class="line">            root.right, root.left = invert(root.left), invert(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<ul>
<li>需要换node而不是换val</li>
</ul>
<h1 id="257"><a href="#257" class="headerlink" title="257"></a>257</h1><p>Given a binary tree, return all root-to-leaf paths.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Input:</p>
<p>   1<br> /   \<br>2     3<br> \<br>  5</p>
<p>Output: [“1-&gt;2-&gt;5”, “1-&gt;3”]</p>
<p>Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root: TreeNode)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack = [(root,<span class="string">""</span>)]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            current,ls = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> current.left <span class="keyword">and</span> <span class="keyword">not</span> current.right:</span><br><span class="line">                result.append(ls+str(current.val))</span><br><span class="line">            <span class="keyword">if</span> current.right:</span><br><span class="line">                stack.append((current.right,ls+str(current.val)+<span class="string">"-&gt;"</span>))</span><br><span class="line">            <span class="keyword">if</span> current.left:</span><br><span class="line">                stack.append((current.left,ls+str(current.val)+<span class="string">"-&gt;"</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<ul>
<li>dfs的方法，终止条件是现在的点没有任何child了。自己搞错的地方主要是需要string跟着stack一起走，而不是两个分别判断。</li>
<li>同样的到底可以写出来第112题，本质上是一样的，就是把求路径换成了这个路径的和</li>
<li>同理写出来113，在tuple里面再加上路径的计算就可以了</li>
<li>129也同理！但是129可以直接在每次recursion里面把上一位数乘10，然后加上这一位数，这样会比得到所有路径再计算的速度快很多</li>
</ul>
<h1 id="111-找出这个tree的最小depth"><a href="#111-找出这个tree的最小depth" class="headerlink" title="111 找出这个tree的最小depth"></a>111 找出这个tree的最小depth</h1><ul>
<li>可以用BFS也可以用DFS，但是注意的是两个return的东西的条件是不一样的。DFS的时候必须把左右树比大小<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># stack = [(root,1)]</span></span><br><span class="line">        <span class="comment"># while stack:</span></span><br><span class="line">        <span class="comment">#     current,depth = stack.pop(0)</span></span><br><span class="line">        <span class="comment">#     if not current.left and not current.right:</span></span><br><span class="line">        <span class="comment">#         return depth</span></span><br><span class="line">        <span class="comment">#     if current.left:</span></span><br><span class="line">        <span class="comment">#         stack.append((current.left,depth+1))</span></span><br><span class="line">        <span class="comment">#     if current.right:</span></span><br><span class="line">        <span class="comment">#         stack.append((current.right,depth+1))</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#         dfs</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> max(self.minDepth(root.left),self.minDepth(root.right))+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> min(self.minDepth(root.left),self.minDepth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="104"><a href="#104" class="headerlink" title="104"></a>104</h1><ul>
<li>寻找最深的层</li>
<li>不用判断条件，直接dfs每次加一就可以实现了<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># if not root.left and not root.right:</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left),self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="110-判断是不是平衡树"><a href="#110-判断是不是平衡树" class="headerlink" title="110 判断是不是平衡树"></a>110 判断是不是平衡树</h1><ul>
<li>recursion的方法，注意的是每次返回的时候连带着子树是否平衡一起返回的，整体思路和之前的带着深度一起返回的感觉差不多</li>
<li>或者也可以直接设置一个函数，计算出各个部分的height，然后再放到isBalance里面从上到下计算<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(root)[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> (<span class="number">0</span>, <span class="literal">True</span>) <span class="comment">#depth, if_balance</span></span><br><span class="line">        l_depth, l_balance = self.dfs(root.left)</span><br><span class="line">        r_depth, r_balance = self.dfs(root.right)</span><br><span class="line">        <span class="keyword">return</span> max(l_depth,r_depth)+<span class="number">1</span>, l_balance <span class="keyword">and</span> r_balance <span class="keyword">and</span> abs(l_depth-r_depth) &lt;= <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="337-213"><a href="#337-213" class="headerlink" title="337/213"></a>337/213</h1><p>都是贼偷东西，不能连着偷两家。简单的动态规划问题。<br>这个问题的主要思路如下：</p>
<ul>
<li>对于每一家，其实都有两种情况：偷这家和不偷这家情况下得到的钱<ul>
<li>偷这家的时候，偷到的钱等于：这家的钱+前一家（childnode）不偷时候得到的钱</li>
<li>不偷这家的时候，偷到得钱等于：max（偷前一家，不偷前一家）<ul>
<li><strong>注意这种情况下，前一家可以偷可以不偷，取决于有多少钱</strong><br>三个题如下：</li>
</ul>
</li>
</ul>
</li>
<li>最简单的情况是数组</li>
<li>中等情况是一个环，即数组的收尾不能连着偷。在这种情况下其实就是计算两次，一次不偷第一家，一次不偷最后一家，看哪种情况多</li>
<li>最后的情况是二叉树的情况，这种情况下可以给每个点都规定一个tuple分别表示偷了和没偷的结果</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#第二种情况下</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> max(self.simple_rob(nums[<span class="number">1</span>:]),self.simple_rob(nums[:<span class="number">-1</span>]))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simple_rob</span><span class="params">(self,nums)</span>:</span></span><br><span class="line">        rob,not_rob = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            rob,not_rob = not_rob+n, max(not_rob,rob)</span><br><span class="line">        <span class="keyword">return</span> max(rob,not_rob)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#第三种情况下</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> max(self.dfs(root))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>,<span class="number">0</span>) <span class="comment"># [0]steal this node, [1] don't steal this node</span></span><br><span class="line">        left = self.dfs(root.left)</span><br><span class="line">        right = self.dfs(root.right)</span><br><span class="line">        <span class="keyword">return</span> (root.val + left[<span class="number">1</span>] + right[<span class="number">1</span>],max(left[<span class="number">0</span>],left[<span class="number">1</span>]) + max(right[<span class="number">0</span>],right[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<h1 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235 Lowest Common Ancestor of a Binary Search Tree"></a>235 Lowest Common Ancestor of a Binary Search Tree</h1><ul>
<li>找到给的两个点的最低的公共的祖先（parent）</li>
<li>其实需要注意这个思路，思路就是当这两个点都比现在的root小的时候，那这个公共点在root的左边，如果都小的时候就在右边。</li>
<li>因为这里要找的是最low的公共点，也就是离root最远的点</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> max(p.val,q.val) &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        <span class="keyword">if</span> min(p.val,q.val) &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1 id="236"><a href="#236" class="headerlink" title="236"></a>236</h1><ul>
<li>依然是找公共祖先，但是不是在BST里面找而是普通的二叉树里面找了，所以也就是不能用BST的性质了<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root==p <span class="keyword">or</span> root ==q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">or</span> right</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="108"><a href="#108" class="headerlink" title="108"></a>108</h1><p> Convert Sorted Array to Binary Search Tree</p>
<ul>
<li>注意，已经给了排好序的array了，而且需要的结果是height-balance的，这里可以直接取这个array最中间的作为root，然后左右分别recursion</li>
<li>如果用平常的插入方法，插入进来的树不一定是平衡的<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = len(nums) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        </span><br><span class="line">        root.left = self.sortedArrayToBST(nums[:mid])</span><br><span class="line">        root.right = self.sortedArrayToBST(nums[mid+<span class="number">1</span>:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="77-回溯法，列举所有组合"><a href="#77-回溯法，列举所有组合" class="headerlink" title="77 回溯法，列举所有组合"></a>77 回溯法，列举所有组合</h1><ul>
<li>回溯法需要注意三个阶段<ul>
<li>可以选择的条件是什么（需要在这些条件里迭代)</li>
<li>对条件的限制是什么。比如在这个例子里面，如果一个数字用过了就不能再用了。不能实现或者已经实现的条件需要弹出</li>
<li>目标：需要得到一个base case。比如这个题里面，字符串的长度到了k，就需要输入了</li>
</ul>
</li>
<li>用于问题种类：计算或者列举全部的可能</li>
<li>这道题的python的问题，在list里面append之后pop明显会出现一些问题</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/07/CS231nassignment2Pytorch/" rel="next" title="CS231Nassignment2之Pytorch">
                <i class="fa fa-chevron-left"></i> CS231Nassignment2之Pytorch
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/08/OpenCV19/" rel="prev" title="学习OpenCV第19章，投影和3D视觉">
                学习OpenCV第19章，投影和3D视觉 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpeg" alt="RUOPENG XU">
            
              <p class="site-author-name" itemprop="name">RUOPENG XU</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">64</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">63</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/Bigphess" title="GitHub &rarr; https://github.com/Bigphess" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:xrp0308@gmail.com" title="E-Mail &rarr; mailto:xrp0308@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#进度："><span class="nav-number">1.</span> <span class="nav-text">进度：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-twoSum"><span class="nav-number">2.</span> <span class="nav-text">1 twoSum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-remove-element"><span class="nav-number">3.</span> <span class="nav-text">27 remove element</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#80"><span class="nav-number">4.</span> <span class="nav-text">80</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#189-Rotate-array"><span class="nav-number">5.</span> <span class="nav-text">189 Rotate array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#思路"><span class="nav-number">6.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#另一种方法：in-place"><span class="nav-number">7.</span> <span class="nav-text">另一种方法：in-place</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41-First-Missing-Positive"><span class="nav-number">8.</span> <span class="nav-text">41 First Missing Positive</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第一个思路：时间nlog-n"><span class="nav-number">9.</span> <span class="nav-text">第一个思路：时间nlog(n)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#299"><span class="nav-number">10.</span> <span class="nav-text">299</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#134-gas-station"><span class="nav-number">11.</span> <span class="nav-text">134 gas station</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#118-Pascal’s-Triangle"><span class="nav-number">12.</span> <span class="nav-text">118 Pascal’s Triangle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#119-杨辉三角形2"><span class="nav-number">13.</span> <span class="nav-text">119 杨辉三角形2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#169-Majority-Element"><span class="nav-number">14.</span> <span class="nav-text">169 Majority Element</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#229-Majority-Element-2"><span class="nav-number">15.</span> <span class="nav-text">229 Majority Element 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#274-h-index"><span class="nav-number">16.</span> <span class="nav-text">274 h-index</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#275-h-index-2"><span class="nav-number">17.</span> <span class="nav-text">275 h-index 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#217-contains-duplicate"><span class="nav-number">18.</span> <span class="nav-text">217 contains duplicate</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#219-contains-duplicate2"><span class="nav-number">19.</span> <span class="nav-text">219 contains duplicate2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#220"><span class="nav-number">20.</span> <span class="nav-text">220</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#55-Jump-game"><span class="nav-number">21.</span> <span class="nav-text">55 Jump game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#45-Jump-game-2"><span class="nav-number">22.</span> <span class="nav-text">45 Jump game 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-number">23.</span> <span class="nav-text">121 Best Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#122"><span class="nav-number">24.</span> <span class="nav-text">122</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#123"><span class="nav-number">25.</span> <span class="nav-text">123</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#188"><span class="nav-number">26.</span> <span class="nav-text">188</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#309-中间带冷却的买股票"><span class="nav-number">27.</span> <span class="nav-text">309 中间带冷却的买股票</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-装水"><span class="nav-number">28.</span> <span class="nav-text">11 装水</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42-装水"><span class="nav-number">29.</span> <span class="nav-text">42 装水</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#334-升序的三个数字"><span class="nav-number">30.</span> <span class="nav-text">334 升序的三个数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#128"><span class="nav-number">31.</span> <span class="nav-text">128</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#164"><span class="nav-number">32.</span> <span class="nav-text">164</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-implement-strStr（）"><span class="nav-number">33.</span> <span class="nav-text">28 implement strStr（）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14"><span class="nav-number">34.</span> <span class="nav-text">14</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#58"><span class="nav-number">35.</span> <span class="nav-text">58</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#387"><span class="nav-number">36.</span> <span class="nav-text">387</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#383"><span class="nav-number">37.</span> <span class="nav-text">383</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#344"><span class="nav-number">38.</span> <span class="nav-text">344</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#151"><span class="nav-number">39.</span> <span class="nav-text">151</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#70-爬楼梯-DP"><span class="nav-number">40.</span> <span class="nav-text">70 爬楼梯 DP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#345"><span class="nav-number">41.</span> <span class="nav-text">345</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#205-Isomorphic-Strings"><span class="nav-number">42.</span> <span class="nav-text">205 Isomorphic Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#290-word-pattern"><span class="nav-number">43.</span> <span class="nav-text">290 word pattern</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-变位词"><span class="nav-number">44.</span> <span class="nav-text">49 变位词</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56-merge-intervals"><span class="nav-number">45.</span> <span class="nav-text">56 merge intervals</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#57插入"><span class="nav-number">46.</span> <span class="nav-text">57插入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#101对称树"><span class="nav-number">47.</span> <span class="nav-text">101对称树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#87-Scramble-String"><span class="nav-number">48.</span> <span class="nav-text">87 Scramble String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-count-and-say"><span class="nav-number">49.</span> <span class="nav-text">38 count and say</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#316-remove-deplicate-letters"><span class="nav-number">50.</span> <span class="nav-text">#316 remove deplicate letters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#168-excel-column-title"><span class="nav-number">51.</span> <span class="nav-text">168 excel column title</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#171-Excel-Sheet-Column-Number"><span class="nav-number">52.</span> <span class="nav-text">171 Excel Sheet Column Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-roman-to-integer"><span class="nav-number">53.</span> <span class="nav-text">13 roman to integer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-int-to-roman"><span class="nav-number">54.</span> <span class="nav-text">12 int to roman</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#273-int-to-english"><span class="nav-number">55.</span> <span class="nav-text">273 int to english</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#68-text-justification"><span class="nav-number">56.</span> <span class="nav-text"># 68 text justification</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6"><span class="nav-number">57.</span> <span class="nav-text">6</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#165-Compare-Version-Numbers"><span class="nav-number">58.</span> <span class="nav-text">165. Compare Version Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66"><span class="nav-number">59.</span> <span class="nav-text">66</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#258-一个数字的逐位相加，直到小于9"><span class="nav-number">60.</span> <span class="nav-text">258 一个数字的逐位相加，直到小于9</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#144-Binary-Tree-Preorder-Traversal"><span class="nav-number">61.</span> <span class="nav-text">144 Binary Tree Preorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#145-Binary-Tree-Postorder-Traversal"><span class="nav-number">62.</span> <span class="nav-text">145 Binary Tree Postorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#102"><span class="nav-number">63.</span> <span class="nav-text">102</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#103-把树按层zigzag排列"><span class="nav-number">64.</span> <span class="nav-text">103 把树按层zigzag排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#100-判断两个tree是不是一样的"><span class="nav-number">65.</span> <span class="nav-text">100 判断两个tree是不是一样的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#226-把一个二叉树对称变换"><span class="nav-number">66.</span> <span class="nav-text">226 把一个二叉树对称变换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#257"><span class="nav-number">67.</span> <span class="nav-text">257</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#111-找出这个tree的最小depth"><span class="nav-number">68.</span> <span class="nav-text">111 找出这个tree的最小depth</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#104"><span class="nav-number">69.</span> <span class="nav-text">104</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#110-判断是不是平衡树"><span class="nav-number">70.</span> <span class="nav-text">110 判断是不是平衡树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#337-213"><span class="nav-number">71.</span> <span class="nav-text">337/213</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="nav-number">72.</span> <span class="nav-text">235 Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#236"><span class="nav-number">73.</span> <span class="nav-text">236</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#108"><span class="nav-number">74.</span> <span class="nav-text">108</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#77-回溯法，列举所有组合"><span class="nav-number">75.</span> <span class="nav-text">77 回溯法，列举所有组合</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  
    <div id="sidebar-dimmer"></div>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RUOPENG XU</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
